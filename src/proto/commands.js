/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.anytype = (function() {

    /**
     * Namespace anytype.
     * @exports anytype
     * @namespace
     */
    var anytype = {};

    anytype.Rpc = (function() {

        /**
         * Properties of a Rpc.
         * @memberof anytype
         * @interface IRpc
         */

        /**
         * Constructs a new Rpc.
         * @memberof anytype
         * @classdesc Represents a Rpc.
         * @implements IRpc
         * @constructor
         * @param {anytype.IRpc=} [properties] Properties to set
         */
        function Rpc(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new Rpc instance using the specified properties.
         * @function create
         * @memberof anytype.Rpc
         * @static
         * @param {anytype.IRpc=} [properties] Properties to set
         * @returns {anytype.Rpc} Rpc instance
         */
        Rpc.create = function create(properties) {
            return new Rpc(properties);
        };

        /**
         * Encodes the specified Rpc message. Does not implicitly {@link anytype.Rpc.verify|verify} messages.
         * @function encode
         * @memberof anytype.Rpc
         * @static
         * @param {anytype.IRpc} message Rpc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rpc.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified Rpc message, length delimited. Does not implicitly {@link anytype.Rpc.verify|verify} messages.
         * @function encodeDelimited
         * @memberof anytype.Rpc
         * @static
         * @param {anytype.IRpc} message Rpc message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rpc.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Rpc message from the specified reader or buffer.
         * @function decode
         * @memberof anytype.Rpc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {anytype.Rpc} Rpc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rpc.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Rpc message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof anytype.Rpc
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {anytype.Rpc} Rpc
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rpc.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Rpc message.
         * @function verify
         * @memberof anytype.Rpc
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Rpc.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        /**
         * Creates a Rpc message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof anytype.Rpc
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {anytype.Rpc} Rpc
         */
        Rpc.fromObject = function fromObject(object) {
            if (object instanceof $root.anytype.Rpc)
                return object;
            return new $root.anytype.Rpc();
        };

        /**
         * Creates a plain object from a Rpc message. Also converts values to other types if specified.
         * @function toObject
         * @memberof anytype.Rpc
         * @static
         * @param {anytype.Rpc} message Rpc
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Rpc.toObject = function toObject() {
            return {};
        };

        /**
         * Converts this Rpc to JSON.
         * @function toJSON
         * @memberof anytype.Rpc
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Rpc.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Rpc.ExternalDrop = (function() {

            /**
             * Properties of an ExternalDrop.
             * @memberof anytype.Rpc
             * @interface IExternalDrop
             */

            /**
             * Constructs a new ExternalDrop.
             * @memberof anytype.Rpc
             * @classdesc Represents an ExternalDrop.
             * @implements IExternalDrop
             * @constructor
             * @param {anytype.Rpc.IExternalDrop=} [properties] Properties to set
             */
            function ExternalDrop(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ExternalDrop instance using the specified properties.
             * @function create
             * @memberof anytype.Rpc.ExternalDrop
             * @static
             * @param {anytype.Rpc.IExternalDrop=} [properties] Properties to set
             * @returns {anytype.Rpc.ExternalDrop} ExternalDrop instance
             */
            ExternalDrop.create = function create(properties) {
                return new ExternalDrop(properties);
            };

            /**
             * Encodes the specified ExternalDrop message. Does not implicitly {@link anytype.Rpc.ExternalDrop.verify|verify} messages.
             * @function encode
             * @memberof anytype.Rpc.ExternalDrop
             * @static
             * @param {anytype.Rpc.IExternalDrop} message ExternalDrop message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExternalDrop.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ExternalDrop message, length delimited. Does not implicitly {@link anytype.Rpc.ExternalDrop.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Rpc.ExternalDrop
             * @static
             * @param {anytype.Rpc.IExternalDrop} message ExternalDrop message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExternalDrop.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExternalDrop message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Rpc.ExternalDrop
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Rpc.ExternalDrop} ExternalDrop
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExternalDrop.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.ExternalDrop();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExternalDrop message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Rpc.ExternalDrop
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Rpc.ExternalDrop} ExternalDrop
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExternalDrop.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExternalDrop message.
             * @function verify
             * @memberof anytype.Rpc.ExternalDrop
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExternalDrop.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an ExternalDrop message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Rpc.ExternalDrop
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Rpc.ExternalDrop} ExternalDrop
             */
            ExternalDrop.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Rpc.ExternalDrop)
                    return object;
                return new $root.anytype.Rpc.ExternalDrop();
            };

            /**
             * Creates a plain object from an ExternalDrop message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Rpc.ExternalDrop
             * @static
             * @param {anytype.Rpc.ExternalDrop} message ExternalDrop
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExternalDrop.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ExternalDrop to JSON.
             * @function toJSON
             * @memberof anytype.Rpc.ExternalDrop
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExternalDrop.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            ExternalDrop.Files = (function() {

                /**
                 * Properties of a Files.
                 * @memberof anytype.Rpc.ExternalDrop
                 * @interface IFiles
                 */

                /**
                 * Constructs a new Files.
                 * @memberof anytype.Rpc.ExternalDrop
                 * @classdesc Represents a Files.
                 * @implements IFiles
                 * @constructor
                 * @param {anytype.Rpc.ExternalDrop.IFiles=} [properties] Properties to set
                 */
                function Files(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Files instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.ExternalDrop.Files
                 * @static
                 * @param {anytype.Rpc.ExternalDrop.IFiles=} [properties] Properties to set
                 * @returns {anytype.Rpc.ExternalDrop.Files} Files instance
                 */
                Files.create = function create(properties) {
                    return new Files(properties);
                };

                /**
                 * Encodes the specified Files message. Does not implicitly {@link anytype.Rpc.ExternalDrop.Files.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.ExternalDrop.Files
                 * @static
                 * @param {anytype.Rpc.ExternalDrop.IFiles} message Files message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Files.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Files message, length delimited. Does not implicitly {@link anytype.Rpc.ExternalDrop.Files.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.ExternalDrop.Files
                 * @static
                 * @param {anytype.Rpc.ExternalDrop.IFiles} message Files message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Files.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Files message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.ExternalDrop.Files
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.ExternalDrop.Files} Files
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Files.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.ExternalDrop.Files();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Files message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.ExternalDrop.Files
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.ExternalDrop.Files} Files
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Files.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Files message.
                 * @function verify
                 * @memberof anytype.Rpc.ExternalDrop.Files
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Files.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Files message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.ExternalDrop.Files
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.ExternalDrop.Files} Files
                 */
                Files.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.ExternalDrop.Files)
                        return object;
                    return new $root.anytype.Rpc.ExternalDrop.Files();
                };

                /**
                 * Creates a plain object from a Files message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.ExternalDrop.Files
                 * @static
                 * @param {anytype.Rpc.ExternalDrop.Files} message Files
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Files.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Files to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.ExternalDrop.Files
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Files.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Files.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.ExternalDrop.Files
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {string|null} [focusedBlockId] Request focusedBlockId
                     * @property {Array.<string>|null} [localFilePaths] Request localFilePaths
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.ExternalDrop.Files
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.ExternalDrop.Files.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        this.localFilePaths = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.ExternalDrop.Files.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request focusedBlockId.
                     * @member {string} focusedBlockId
                     * @memberof anytype.Rpc.ExternalDrop.Files.Request
                     * @instance
                     */
                    Request.prototype.focusedBlockId = "";

                    /**
                     * Request localFilePaths.
                     * @member {Array.<string>} localFilePaths
                     * @memberof anytype.Rpc.ExternalDrop.Files.Request
                     * @instance
                     */
                    Request.prototype.localFilePaths = $util.emptyArray;

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.ExternalDrop.Files.Request
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Files.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.ExternalDrop.Files.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.ExternalDrop.Files.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.ExternalDrop.Files.Request
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Files.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.focusedBlockId != null && message.hasOwnProperty("focusedBlockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.focusedBlockId);
                        if (message.localFilePaths != null && message.localFilePaths.length)
                            for (var i = 0; i < message.localFilePaths.length; ++i)
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.localFilePaths[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.ExternalDrop.Files.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.ExternalDrop.Files.Request
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Files.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.ExternalDrop.Files.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.ExternalDrop.Files.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.ExternalDrop.Files.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                message.focusedBlockId = reader.string();
                                break;
                            case 3:
                                if (!(message.localFilePaths && message.localFilePaths.length))
                                    message.localFilePaths = [];
                                message.localFilePaths.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.ExternalDrop.Files.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.ExternalDrop.Files.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.ExternalDrop.Files.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.focusedBlockId != null && message.hasOwnProperty("focusedBlockId"))
                            if (!$util.isString(message.focusedBlockId))
                                return "focusedBlockId: string expected";
                        if (message.localFilePaths != null && message.hasOwnProperty("localFilePaths")) {
                            if (!Array.isArray(message.localFilePaths))
                                return "localFilePaths: array expected";
                            for (var i = 0; i < message.localFilePaths.length; ++i)
                                if (!$util.isString(message.localFilePaths[i]))
                                    return "localFilePaths: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.ExternalDrop.Files.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.ExternalDrop.Files.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.ExternalDrop.Files.Request)
                            return object;
                        var message = new $root.anytype.Rpc.ExternalDrop.Files.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.focusedBlockId != null)
                            message.focusedBlockId = String(object.focusedBlockId);
                        if (object.localFilePaths) {
                            if (!Array.isArray(object.localFilePaths))
                                throw TypeError(".anytype.Rpc.ExternalDrop.Files.Request.localFilePaths: array expected");
                            message.localFilePaths = [];
                            for (var i = 0; i < object.localFilePaths.length; ++i)
                                message.localFilePaths[i] = String(object.localFilePaths[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.ExternalDrop.Files.Request
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Files.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.localFilePaths = [];
                        if (options.defaults) {
                            object.contextId = "";
                            object.focusedBlockId = "";
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.focusedBlockId != null && message.hasOwnProperty("focusedBlockId"))
                            object.focusedBlockId = message.focusedBlockId;
                        if (message.localFilePaths && message.localFilePaths.length) {
                            object.localFilePaths = [];
                            for (var j = 0; j < message.localFilePaths.length; ++j)
                                object.localFilePaths[j] = message.localFilePaths[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.ExternalDrop.Files.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Files.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.ExternalDrop.Files
                     * @interface IResponse
                     * @property {anytype.Rpc.ExternalDrop.Files.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.ExternalDrop.Files
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.ExternalDrop.Files.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.ExternalDrop.Files.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.ExternalDrop.Files.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.ExternalDrop.Files.Response
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Files.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.ExternalDrop.Files.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.ExternalDrop.Files.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.ExternalDrop.Files.Response
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Files.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.ExternalDrop.Files.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.ExternalDrop.Files.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.ExternalDrop.Files.Response
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Files.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.ExternalDrop.Files.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.ExternalDrop.Files.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.ExternalDrop.Files.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.ExternalDrop.Files.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.ExternalDrop.Files.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.ExternalDrop.Files.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.ExternalDrop.Files.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.ExternalDrop.Files.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.ExternalDrop.Files.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.ExternalDrop.Files.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.ExternalDrop.Files.Response)
                            return object;
                        var message = new $root.anytype.Rpc.ExternalDrop.Files.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.ExternalDrop.Files.Response.error: object expected");
                            message.error = $root.anytype.Rpc.ExternalDrop.Files.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.ExternalDrop.Files.Response
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Files.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.ExternalDrop.Files.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.ExternalDrop.Files.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response
                         * @interface IError
                         * @property {anytype.Rpc.ExternalDrop.Files.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.ExternalDrop.Files.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.ExternalDrop.Files.Response.Error.Code} code
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response.Error
                         * @static
                         * @param {anytype.Rpc.ExternalDrop.Files.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.ExternalDrop.Files.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.ExternalDrop.Files.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response.Error
                         * @static
                         * @param {anytype.Rpc.ExternalDrop.Files.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.ExternalDrop.Files.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response.Error
                         * @static
                         * @param {anytype.Rpc.ExternalDrop.Files.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.ExternalDrop.Files.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.ExternalDrop.Files.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.ExternalDrop.Files.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.ExternalDrop.Files.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.ExternalDrop.Files.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.ExternalDrop.Files.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response.Error
                         * @static
                         * @param {anytype.Rpc.ExternalDrop.Files.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.ExternalDrop.Files.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.ExternalDrop.Files.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.ExternalDrop.Files.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Files;
            })();

            ExternalDrop.Content = (function() {

                /**
                 * Properties of a Content.
                 * @memberof anytype.Rpc.ExternalDrop
                 * @interface IContent
                 */

                /**
                 * Constructs a new Content.
                 * @memberof anytype.Rpc.ExternalDrop
                 * @classdesc Represents a Content.
                 * @implements IContent
                 * @constructor
                 * @param {anytype.Rpc.ExternalDrop.IContent=} [properties] Properties to set
                 */
                function Content(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Content instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.ExternalDrop.Content
                 * @static
                 * @param {anytype.Rpc.ExternalDrop.IContent=} [properties] Properties to set
                 * @returns {anytype.Rpc.ExternalDrop.Content} Content instance
                 */
                Content.create = function create(properties) {
                    return new Content(properties);
                };

                /**
                 * Encodes the specified Content message. Does not implicitly {@link anytype.Rpc.ExternalDrop.Content.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.ExternalDrop.Content
                 * @static
                 * @param {anytype.Rpc.ExternalDrop.IContent} message Content message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Content.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Content message, length delimited. Does not implicitly {@link anytype.Rpc.ExternalDrop.Content.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.ExternalDrop.Content
                 * @static
                 * @param {anytype.Rpc.ExternalDrop.IContent} message Content message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Content.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Content message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.ExternalDrop.Content
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.ExternalDrop.Content} Content
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Content.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.ExternalDrop.Content();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Content message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.ExternalDrop.Content
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.ExternalDrop.Content} Content
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Content.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Content message.
                 * @function verify
                 * @memberof anytype.Rpc.ExternalDrop.Content
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Content.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Content message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.ExternalDrop.Content
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.ExternalDrop.Content} Content
                 */
                Content.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.ExternalDrop.Content)
                        return object;
                    return new $root.anytype.Rpc.ExternalDrop.Content();
                };

                /**
                 * Creates a plain object from a Content message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.ExternalDrop.Content
                 * @static
                 * @param {anytype.Rpc.ExternalDrop.Content} message Content
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Content.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Content to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.ExternalDrop.Content
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Content.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Content.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.ExternalDrop.Content
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {string|null} [focusedBlockId] Request focusedBlockId
                     * @property {Uint8Array|null} [content] Request content
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.ExternalDrop.Content
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.ExternalDrop.Content.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.ExternalDrop.Content.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request focusedBlockId.
                     * @member {string} focusedBlockId
                     * @memberof anytype.Rpc.ExternalDrop.Content.Request
                     * @instance
                     */
                    Request.prototype.focusedBlockId = "";

                    /**
                     * Request content.
                     * @member {Uint8Array} content
                     * @memberof anytype.Rpc.ExternalDrop.Content.Request
                     * @instance
                     */
                    Request.prototype.content = $util.newBuffer([]);

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.ExternalDrop.Content.Request
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Content.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.ExternalDrop.Content.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.ExternalDrop.Content.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.ExternalDrop.Content.Request
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Content.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.focusedBlockId != null && message.hasOwnProperty("focusedBlockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.focusedBlockId);
                        if (message.content != null && message.hasOwnProperty("content"))
                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.content);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.ExternalDrop.Content.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.ExternalDrop.Content.Request
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Content.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.ExternalDrop.Content.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.ExternalDrop.Content.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.ExternalDrop.Content.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                message.focusedBlockId = reader.string();
                                break;
                            case 3:
                                message.content = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.ExternalDrop.Content.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.ExternalDrop.Content.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.ExternalDrop.Content.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.focusedBlockId != null && message.hasOwnProperty("focusedBlockId"))
                            if (!$util.isString(message.focusedBlockId))
                                return "focusedBlockId: string expected";
                        if (message.content != null && message.hasOwnProperty("content"))
                            if (!(message.content && typeof message.content.length === "number" || $util.isString(message.content)))
                                return "content: buffer expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.ExternalDrop.Content.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.ExternalDrop.Content.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.ExternalDrop.Content.Request)
                            return object;
                        var message = new $root.anytype.Rpc.ExternalDrop.Content.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.focusedBlockId != null)
                            message.focusedBlockId = String(object.focusedBlockId);
                        if (object.content != null)
                            if (typeof object.content === "string")
                                $util.base64.decode(object.content, message.content = $util.newBuffer($util.base64.length(object.content)), 0);
                            else if (object.content.length)
                                message.content = object.content;
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.ExternalDrop.Content.Request
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Content.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contextId = "";
                            object.focusedBlockId = "";
                            if (options.bytes === String)
                                object.content = "";
                            else {
                                object.content = [];
                                if (options.bytes !== Array)
                                    object.content = $util.newBuffer(object.content);
                            }
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.focusedBlockId != null && message.hasOwnProperty("focusedBlockId"))
                            object.focusedBlockId = message.focusedBlockId;
                        if (message.content != null && message.hasOwnProperty("content"))
                            object.content = options.bytes === String ? $util.base64.encode(message.content, 0, message.content.length) : options.bytes === Array ? Array.prototype.slice.call(message.content) : message.content;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.ExternalDrop.Content.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Content.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.ExternalDrop.Content
                     * @interface IResponse
                     * @property {anytype.Rpc.ExternalDrop.Content.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.ExternalDrop.Content
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.ExternalDrop.Content.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.ExternalDrop.Content.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.ExternalDrop.Content.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.ExternalDrop.Content.Response
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Content.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.ExternalDrop.Content.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.ExternalDrop.Content.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.ExternalDrop.Content.Response
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Content.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.ExternalDrop.Content.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.ExternalDrop.Content.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.ExternalDrop.Content.Response
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Content.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.ExternalDrop.Content.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.ExternalDrop.Content.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.ExternalDrop.Content.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.ExternalDrop.Content.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.ExternalDrop.Content.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.ExternalDrop.Content.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.ExternalDrop.Content.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.ExternalDrop.Content.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.ExternalDrop.Content.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.ExternalDrop.Content.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.ExternalDrop.Content.Response)
                            return object;
                        var message = new $root.anytype.Rpc.ExternalDrop.Content.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.ExternalDrop.Content.Response.error: object expected");
                            message.error = $root.anytype.Rpc.ExternalDrop.Content.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.ExternalDrop.Content.Response
                     * @static
                     * @param {anytype.Rpc.ExternalDrop.Content.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.ExternalDrop.Content.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.ExternalDrop.Content.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response
                         * @interface IError
                         * @property {anytype.Rpc.ExternalDrop.Content.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.ExternalDrop.Content.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.ExternalDrop.Content.Response.Error.Code} code
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response.Error
                         * @static
                         * @param {anytype.Rpc.ExternalDrop.Content.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.ExternalDrop.Content.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.ExternalDrop.Content.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response.Error
                         * @static
                         * @param {anytype.Rpc.ExternalDrop.Content.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.ExternalDrop.Content.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response.Error
                         * @static
                         * @param {anytype.Rpc.ExternalDrop.Content.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.ExternalDrop.Content.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.ExternalDrop.Content.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.ExternalDrop.Content.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.ExternalDrop.Content.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.ExternalDrop.Content.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.ExternalDrop.Content.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response.Error
                         * @static
                         * @param {anytype.Rpc.ExternalDrop.Content.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.ExternalDrop.Content.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.ExternalDrop.Content.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.ExternalDrop.Content.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Content;
            })();

            return ExternalDrop;
        })();

        Rpc.BlockList = (function() {

            /**
             * Properties of a BlockList.
             * @memberof anytype.Rpc
             * @interface IBlockList
             */

            /**
             * Constructs a new BlockList.
             * @memberof anytype.Rpc
             * @classdesc Represents a BlockList.
             * @implements IBlockList
             * @constructor
             * @param {anytype.Rpc.IBlockList=} [properties] Properties to set
             */
            function BlockList(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new BlockList instance using the specified properties.
             * @function create
             * @memberof anytype.Rpc.BlockList
             * @static
             * @param {anytype.Rpc.IBlockList=} [properties] Properties to set
             * @returns {anytype.Rpc.BlockList} BlockList instance
             */
            BlockList.create = function create(properties) {
                return new BlockList(properties);
            };

            /**
             * Encodes the specified BlockList message. Does not implicitly {@link anytype.Rpc.BlockList.verify|verify} messages.
             * @function encode
             * @memberof anytype.Rpc.BlockList
             * @static
             * @param {anytype.Rpc.IBlockList} message BlockList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockList.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified BlockList message, length delimited. Does not implicitly {@link anytype.Rpc.BlockList.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Rpc.BlockList
             * @static
             * @param {anytype.Rpc.IBlockList} message BlockList message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BlockList.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BlockList message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Rpc.BlockList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Rpc.BlockList} BlockList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockList.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.BlockList();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BlockList message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Rpc.BlockList
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Rpc.BlockList} BlockList
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BlockList.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BlockList message.
             * @function verify
             * @memberof anytype.Rpc.BlockList
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BlockList.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a BlockList message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Rpc.BlockList
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Rpc.BlockList} BlockList
             */
            BlockList.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Rpc.BlockList)
                    return object;
                return new $root.anytype.Rpc.BlockList();
            };

            /**
             * Creates a plain object from a BlockList message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Rpc.BlockList
             * @static
             * @param {anytype.Rpc.BlockList} message BlockList
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BlockList.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this BlockList to JSON.
             * @function toJSON
             * @memberof anytype.Rpc.BlockList
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BlockList.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            BlockList.Move = (function() {

                /**
                 * Properties of a Move.
                 * @memberof anytype.Rpc.BlockList
                 * @interface IMove
                 */

                /**
                 * Constructs a new Move.
                 * @memberof anytype.Rpc.BlockList
                 * @classdesc Represents a Move.
                 * @implements IMove
                 * @constructor
                 * @param {anytype.Rpc.BlockList.IMove=} [properties] Properties to set
                 */
                function Move(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Move instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.BlockList.Move
                 * @static
                 * @param {anytype.Rpc.BlockList.IMove=} [properties] Properties to set
                 * @returns {anytype.Rpc.BlockList.Move} Move instance
                 */
                Move.create = function create(properties) {
                    return new Move(properties);
                };

                /**
                 * Encodes the specified Move message. Does not implicitly {@link anytype.Rpc.BlockList.Move.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.BlockList.Move
                 * @static
                 * @param {anytype.Rpc.BlockList.IMove} message Move message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Move.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Move message, length delimited. Does not implicitly {@link anytype.Rpc.BlockList.Move.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.BlockList.Move
                 * @static
                 * @param {anytype.Rpc.BlockList.IMove} message Move message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Move.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Move message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.BlockList.Move
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.BlockList.Move} Move
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Move.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.BlockList.Move();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Move message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.BlockList.Move
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.BlockList.Move} Move
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Move.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Move message.
                 * @function verify
                 * @memberof anytype.Rpc.BlockList.Move
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Move.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Move message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.BlockList.Move
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.BlockList.Move} Move
                 */
                Move.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.BlockList.Move)
                        return object;
                    return new $root.anytype.Rpc.BlockList.Move();
                };

                /**
                 * Creates a plain object from a Move message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.BlockList.Move
                 * @static
                 * @param {anytype.Rpc.BlockList.Move} message Move
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Move.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Move to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.BlockList.Move
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Move.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Move.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.BlockList.Move
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {Array.<string>|null} [blockIds] Request blockIds
                     * @property {string|null} [targetContextId] Request targetContextId
                     * @property {string|null} [dropTargetId] Request dropTargetId
                     * @property {anytype.model.Block.Position|null} [position] Request position
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.BlockList.Move
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.BlockList.Move.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        this.blockIds = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request blockIds.
                     * @member {Array.<string>} blockIds
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @instance
                     */
                    Request.prototype.blockIds = $util.emptyArray;

                    /**
                     * Request targetContextId.
                     * @member {string} targetContextId
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @instance
                     */
                    Request.prototype.targetContextId = "";

                    /**
                     * Request dropTargetId.
                     * @member {string} dropTargetId
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @instance
                     */
                    Request.prototype.dropTargetId = "";

                    /**
                     * Request position.
                     * @member {anytype.model.Block.Position} position
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @instance
                     */
                    Request.prototype.position = 0;

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @static
                     * @param {anytype.Rpc.BlockList.Move.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.BlockList.Move.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.BlockList.Move.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @static
                     * @param {anytype.Rpc.BlockList.Move.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.blockIds != null && message.blockIds.length)
                            for (var i = 0; i < message.blockIds.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockIds[i]);
                        if (message.targetContextId != null && message.hasOwnProperty("targetContextId"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.targetContextId);
                        if (message.dropTargetId != null && message.hasOwnProperty("dropTargetId"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.dropTargetId);
                        if (message.position != null && message.hasOwnProperty("position"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.position);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.BlockList.Move.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @static
                     * @param {anytype.Rpc.BlockList.Move.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.BlockList.Move.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.BlockList.Move.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                if (!(message.blockIds && message.blockIds.length))
                                    message.blockIds = [];
                                message.blockIds.push(reader.string());
                                break;
                            case 3:
                                message.targetContextId = reader.string();
                                break;
                            case 4:
                                message.dropTargetId = reader.string();
                                break;
                            case 5:
                                message.position = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.BlockList.Move.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.blockIds != null && message.hasOwnProperty("blockIds")) {
                            if (!Array.isArray(message.blockIds))
                                return "blockIds: array expected";
                            for (var i = 0; i < message.blockIds.length; ++i)
                                if (!$util.isString(message.blockIds[i]))
                                    return "blockIds: string[] expected";
                        }
                        if (message.targetContextId != null && message.hasOwnProperty("targetContextId"))
                            if (!$util.isString(message.targetContextId))
                                return "targetContextId: string expected";
                        if (message.dropTargetId != null && message.hasOwnProperty("dropTargetId"))
                            if (!$util.isString(message.dropTargetId))
                                return "dropTargetId: string expected";
                        if (message.position != null && message.hasOwnProperty("position"))
                            switch (message.position) {
                            default:
                                return "position: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.BlockList.Move.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.BlockList.Move.Request)
                            return object;
                        var message = new $root.anytype.Rpc.BlockList.Move.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.blockIds) {
                            if (!Array.isArray(object.blockIds))
                                throw TypeError(".anytype.Rpc.BlockList.Move.Request.blockIds: array expected");
                            message.blockIds = [];
                            for (var i = 0; i < object.blockIds.length; ++i)
                                message.blockIds[i] = String(object.blockIds[i]);
                        }
                        if (object.targetContextId != null)
                            message.targetContextId = String(object.targetContextId);
                        if (object.dropTargetId != null)
                            message.dropTargetId = String(object.dropTargetId);
                        switch (object.position) {
                        case "None":
                        case 0:
                            message.position = 0;
                            break;
                        case "Top":
                        case 1:
                            message.position = 1;
                            break;
                        case "Bottom":
                        case 2:
                            message.position = 2;
                            break;
                        case "Left":
                        case 3:
                            message.position = 3;
                            break;
                        case "Right":
                        case 4:
                            message.position = 4;
                            break;
                        case "Inner":
                        case 5:
                            message.position = 5;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @static
                     * @param {anytype.Rpc.BlockList.Move.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.blockIds = [];
                        if (options.defaults) {
                            object.contextId = "";
                            object.targetContextId = "";
                            object.dropTargetId = "";
                            object.position = options.enums === String ? "None" : 0;
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.blockIds && message.blockIds.length) {
                            object.blockIds = [];
                            for (var j = 0; j < message.blockIds.length; ++j)
                                object.blockIds[j] = message.blockIds[j];
                        }
                        if (message.targetContextId != null && message.hasOwnProperty("targetContextId"))
                            object.targetContextId = message.targetContextId;
                        if (message.dropTargetId != null && message.hasOwnProperty("dropTargetId"))
                            object.dropTargetId = message.dropTargetId;
                        if (message.position != null && message.hasOwnProperty("position"))
                            object.position = options.enums === String ? $root.anytype.model.Block.Position[message.position] : message.position;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.BlockList.Move.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Move.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.BlockList.Move
                     * @interface IResponse
                     * @property {anytype.Rpc.BlockList.Move.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.BlockList.Move
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.BlockList.Move.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.BlockList.Move.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.BlockList.Move.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.BlockList.Move.Response
                     * @static
                     * @param {anytype.Rpc.BlockList.Move.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.BlockList.Move.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.BlockList.Move.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.BlockList.Move.Response
                     * @static
                     * @param {anytype.Rpc.BlockList.Move.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.BlockList.Move.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.BlockList.Move.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.BlockList.Move.Response
                     * @static
                     * @param {anytype.Rpc.BlockList.Move.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.BlockList.Move.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.BlockList.Move.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.BlockList.Move.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.BlockList.Move.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.BlockList.Move.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.BlockList.Move.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.BlockList.Move.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.BlockList.Move.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.BlockList.Move.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.BlockList.Move.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.BlockList.Move.Response)
                            return object;
                        var message = new $root.anytype.Rpc.BlockList.Move.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.BlockList.Move.Response.error: object expected");
                            message.error = $root.anytype.Rpc.BlockList.Move.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.BlockList.Move.Response
                     * @static
                     * @param {anytype.Rpc.BlockList.Move.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.BlockList.Move.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.BlockList.Move.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.BlockList.Move.Response
                         * @interface IError
                         * @property {anytype.Rpc.BlockList.Move.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.BlockList.Move.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.BlockList.Move.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.BlockList.Move.Response.Error.Code} code
                         * @memberof anytype.Rpc.BlockList.Move.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.BlockList.Move.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.BlockList.Move.Response.Error
                         * @static
                         * @param {anytype.Rpc.BlockList.Move.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.BlockList.Move.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.BlockList.Move.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.BlockList.Move.Response.Error
                         * @static
                         * @param {anytype.Rpc.BlockList.Move.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.BlockList.Move.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.BlockList.Move.Response.Error
                         * @static
                         * @param {anytype.Rpc.BlockList.Move.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.BlockList.Move.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.BlockList.Move.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.BlockList.Move.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.BlockList.Move.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.BlockList.Move.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.BlockList.Move.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.BlockList.Move.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.BlockList.Move.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.BlockList.Move.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.BlockList.Move.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.BlockList.Move.Response.Error
                         * @static
                         * @param {anytype.Rpc.BlockList.Move.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.BlockList.Move.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.BlockList.Move.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.BlockList.Move.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Move;
            })();

            BlockList.Set = (function() {

                /**
                 * Properties of a Set.
                 * @memberof anytype.Rpc.BlockList
                 * @interface ISet
                 */

                /**
                 * Constructs a new Set.
                 * @memberof anytype.Rpc.BlockList
                 * @classdesc Represents a Set.
                 * @implements ISet
                 * @constructor
                 * @param {anytype.Rpc.BlockList.ISet=} [properties] Properties to set
                 */
                function Set(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Set instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.BlockList.Set
                 * @static
                 * @param {anytype.Rpc.BlockList.ISet=} [properties] Properties to set
                 * @returns {anytype.Rpc.BlockList.Set} Set instance
                 */
                Set.create = function create(properties) {
                    return new Set(properties);
                };

                /**
                 * Encodes the specified Set message. Does not implicitly {@link anytype.Rpc.BlockList.Set.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.BlockList.Set
                 * @static
                 * @param {anytype.Rpc.BlockList.ISet} message Set message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Set.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Set message, length delimited. Does not implicitly {@link anytype.Rpc.BlockList.Set.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.BlockList.Set
                 * @static
                 * @param {anytype.Rpc.BlockList.ISet} message Set message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Set.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Set message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.BlockList.Set
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.BlockList.Set} Set
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Set.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.BlockList.Set();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Set message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.BlockList.Set
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.BlockList.Set} Set
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Set.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Set message.
                 * @function verify
                 * @memberof anytype.Rpc.BlockList.Set
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Set.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Set message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.BlockList.Set
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.BlockList.Set} Set
                 */
                Set.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.BlockList.Set)
                        return object;
                    return new $root.anytype.Rpc.BlockList.Set();
                };

                /**
                 * Creates a plain object from a Set message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.BlockList.Set
                 * @static
                 * @param {anytype.Rpc.BlockList.Set} message Set
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Set.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Set to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.BlockList.Set
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Set.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Set.Text = (function() {

                    /**
                     * Properties of a Text.
                     * @memberof anytype.Rpc.BlockList.Set
                     * @interface IText
                     */

                    /**
                     * Constructs a new Text.
                     * @memberof anytype.Rpc.BlockList.Set
                     * @classdesc Represents a Text.
                     * @implements IText
                     * @constructor
                     * @param {anytype.Rpc.BlockList.Set.IText=} [properties] Properties to set
                     */
                    function Text(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Text instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.BlockList.Set.Text
                     * @static
                     * @param {anytype.Rpc.BlockList.Set.IText=} [properties] Properties to set
                     * @returns {anytype.Rpc.BlockList.Set.Text} Text instance
                     */
                    Text.create = function create(properties) {
                        return new Text(properties);
                    };

                    /**
                     * Encodes the specified Text message. Does not implicitly {@link anytype.Rpc.BlockList.Set.Text.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.BlockList.Set.Text
                     * @static
                     * @param {anytype.Rpc.BlockList.Set.IText} message Text message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Text.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Text message, length delimited. Does not implicitly {@link anytype.Rpc.BlockList.Set.Text.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.BlockList.Set.Text
                     * @static
                     * @param {anytype.Rpc.BlockList.Set.IText} message Text message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Text.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Text message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.BlockList.Set.Text
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.BlockList.Set.Text} Text
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Text.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.BlockList.Set.Text();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Text message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.BlockList.Set.Text
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.BlockList.Set.Text} Text
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Text.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Text message.
                     * @function verify
                     * @memberof anytype.Rpc.BlockList.Set.Text
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Text.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Text message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.BlockList.Set.Text
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.BlockList.Set.Text} Text
                     */
                    Text.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.BlockList.Set.Text)
                            return object;
                        return new $root.anytype.Rpc.BlockList.Set.Text();
                    };

                    /**
                     * Creates a plain object from a Text message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.BlockList.Set.Text
                     * @static
                     * @param {anytype.Rpc.BlockList.Set.Text} message Text
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Text.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Text to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.BlockList.Set.Text
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Text.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Text.Style = (function() {

                        /**
                         * Properties of a Style.
                         * @memberof anytype.Rpc.BlockList.Set.Text
                         * @interface IStyle
                         */

                        /**
                         * Constructs a new Style.
                         * @memberof anytype.Rpc.BlockList.Set.Text
                         * @classdesc Represents a Style.
                         * @implements IStyle
                         * @constructor
                         * @param {anytype.Rpc.BlockList.Set.Text.IStyle=} [properties] Properties to set
                         */
                        function Style(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Style instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.BlockList.Set.Text.Style
                         * @static
                         * @param {anytype.Rpc.BlockList.Set.Text.IStyle=} [properties] Properties to set
                         * @returns {anytype.Rpc.BlockList.Set.Text.Style} Style instance
                         */
                        Style.create = function create(properties) {
                            return new Style(properties);
                        };

                        /**
                         * Encodes the specified Style message. Does not implicitly {@link anytype.Rpc.BlockList.Set.Text.Style.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.BlockList.Set.Text.Style
                         * @static
                         * @param {anytype.Rpc.BlockList.Set.Text.IStyle} message Style message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Style.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Style message, length delimited. Does not implicitly {@link anytype.Rpc.BlockList.Set.Text.Style.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.BlockList.Set.Text.Style
                         * @static
                         * @param {anytype.Rpc.BlockList.Set.Text.IStyle} message Style message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Style.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Style message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.BlockList.Set.Text.Style
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.BlockList.Set.Text.Style} Style
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Style.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.BlockList.Set.Text.Style();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Style message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.BlockList.Set.Text.Style
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.BlockList.Set.Text.Style} Style
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Style.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Style message.
                         * @function verify
                         * @memberof anytype.Rpc.BlockList.Set.Text.Style
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Style.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Style message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.BlockList.Set.Text.Style
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.BlockList.Set.Text.Style} Style
                         */
                        Style.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.BlockList.Set.Text.Style)
                                return object;
                            return new $root.anytype.Rpc.BlockList.Set.Text.Style();
                        };

                        /**
                         * Creates a plain object from a Style message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.BlockList.Set.Text.Style
                         * @static
                         * @param {anytype.Rpc.BlockList.Set.Text.Style} message Style
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Style.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Style to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.BlockList.Set.Text.Style
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Style.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Style.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style
                             * @interface IRequest
                             * @property {string|null} [contextId] Request contextId
                             * @property {Array.<string>|null} [blockIds] Request blockIds
                             * @property {anytype.model.Block.Content.Text.Style|null} [style] Request style
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.BlockList.Set.Text.Style.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                this.blockIds = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request contextId.
                             * @member {string} contextId
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Request
                             * @instance
                             */
                            Request.prototype.contextId = "";

                            /**
                             * Request blockIds.
                             * @member {Array.<string>} blockIds
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Request
                             * @instance
                             */
                            Request.prototype.blockIds = $util.emptyArray;

                            /**
                             * Request style.
                             * @member {anytype.model.Block.Content.Text.Style} style
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Request
                             * @instance
                             */
                            Request.prototype.style = 0;

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Request
                             * @static
                             * @param {anytype.Rpc.BlockList.Set.Text.Style.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.BlockList.Set.Text.Style.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.BlockList.Set.Text.Style.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Request
                             * @static
                             * @param {anytype.Rpc.BlockList.Set.Text.Style.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                                if (message.blockIds != null && message.blockIds.length)
                                    for (var i = 0; i < message.blockIds.length; ++i)
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockIds[i]);
                                if (message.style != null && message.hasOwnProperty("style"))
                                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.style);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.BlockList.Set.Text.Style.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Request
                             * @static
                             * @param {anytype.Rpc.BlockList.Set.Text.Style.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.BlockList.Set.Text.Style.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.BlockList.Set.Text.Style.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.contextId = reader.string();
                                        break;
                                    case 2:
                                        if (!(message.blockIds && message.blockIds.length))
                                            message.blockIds = [];
                                        message.blockIds.push(reader.string());
                                        break;
                                    case 3:
                                        message.style = reader.int32();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.BlockList.Set.Text.Style.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    if (!$util.isString(message.contextId))
                                        return "contextId: string expected";
                                if (message.blockIds != null && message.hasOwnProperty("blockIds")) {
                                    if (!Array.isArray(message.blockIds))
                                        return "blockIds: array expected";
                                    for (var i = 0; i < message.blockIds.length; ++i)
                                        if (!$util.isString(message.blockIds[i]))
                                            return "blockIds: string[] expected";
                                }
                                if (message.style != null && message.hasOwnProperty("style"))
                                    switch (message.style) {
                                    default:
                                        return "style: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                    case 4:
                                    case 5:
                                    case 6:
                                    case 7:
                                    case 8:
                                    case 9:
                                    case 10:
                                    case 11:
                                        break;
                                    }
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.BlockList.Set.Text.Style.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.BlockList.Set.Text.Style.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.BlockList.Set.Text.Style.Request();
                                if (object.contextId != null)
                                    message.contextId = String(object.contextId);
                                if (object.blockIds) {
                                    if (!Array.isArray(object.blockIds))
                                        throw TypeError(".anytype.Rpc.BlockList.Set.Text.Style.Request.blockIds: array expected");
                                    message.blockIds = [];
                                    for (var i = 0; i < object.blockIds.length; ++i)
                                        message.blockIds[i] = String(object.blockIds[i]);
                                }
                                switch (object.style) {
                                case "Paragraph":
                                case 0:
                                    message.style = 0;
                                    break;
                                case "Header1":
                                case 1:
                                    message.style = 1;
                                    break;
                                case "Header2":
                                case 2:
                                    message.style = 2;
                                    break;
                                case "Header3":
                                case 3:
                                    message.style = 3;
                                    break;
                                case "Header4":
                                case 4:
                                    message.style = 4;
                                    break;
                                case "Quote":
                                case 5:
                                    message.style = 5;
                                    break;
                                case "Code":
                                case 6:
                                    message.style = 6;
                                    break;
                                case "Title":
                                case 7:
                                    message.style = 7;
                                    break;
                                case "Checkbox":
                                case 8:
                                    message.style = 8;
                                    break;
                                case "Marked":
                                case 9:
                                    message.style = 9;
                                    break;
                                case "Numbered":
                                case 10:
                                    message.style = 10;
                                    break;
                                case "Toggle":
                                case 11:
                                    message.style = 11;
                                    break;
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Request
                             * @static
                             * @param {anytype.Rpc.BlockList.Set.Text.Style.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.arrays || options.defaults)
                                    object.blockIds = [];
                                if (options.defaults) {
                                    object.contextId = "";
                                    object.style = options.enums === String ? "Paragraph" : 0;
                                }
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    object.contextId = message.contextId;
                                if (message.blockIds && message.blockIds.length) {
                                    object.blockIds = [];
                                    for (var j = 0; j < message.blockIds.length; ++j)
                                        object.blockIds[j] = message.blockIds[j];
                                }
                                if (message.style != null && message.hasOwnProperty("style"))
                                    object.style = options.enums === String ? $root.anytype.model.Block.Content.Text.Style[message.style] : message.style;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        Style.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style
                             * @interface IResponse
                             * @property {anytype.Rpc.BlockList.Set.Text.Style.Response.IError|null} [error] Response error
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.BlockList.Set.Text.Style.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.BlockList.Set.Text.Style.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response
                             * @static
                             * @param {anytype.Rpc.BlockList.Set.Text.Style.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.BlockList.Set.Text.Style.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.BlockList.Set.Text.Style.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response
                             * @static
                             * @param {anytype.Rpc.BlockList.Set.Text.Style.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.BlockList.Set.Text.Style.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.BlockList.Set.Text.Style.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response
                             * @static
                             * @param {anytype.Rpc.BlockList.Set.Text.Style.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.BlockList.Set.Text.Style.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.BlockList.Set.Text.Style.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.BlockList.Set.Text.Style.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.BlockList.Set.Text.Style.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.BlockList.Set.Text.Style.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.BlockList.Set.Text.Style.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.BlockList.Set.Text.Style.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.BlockList.Set.Text.Style.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.BlockList.Set.Text.Style.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.BlockList.Set.Text.Style.Response.Error.fromObject(object.error);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response
                             * @static
                             * @param {anytype.Rpc.BlockList.Set.Text.Style.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.error = null;
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.BlockList.Set.Text.Style.Response.Error.toObject(message.error, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.BlockList.Set.Text.Style.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.BlockList.Set.Text.Style.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.BlockList.Set.Text.Style.Response.Error.Code} code
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.BlockList.Set.Text.Style.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.BlockList.Set.Text.Style.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.BlockList.Set.Text.Style.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.BlockList.Set.Text.Style.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.BlockList.Set.Text.Style.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.BlockList.Set.Text.Style.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.BlockList.Set.Text.Style.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.BlockList.Set.Text.Style.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.BlockList.Set.Text.Style.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.BlockList.Set.Text.Style.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.BlockList.Set.Text.Style.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.BlockList.Set.Text.Style.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.BlockList.Set.Text.Style.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.BlockList.Set.Text.Style.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.BlockList.Set.Text.Style.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.BlockList.Set.Text.Style.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return Style;
                    })();

                    return Text;
                })();

                return Set;
            })();

            return BlockList;
        })();

        Rpc.Block = (function() {

            /**
             * Properties of a Block.
             * @memberof anytype.Rpc
             * @interface IBlock
             */

            /**
             * Constructs a new Block.
             * @memberof anytype.Rpc
             * @classdesc Represents a Block.
             * @implements IBlock
             * @constructor
             * @param {anytype.Rpc.IBlock=} [properties] Properties to set
             */
            function Block(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Block instance using the specified properties.
             * @function create
             * @memberof anytype.Rpc.Block
             * @static
             * @param {anytype.Rpc.IBlock=} [properties] Properties to set
             * @returns {anytype.Rpc.Block} Block instance
             */
            Block.create = function create(properties) {
                return new Block(properties);
            };

            /**
             * Encodes the specified Block message. Does not implicitly {@link anytype.Rpc.Block.verify|verify} messages.
             * @function encode
             * @memberof anytype.Rpc.Block
             * @static
             * @param {anytype.Rpc.IBlock} message Block message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Block.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Block message, length delimited. Does not implicitly {@link anytype.Rpc.Block.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Rpc.Block
             * @static
             * @param {anytype.Rpc.IBlock} message Block message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Block.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Block message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Rpc.Block
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Rpc.Block} Block
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Block.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Block message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Rpc.Block
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Rpc.Block} Block
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Block.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Block message.
             * @function verify
             * @memberof anytype.Rpc.Block
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Block.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Block message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Rpc.Block
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Rpc.Block} Block
             */
            Block.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Rpc.Block)
                    return object;
                return new $root.anytype.Rpc.Block();
            };

            /**
             * Creates a plain object from a Block message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Rpc.Block
             * @static
             * @param {anytype.Rpc.Block} message Block
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Block.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Block to JSON.
             * @function toJSON
             * @memberof anytype.Rpc.Block
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Block.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Block.Replace = (function() {

                /**
                 * Properties of a Replace.
                 * @memberof anytype.Rpc.Block
                 * @interface IReplace
                 */

                /**
                 * Constructs a new Replace.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents a Replace.
                 * @implements IReplace
                 * @constructor
                 * @param {anytype.Rpc.Block.IReplace=} [properties] Properties to set
                 */
                function Replace(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Replace instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Replace
                 * @static
                 * @param {anytype.Rpc.Block.IReplace=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Replace} Replace instance
                 */
                Replace.create = function create(properties) {
                    return new Replace(properties);
                };

                /**
                 * Encodes the specified Replace message. Does not implicitly {@link anytype.Rpc.Block.Replace.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Replace
                 * @static
                 * @param {anytype.Rpc.Block.IReplace} message Replace message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Replace.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Replace message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Replace.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Replace
                 * @static
                 * @param {anytype.Rpc.Block.IReplace} message Replace message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Replace.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Replace message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Replace
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Replace} Replace
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Replace.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Replace();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Replace message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Replace
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Replace} Replace
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Replace.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Replace message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Replace
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Replace.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Replace message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Replace
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Replace} Replace
                 */
                Replace.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Replace)
                        return object;
                    return new $root.anytype.Rpc.Block.Replace();
                };

                /**
                 * Creates a plain object from a Replace message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Replace
                 * @static
                 * @param {anytype.Rpc.Block.Replace} message Replace
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Replace.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Replace to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Replace
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Replace.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Replace.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Block.Replace
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {string|null} [blockId] Request blockId
                     * @property {anytype.model.IBlock|null} [block] Request block
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Block.Replace
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Block.Replace.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.Block.Replace.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request blockId.
                     * @member {string} blockId
                     * @memberof anytype.Rpc.Block.Replace.Request
                     * @instance
                     */
                    Request.prototype.blockId = "";

                    /**
                     * Request block.
                     * @member {anytype.model.IBlock|null|undefined} block
                     * @memberof anytype.Rpc.Block.Replace.Request
                     * @instance
                     */
                    Request.prototype.block = null;

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Replace.Request
                     * @static
                     * @param {anytype.Rpc.Block.Replace.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Replace.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Replace.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Replace.Request
                     * @static
                     * @param {anytype.Rpc.Block.Replace.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                        if (message.block != null && message.hasOwnProperty("block"))
                            $root.anytype.model.Block.encode(message.block, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Replace.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Replace.Request
                     * @static
                     * @param {anytype.Rpc.Block.Replace.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Replace.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Replace.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Replace.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                message.blockId = reader.string();
                                break;
                            case 3:
                                message.block = $root.anytype.model.Block.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Replace.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Replace.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Replace.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            if (!$util.isString(message.blockId))
                                return "blockId: string expected";
                        if (message.block != null && message.hasOwnProperty("block")) {
                            var error = $root.anytype.model.Block.verify(message.block);
                            if (error)
                                return "block." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Replace.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Replace.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Replace.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Replace.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.blockId != null)
                            message.blockId = String(object.blockId);
                        if (object.block != null) {
                            if (typeof object.block !== "object")
                                throw TypeError(".anytype.Rpc.Block.Replace.Request.block: object expected");
                            message.block = $root.anytype.model.Block.fromObject(object.block);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Replace.Request
                     * @static
                     * @param {anytype.Rpc.Block.Replace.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contextId = "";
                            object.blockId = "";
                            object.block = null;
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            object.blockId = message.blockId;
                        if (message.block != null && message.hasOwnProperty("block"))
                            object.block = $root.anytype.model.Block.toObject(message.block, options);
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Replace.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Replace.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Block.Replace
                     * @interface IResponse
                     * @property {anytype.Rpc.Block.Replace.Response.IError|null} [error] Response error
                     * @property {string|null} [blockId] Response blockId
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Block.Replace
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Block.Replace.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Block.Replace.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Block.Replace.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Response blockId.
                     * @member {string} blockId
                     * @memberof anytype.Rpc.Block.Replace.Response
                     * @instance
                     */
                    Response.prototype.blockId = "";

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Replace.Response
                     * @static
                     * @param {anytype.Rpc.Block.Replace.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Replace.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Replace.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Replace.Response
                     * @static
                     * @param {anytype.Rpc.Block.Replace.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Block.Replace.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Replace.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Replace.Response
                     * @static
                     * @param {anytype.Rpc.Block.Replace.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Replace.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Replace.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Replace.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Block.Replace.Response.Error.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.blockId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Replace.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Replace.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Replace.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Block.Replace.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            if (!$util.isString(message.blockId))
                                return "blockId: string expected";
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Replace.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Replace.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Replace.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Replace.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Block.Replace.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Block.Replace.Response.Error.fromObject(object.error);
                        }
                        if (object.blockId != null)
                            message.blockId = String(object.blockId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Replace.Response
                     * @static
                     * @param {anytype.Rpc.Block.Replace.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.error = null;
                            object.blockId = "";
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Block.Replace.Response.Error.toObject(message.error, options);
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            object.blockId = message.blockId;
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Replace.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Block.Replace.Response
                         * @interface IError
                         * @property {anytype.Rpc.Block.Replace.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Block.Replace.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Block.Replace.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Block.Replace.Response.Error.Code} code
                         * @memberof anytype.Rpc.Block.Replace.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Block.Replace.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Replace.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Replace.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Replace.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Replace.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Replace.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Replace.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Replace.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Replace.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Replace.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Replace.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Replace.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Replace.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Replace.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Replace.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Replace.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Replace.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Replace.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Replace.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Replace.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Replace.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Replace.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Block.Replace.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Replace.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Block.Replace.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Replace;
            })();

            Block.Split = (function() {

                /**
                 * Properties of a Split.
                 * @memberof anytype.Rpc.Block
                 * @interface ISplit
                 */

                /**
                 * Constructs a new Split.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents a Split.
                 * @implements ISplit
                 * @constructor
                 * @param {anytype.Rpc.Block.ISplit=} [properties] Properties to set
                 */
                function Split(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Split instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Split
                 * @static
                 * @param {anytype.Rpc.Block.ISplit=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Split} Split instance
                 */
                Split.create = function create(properties) {
                    return new Split(properties);
                };

                /**
                 * Encodes the specified Split message. Does not implicitly {@link anytype.Rpc.Block.Split.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Split
                 * @static
                 * @param {anytype.Rpc.Block.ISplit} message Split message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Split.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Split message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Split.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Split
                 * @static
                 * @param {anytype.Rpc.Block.ISplit} message Split message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Split.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Split message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Split
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Split} Split
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Split.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Split();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Split message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Split
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Split} Split
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Split.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Split message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Split
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Split.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Split message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Split
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Split} Split
                 */
                Split.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Split)
                        return object;
                    return new $root.anytype.Rpc.Block.Split();
                };

                /**
                 * Creates a plain object from a Split message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Split
                 * @static
                 * @param {anytype.Rpc.Block.Split} message Split
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Split.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Split to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Split
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Split.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Split.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Block.Split
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {string|null} [blockId] Request blockId
                     * @property {number|null} [cursorPosition] Request cursorPosition
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Block.Split
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Block.Split.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.Block.Split.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request blockId.
                     * @member {string} blockId
                     * @memberof anytype.Rpc.Block.Split.Request
                     * @instance
                     */
                    Request.prototype.blockId = "";

                    /**
                     * Request cursorPosition.
                     * @member {number} cursorPosition
                     * @memberof anytype.Rpc.Block.Split.Request
                     * @instance
                     */
                    Request.prototype.cursorPosition = 0;

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Split.Request
                     * @static
                     * @param {anytype.Rpc.Block.Split.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Split.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Split.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Split.Request
                     * @static
                     * @param {anytype.Rpc.Block.Split.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                        if (message.cursorPosition != null && message.hasOwnProperty("cursorPosition"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cursorPosition);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Split.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Split.Request
                     * @static
                     * @param {anytype.Rpc.Block.Split.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Split.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Split.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Split.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                message.blockId = reader.string();
                                break;
                            case 3:
                                message.cursorPosition = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Split.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Split.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Split.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            if (!$util.isString(message.blockId))
                                return "blockId: string expected";
                        if (message.cursorPosition != null && message.hasOwnProperty("cursorPosition"))
                            if (!$util.isInteger(message.cursorPosition))
                                return "cursorPosition: integer expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Split.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Split.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Split.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Split.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.blockId != null)
                            message.blockId = String(object.blockId);
                        if (object.cursorPosition != null)
                            message.cursorPosition = object.cursorPosition | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Split.Request
                     * @static
                     * @param {anytype.Rpc.Block.Split.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contextId = "";
                            object.blockId = "";
                            object.cursorPosition = 0;
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            object.blockId = message.blockId;
                        if (message.cursorPosition != null && message.hasOwnProperty("cursorPosition"))
                            object.cursorPosition = message.cursorPosition;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Split.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Split.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Block.Split
                     * @interface IResponse
                     * @property {anytype.Rpc.Block.Split.Response.IError|null} [error] Response error
                     * @property {string|null} [blockId] Response blockId
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Block.Split
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Block.Split.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Block.Split.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Block.Split.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Response blockId.
                     * @member {string} blockId
                     * @memberof anytype.Rpc.Block.Split.Response
                     * @instance
                     */
                    Response.prototype.blockId = "";

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Split.Response
                     * @static
                     * @param {anytype.Rpc.Block.Split.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Split.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Split.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Split.Response
                     * @static
                     * @param {anytype.Rpc.Block.Split.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Block.Split.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Split.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Split.Response
                     * @static
                     * @param {anytype.Rpc.Block.Split.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Split.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Split.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Split.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Block.Split.Response.Error.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.blockId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Split.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Split.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Split.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Block.Split.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            if (!$util.isString(message.blockId))
                                return "blockId: string expected";
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Split.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Split.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Split.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Split.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Block.Split.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Block.Split.Response.Error.fromObject(object.error);
                        }
                        if (object.blockId != null)
                            message.blockId = String(object.blockId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Split.Response
                     * @static
                     * @param {anytype.Rpc.Block.Split.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.error = null;
                            object.blockId = "";
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Block.Split.Response.Error.toObject(message.error, options);
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            object.blockId = message.blockId;
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Split.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Block.Split.Response
                         * @interface IError
                         * @property {anytype.Rpc.Block.Split.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Block.Split.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Block.Split.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Block.Split.Response.Error.Code} code
                         * @memberof anytype.Rpc.Block.Split.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Block.Split.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Split.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Split.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Split.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Split.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Split.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Split.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Split.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Split.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Split.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Split.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Split.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Split.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Split.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Split.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Split.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Split.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Split.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Split.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Split.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Split.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Split.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Block.Split.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Split.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Block.Split.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Split;
            })();

            Block.Merge = (function() {

                /**
                 * Properties of a Merge.
                 * @memberof anytype.Rpc.Block
                 * @interface IMerge
                 */

                /**
                 * Constructs a new Merge.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents a Merge.
                 * @implements IMerge
                 * @constructor
                 * @param {anytype.Rpc.Block.IMerge=} [properties] Properties to set
                 */
                function Merge(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Merge instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Merge
                 * @static
                 * @param {anytype.Rpc.Block.IMerge=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Merge} Merge instance
                 */
                Merge.create = function create(properties) {
                    return new Merge(properties);
                };

                /**
                 * Encodes the specified Merge message. Does not implicitly {@link anytype.Rpc.Block.Merge.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Merge
                 * @static
                 * @param {anytype.Rpc.Block.IMerge} message Merge message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Merge.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Merge message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Merge.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Merge
                 * @static
                 * @param {anytype.Rpc.Block.IMerge} message Merge message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Merge.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Merge message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Merge
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Merge} Merge
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Merge.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Merge();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Merge message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Merge
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Merge} Merge
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Merge.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Merge message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Merge
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Merge.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Merge message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Merge
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Merge} Merge
                 */
                Merge.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Merge)
                        return object;
                    return new $root.anytype.Rpc.Block.Merge();
                };

                /**
                 * Creates a plain object from a Merge message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Merge
                 * @static
                 * @param {anytype.Rpc.Block.Merge} message Merge
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Merge.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Merge to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Merge
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Merge.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Merge.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Block.Merge
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {string|null} [firstBlockId] Request firstBlockId
                     * @property {string|null} [secondBlockId] Request secondBlockId
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Block.Merge
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Block.Merge.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.Block.Merge.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request firstBlockId.
                     * @member {string} firstBlockId
                     * @memberof anytype.Rpc.Block.Merge.Request
                     * @instance
                     */
                    Request.prototype.firstBlockId = "";

                    /**
                     * Request secondBlockId.
                     * @member {string} secondBlockId
                     * @memberof anytype.Rpc.Block.Merge.Request
                     * @instance
                     */
                    Request.prototype.secondBlockId = "";

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Merge.Request
                     * @static
                     * @param {anytype.Rpc.Block.Merge.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Merge.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Merge.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Merge.Request
                     * @static
                     * @param {anytype.Rpc.Block.Merge.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.firstBlockId != null && message.hasOwnProperty("firstBlockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.firstBlockId);
                        if (message.secondBlockId != null && message.hasOwnProperty("secondBlockId"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.secondBlockId);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Merge.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Merge.Request
                     * @static
                     * @param {anytype.Rpc.Block.Merge.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Merge.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Merge.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Merge.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                message.firstBlockId = reader.string();
                                break;
                            case 3:
                                message.secondBlockId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Merge.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Merge.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Merge.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.firstBlockId != null && message.hasOwnProperty("firstBlockId"))
                            if (!$util.isString(message.firstBlockId))
                                return "firstBlockId: string expected";
                        if (message.secondBlockId != null && message.hasOwnProperty("secondBlockId"))
                            if (!$util.isString(message.secondBlockId))
                                return "secondBlockId: string expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Merge.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Merge.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Merge.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Merge.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.firstBlockId != null)
                            message.firstBlockId = String(object.firstBlockId);
                        if (object.secondBlockId != null)
                            message.secondBlockId = String(object.secondBlockId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Merge.Request
                     * @static
                     * @param {anytype.Rpc.Block.Merge.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contextId = "";
                            object.firstBlockId = "";
                            object.secondBlockId = "";
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.firstBlockId != null && message.hasOwnProperty("firstBlockId"))
                            object.firstBlockId = message.firstBlockId;
                        if (message.secondBlockId != null && message.hasOwnProperty("secondBlockId"))
                            object.secondBlockId = message.secondBlockId;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Merge.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Merge.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Block.Merge
                     * @interface IResponse
                     * @property {anytype.Rpc.Block.Merge.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Block.Merge
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Block.Merge.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Block.Merge.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Block.Merge.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Merge.Response
                     * @static
                     * @param {anytype.Rpc.Block.Merge.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Merge.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Merge.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Merge.Response
                     * @static
                     * @param {anytype.Rpc.Block.Merge.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Block.Merge.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Merge.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Merge.Response
                     * @static
                     * @param {anytype.Rpc.Block.Merge.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Merge.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Merge.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Merge.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Block.Merge.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Merge.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Merge.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Merge.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Block.Merge.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Merge.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Merge.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Merge.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Merge.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Block.Merge.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Block.Merge.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Merge.Response
                     * @static
                     * @param {anytype.Rpc.Block.Merge.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Block.Merge.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Merge.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Block.Merge.Response
                         * @interface IError
                         * @property {anytype.Rpc.Block.Merge.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Block.Merge.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Block.Merge.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Block.Merge.Response.Error.Code} code
                         * @memberof anytype.Rpc.Block.Merge.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Block.Merge.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Merge.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Merge.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Merge.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Merge.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Merge.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Merge.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Merge.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Merge.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Merge.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Merge.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Merge.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Merge.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Merge.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Merge.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Merge.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Merge.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Merge.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Merge.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Merge.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Merge.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Merge.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Block.Merge.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Merge.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Block.Merge.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Merge;
            })();

            Block.Duplicate = (function() {

                /**
                 * Properties of a Duplicate.
                 * @memberof anytype.Rpc.Block
                 * @interface IDuplicate
                 */

                /**
                 * Constructs a new Duplicate.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents a Duplicate.
                 * @implements IDuplicate
                 * @constructor
                 * @param {anytype.Rpc.Block.IDuplicate=} [properties] Properties to set
                 */
                function Duplicate(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Duplicate instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Duplicate
                 * @static
                 * @param {anytype.Rpc.Block.IDuplicate=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Duplicate} Duplicate instance
                 */
                Duplicate.create = function create(properties) {
                    return new Duplicate(properties);
                };

                /**
                 * Encodes the specified Duplicate message. Does not implicitly {@link anytype.Rpc.Block.Duplicate.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Duplicate
                 * @static
                 * @param {anytype.Rpc.Block.IDuplicate} message Duplicate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Duplicate.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Duplicate message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Duplicate.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Duplicate
                 * @static
                 * @param {anytype.Rpc.Block.IDuplicate} message Duplicate message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Duplicate.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Duplicate message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Duplicate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Duplicate} Duplicate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Duplicate.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Duplicate();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Duplicate message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Duplicate
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Duplicate} Duplicate
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Duplicate.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Duplicate message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Duplicate
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Duplicate.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Duplicate message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Duplicate
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Duplicate} Duplicate
                 */
                Duplicate.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Duplicate)
                        return object;
                    return new $root.anytype.Rpc.Block.Duplicate();
                };

                /**
                 * Creates a plain object from a Duplicate message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Duplicate
                 * @static
                 * @param {anytype.Rpc.Block.Duplicate} message Duplicate
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Duplicate.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Duplicate to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Duplicate
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Duplicate.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Duplicate.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Block.Duplicate
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {string|null} [targetId] Request targetId
                     * @property {string|null} [blockId] Request blockId
                     * @property {anytype.model.Block.Position|null} [position] Request position
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Block.Duplicate
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Block.Duplicate.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request targetId.
                     * @member {string} targetId
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @instance
                     */
                    Request.prototype.targetId = "";

                    /**
                     * Request blockId.
                     * @member {string} blockId
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @instance
                     */
                    Request.prototype.blockId = "";

                    /**
                     * Request position.
                     * @member {anytype.model.Block.Position} position
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @instance
                     */
                    Request.prototype.position = 0;

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @static
                     * @param {anytype.Rpc.Block.Duplicate.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Duplicate.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Duplicate.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @static
                     * @param {anytype.Rpc.Block.Duplicate.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.targetId != null && message.hasOwnProperty("targetId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetId);
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.blockId);
                        if (message.position != null && message.hasOwnProperty("position"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.position);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Duplicate.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @static
                     * @param {anytype.Rpc.Block.Duplicate.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Duplicate.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Duplicate.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                message.targetId = reader.string();
                                break;
                            case 3:
                                message.blockId = reader.string();
                                break;
                            case 4:
                                message.position = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Duplicate.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.targetId != null && message.hasOwnProperty("targetId"))
                            if (!$util.isString(message.targetId))
                                return "targetId: string expected";
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            if (!$util.isString(message.blockId))
                                return "blockId: string expected";
                        if (message.position != null && message.hasOwnProperty("position"))
                            switch (message.position) {
                            default:
                                return "position: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Duplicate.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Duplicate.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Duplicate.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.targetId != null)
                            message.targetId = String(object.targetId);
                        if (object.blockId != null)
                            message.blockId = String(object.blockId);
                        switch (object.position) {
                        case "None":
                        case 0:
                            message.position = 0;
                            break;
                        case "Top":
                        case 1:
                            message.position = 1;
                            break;
                        case "Bottom":
                        case 2:
                            message.position = 2;
                            break;
                        case "Left":
                        case 3:
                            message.position = 3;
                            break;
                        case "Right":
                        case 4:
                            message.position = 4;
                            break;
                        case "Inner":
                        case 5:
                            message.position = 5;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @static
                     * @param {anytype.Rpc.Block.Duplicate.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contextId = "";
                            object.targetId = "";
                            object.blockId = "";
                            object.position = options.enums === String ? "None" : 0;
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.targetId != null && message.hasOwnProperty("targetId"))
                            object.targetId = message.targetId;
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            object.blockId = message.blockId;
                        if (message.position != null && message.hasOwnProperty("position"))
                            object.position = options.enums === String ? $root.anytype.model.Block.Position[message.position] : message.position;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Duplicate.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Duplicate.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Block.Duplicate
                     * @interface IResponse
                     * @property {anytype.Rpc.Block.Duplicate.Response.IError|null} [error] Response error
                     * @property {string|null} [blockId] Response blockId
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Block.Duplicate
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Block.Duplicate.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Block.Duplicate.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Block.Duplicate.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Response blockId.
                     * @member {string} blockId
                     * @memberof anytype.Rpc.Block.Duplicate.Response
                     * @instance
                     */
                    Response.prototype.blockId = "";

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Duplicate.Response
                     * @static
                     * @param {anytype.Rpc.Block.Duplicate.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Duplicate.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Duplicate.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Duplicate.Response
                     * @static
                     * @param {anytype.Rpc.Block.Duplicate.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Block.Duplicate.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Duplicate.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Duplicate.Response
                     * @static
                     * @param {anytype.Rpc.Block.Duplicate.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Duplicate.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Duplicate.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Duplicate.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Block.Duplicate.Response.Error.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.blockId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Duplicate.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Duplicate.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Duplicate.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Block.Duplicate.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            if (!$util.isString(message.blockId))
                                return "blockId: string expected";
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Duplicate.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Duplicate.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Duplicate.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Duplicate.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Block.Duplicate.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Block.Duplicate.Response.Error.fromObject(object.error);
                        }
                        if (object.blockId != null)
                            message.blockId = String(object.blockId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Duplicate.Response
                     * @static
                     * @param {anytype.Rpc.Block.Duplicate.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.error = null;
                            object.blockId = "";
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Block.Duplicate.Response.Error.toObject(message.error, options);
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            object.blockId = message.blockId;
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Duplicate.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Block.Duplicate.Response
                         * @interface IError
                         * @property {anytype.Rpc.Block.Duplicate.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Block.Duplicate.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Block.Duplicate.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Block.Duplicate.Response.Error.Code} code
                         * @memberof anytype.Rpc.Block.Duplicate.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Block.Duplicate.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Duplicate.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Duplicate.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Duplicate.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Duplicate.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Duplicate.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Duplicate.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Duplicate.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Duplicate.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Duplicate.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Duplicate.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Duplicate.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Duplicate.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Duplicate.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Duplicate.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Duplicate.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Duplicate.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Duplicate.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Duplicate.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Duplicate.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Duplicate.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Duplicate.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Block.Duplicate.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Duplicate.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Block.Duplicate.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Duplicate;
            })();

            Block.Copy = (function() {

                /**
                 * Properties of a Copy.
                 * @memberof anytype.Rpc.Block
                 * @interface ICopy
                 */

                /**
                 * Constructs a new Copy.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents a Copy.
                 * @implements ICopy
                 * @constructor
                 * @param {anytype.Rpc.Block.ICopy=} [properties] Properties to set
                 */
                function Copy(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Copy instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Copy
                 * @static
                 * @param {anytype.Rpc.Block.ICopy=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Copy} Copy instance
                 */
                Copy.create = function create(properties) {
                    return new Copy(properties);
                };

                /**
                 * Encodes the specified Copy message. Does not implicitly {@link anytype.Rpc.Block.Copy.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Copy
                 * @static
                 * @param {anytype.Rpc.Block.ICopy} message Copy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Copy.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Copy message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Copy.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Copy
                 * @static
                 * @param {anytype.Rpc.Block.ICopy} message Copy message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Copy.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Copy message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Copy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Copy} Copy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Copy.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Copy();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Copy message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Copy
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Copy} Copy
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Copy.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Copy message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Copy
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Copy.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Copy message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Copy
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Copy} Copy
                 */
                Copy.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Copy)
                        return object;
                    return new $root.anytype.Rpc.Block.Copy();
                };

                /**
                 * Creates a plain object from a Copy message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Copy
                 * @static
                 * @param {anytype.Rpc.Block.Copy} message Copy
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Copy.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Copy to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Copy
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Copy.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Copy.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Block.Copy
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {Array.<string>|null} [blockIds] Request blockIds
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Block.Copy
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Block.Copy.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        this.blockIds = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.Block.Copy.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request blockIds.
                     * @member {Array.<string>} blockIds
                     * @memberof anytype.Rpc.Block.Copy.Request
                     * @instance
                     */
                    Request.prototype.blockIds = $util.emptyArray;

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Copy.Request
                     * @static
                     * @param {anytype.Rpc.Block.Copy.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Copy.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Copy.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Copy.Request
                     * @static
                     * @param {anytype.Rpc.Block.Copy.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.blockIds != null && message.blockIds.length)
                            for (var i = 0; i < message.blockIds.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockIds[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Copy.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Copy.Request
                     * @static
                     * @param {anytype.Rpc.Block.Copy.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Copy.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Copy.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Copy.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                if (!(message.blockIds && message.blockIds.length))
                                    message.blockIds = [];
                                message.blockIds.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Copy.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Copy.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Copy.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.blockIds != null && message.hasOwnProperty("blockIds")) {
                            if (!Array.isArray(message.blockIds))
                                return "blockIds: array expected";
                            for (var i = 0; i < message.blockIds.length; ++i)
                                if (!$util.isString(message.blockIds[i]))
                                    return "blockIds: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Copy.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Copy.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Copy.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Copy.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.blockIds) {
                            if (!Array.isArray(object.blockIds))
                                throw TypeError(".anytype.Rpc.Block.Copy.Request.blockIds: array expected");
                            message.blockIds = [];
                            for (var i = 0; i < object.blockIds.length; ++i)
                                message.blockIds[i] = String(object.blockIds[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Copy.Request
                     * @static
                     * @param {anytype.Rpc.Block.Copy.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.blockIds = [];
                        if (options.defaults)
                            object.contextId = "";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.blockIds && message.blockIds.length) {
                            object.blockIds = [];
                            for (var j = 0; j < message.blockIds.length; ++j)
                                object.blockIds[j] = message.blockIds[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Copy.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Copy.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Block.Copy
                     * @interface IResponse
                     * @property {anytype.Rpc.Block.Copy.Response.IError|null} [error] Response error
                     * @property {string|null} [clipboardText] Response clipboardText
                     * @property {string|null} [clipboardHtml] Response clipboardHtml
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Block.Copy
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Block.Copy.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Block.Copy.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Block.Copy.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Response clipboardText.
                     * @member {string} clipboardText
                     * @memberof anytype.Rpc.Block.Copy.Response
                     * @instance
                     */
                    Response.prototype.clipboardText = "";

                    /**
                     * Response clipboardHtml.
                     * @member {string} clipboardHtml
                     * @memberof anytype.Rpc.Block.Copy.Response
                     * @instance
                     */
                    Response.prototype.clipboardHtml = "";

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Copy.Response
                     * @static
                     * @param {anytype.Rpc.Block.Copy.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Copy.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Copy.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Copy.Response
                     * @static
                     * @param {anytype.Rpc.Block.Copy.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Block.Copy.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.clipboardText != null && message.hasOwnProperty("clipboardText"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.clipboardText);
                        if (message.clipboardHtml != null && message.hasOwnProperty("clipboardHtml"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.clipboardHtml);
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Copy.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Copy.Response
                     * @static
                     * @param {anytype.Rpc.Block.Copy.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Copy.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Copy.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Copy.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Block.Copy.Response.Error.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.clipboardText = reader.string();
                                break;
                            case 3:
                                message.clipboardHtml = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Copy.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Copy.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Copy.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Block.Copy.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        if (message.clipboardText != null && message.hasOwnProperty("clipboardText"))
                            if (!$util.isString(message.clipboardText))
                                return "clipboardText: string expected";
                        if (message.clipboardHtml != null && message.hasOwnProperty("clipboardHtml"))
                            if (!$util.isString(message.clipboardHtml))
                                return "clipboardHtml: string expected";
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Copy.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Copy.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Copy.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Copy.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Block.Copy.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Block.Copy.Response.Error.fromObject(object.error);
                        }
                        if (object.clipboardText != null)
                            message.clipboardText = String(object.clipboardText);
                        if (object.clipboardHtml != null)
                            message.clipboardHtml = String(object.clipboardHtml);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Copy.Response
                     * @static
                     * @param {anytype.Rpc.Block.Copy.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.error = null;
                            object.clipboardText = "";
                            object.clipboardHtml = "";
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Block.Copy.Response.Error.toObject(message.error, options);
                        if (message.clipboardText != null && message.hasOwnProperty("clipboardText"))
                            object.clipboardText = message.clipboardText;
                        if (message.clipboardHtml != null && message.hasOwnProperty("clipboardHtml"))
                            object.clipboardHtml = message.clipboardHtml;
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Copy.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Block.Copy.Response
                         * @interface IError
                         * @property {anytype.Rpc.Block.Copy.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Block.Copy.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Block.Copy.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Block.Copy.Response.Error.Code} code
                         * @memberof anytype.Rpc.Block.Copy.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Block.Copy.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Copy.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Copy.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Copy.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Copy.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Copy.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Copy.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Copy.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Copy.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Copy.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Copy.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Copy.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Copy.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Copy.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Copy.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Copy.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Copy.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Copy.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Copy.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Copy.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Copy.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Copy.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Block.Copy.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Copy.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Block.Copy.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Copy;
            })();

            Block.Paste = (function() {

                /**
                 * Properties of a Paste.
                 * @memberof anytype.Rpc.Block
                 * @interface IPaste
                 */

                /**
                 * Constructs a new Paste.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents a Paste.
                 * @implements IPaste
                 * @constructor
                 * @param {anytype.Rpc.Block.IPaste=} [properties] Properties to set
                 */
                function Paste(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Paste instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Paste
                 * @static
                 * @param {anytype.Rpc.Block.IPaste=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Paste} Paste instance
                 */
                Paste.create = function create(properties) {
                    return new Paste(properties);
                };

                /**
                 * Encodes the specified Paste message. Does not implicitly {@link anytype.Rpc.Block.Paste.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Paste
                 * @static
                 * @param {anytype.Rpc.Block.IPaste} message Paste message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Paste.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Paste message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Paste.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Paste
                 * @static
                 * @param {anytype.Rpc.Block.IPaste} message Paste message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Paste.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Paste message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Paste
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Paste} Paste
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Paste.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Paste();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Paste message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Paste
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Paste} Paste
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Paste.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Paste message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Paste
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Paste.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Paste message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Paste
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Paste} Paste
                 */
                Paste.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Paste)
                        return object;
                    return new $root.anytype.Rpc.Block.Paste();
                };

                /**
                 * Creates a plain object from a Paste message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Paste
                 * @static
                 * @param {anytype.Rpc.Block.Paste} message Paste
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Paste.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Paste to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Paste
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Paste.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Paste.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Block.Paste
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {string|null} [focusedBlockId] Request focusedBlockId
                     * @property {anytype.model.IRange|null} [selectedTextRange] Request selectedTextRange
                     * @property {Array.<string>|null} [selectedBlocks] Request selectedBlocks
                     * @property {string|null} [textSlot] Request textSlot
                     * @property {string|null} [htmlSlot] Request htmlSlot
                     * @property {string|null} [anySlot] Request anySlot
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Block.Paste
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Block.Paste.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        this.selectedBlocks = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request focusedBlockId.
                     * @member {string} focusedBlockId
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @instance
                     */
                    Request.prototype.focusedBlockId = "";

                    /**
                     * Request selectedTextRange.
                     * @member {anytype.model.IRange|null|undefined} selectedTextRange
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @instance
                     */
                    Request.prototype.selectedTextRange = null;

                    /**
                     * Request selectedBlocks.
                     * @member {Array.<string>} selectedBlocks
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @instance
                     */
                    Request.prototype.selectedBlocks = $util.emptyArray;

                    /**
                     * Request textSlot.
                     * @member {string} textSlot
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @instance
                     */
                    Request.prototype.textSlot = "";

                    /**
                     * Request htmlSlot.
                     * @member {string} htmlSlot
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @instance
                     */
                    Request.prototype.htmlSlot = "";

                    /**
                     * Request anySlot.
                     * @member {string} anySlot
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @instance
                     */
                    Request.prototype.anySlot = "";

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @static
                     * @param {anytype.Rpc.Block.Paste.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Paste.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Paste.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @static
                     * @param {anytype.Rpc.Block.Paste.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.focusedBlockId != null && message.hasOwnProperty("focusedBlockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.focusedBlockId);
                        if (message.selectedTextRange != null && message.hasOwnProperty("selectedTextRange"))
                            $root.anytype.model.Range.encode(message.selectedTextRange, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.selectedBlocks != null && message.selectedBlocks.length)
                            for (var i = 0; i < message.selectedBlocks.length; ++i)
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.selectedBlocks[i]);
                        if (message.textSlot != null && message.hasOwnProperty("textSlot"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.textSlot);
                        if (message.htmlSlot != null && message.hasOwnProperty("htmlSlot"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.htmlSlot);
                        if (message.anySlot != null && message.hasOwnProperty("anySlot"))
                            writer.uint32(/* id 7, wireType 2 =*/58).string(message.anySlot);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Paste.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @static
                     * @param {anytype.Rpc.Block.Paste.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Paste.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Paste.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                message.focusedBlockId = reader.string();
                                break;
                            case 3:
                                message.selectedTextRange = $root.anytype.model.Range.decode(reader, reader.uint32());
                                break;
                            case 4:
                                if (!(message.selectedBlocks && message.selectedBlocks.length))
                                    message.selectedBlocks = [];
                                message.selectedBlocks.push(reader.string());
                                break;
                            case 5:
                                message.textSlot = reader.string();
                                break;
                            case 6:
                                message.htmlSlot = reader.string();
                                break;
                            case 7:
                                message.anySlot = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Paste.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.focusedBlockId != null && message.hasOwnProperty("focusedBlockId"))
                            if (!$util.isString(message.focusedBlockId))
                                return "focusedBlockId: string expected";
                        if (message.selectedTextRange != null && message.hasOwnProperty("selectedTextRange")) {
                            var error = $root.anytype.model.Range.verify(message.selectedTextRange);
                            if (error)
                                return "selectedTextRange." + error;
                        }
                        if (message.selectedBlocks != null && message.hasOwnProperty("selectedBlocks")) {
                            if (!Array.isArray(message.selectedBlocks))
                                return "selectedBlocks: array expected";
                            for (var i = 0; i < message.selectedBlocks.length; ++i)
                                if (!$util.isString(message.selectedBlocks[i]))
                                    return "selectedBlocks: string[] expected";
                        }
                        if (message.textSlot != null && message.hasOwnProperty("textSlot"))
                            if (!$util.isString(message.textSlot))
                                return "textSlot: string expected";
                        if (message.htmlSlot != null && message.hasOwnProperty("htmlSlot"))
                            if (!$util.isString(message.htmlSlot))
                                return "htmlSlot: string expected";
                        if (message.anySlot != null && message.hasOwnProperty("anySlot"))
                            if (!$util.isString(message.anySlot))
                                return "anySlot: string expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Paste.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Paste.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Paste.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.focusedBlockId != null)
                            message.focusedBlockId = String(object.focusedBlockId);
                        if (object.selectedTextRange != null) {
                            if (typeof object.selectedTextRange !== "object")
                                throw TypeError(".anytype.Rpc.Block.Paste.Request.selectedTextRange: object expected");
                            message.selectedTextRange = $root.anytype.model.Range.fromObject(object.selectedTextRange);
                        }
                        if (object.selectedBlocks) {
                            if (!Array.isArray(object.selectedBlocks))
                                throw TypeError(".anytype.Rpc.Block.Paste.Request.selectedBlocks: array expected");
                            message.selectedBlocks = [];
                            for (var i = 0; i < object.selectedBlocks.length; ++i)
                                message.selectedBlocks[i] = String(object.selectedBlocks[i]);
                        }
                        if (object.textSlot != null)
                            message.textSlot = String(object.textSlot);
                        if (object.htmlSlot != null)
                            message.htmlSlot = String(object.htmlSlot);
                        if (object.anySlot != null)
                            message.anySlot = String(object.anySlot);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @static
                     * @param {anytype.Rpc.Block.Paste.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.selectedBlocks = [];
                        if (options.defaults) {
                            object.contextId = "";
                            object.focusedBlockId = "";
                            object.selectedTextRange = null;
                            object.textSlot = "";
                            object.htmlSlot = "";
                            object.anySlot = "";
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.focusedBlockId != null && message.hasOwnProperty("focusedBlockId"))
                            object.focusedBlockId = message.focusedBlockId;
                        if (message.selectedTextRange != null && message.hasOwnProperty("selectedTextRange"))
                            object.selectedTextRange = $root.anytype.model.Range.toObject(message.selectedTextRange, options);
                        if (message.selectedBlocks && message.selectedBlocks.length) {
                            object.selectedBlocks = [];
                            for (var j = 0; j < message.selectedBlocks.length; ++j)
                                object.selectedBlocks[j] = message.selectedBlocks[j];
                        }
                        if (message.textSlot != null && message.hasOwnProperty("textSlot"))
                            object.textSlot = message.textSlot;
                        if (message.htmlSlot != null && message.hasOwnProperty("htmlSlot"))
                            object.htmlSlot = message.htmlSlot;
                        if (message.anySlot != null && message.hasOwnProperty("anySlot"))
                            object.anySlot = message.anySlot;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Paste.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Paste.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Block.Paste
                     * @interface IResponse
                     * @property {anytype.Rpc.Block.Paste.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Block.Paste
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Block.Paste.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Block.Paste.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Block.Paste.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Paste.Response
                     * @static
                     * @param {anytype.Rpc.Block.Paste.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Paste.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Paste.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Paste.Response
                     * @static
                     * @param {anytype.Rpc.Block.Paste.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Block.Paste.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Paste.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Paste.Response
                     * @static
                     * @param {anytype.Rpc.Block.Paste.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Paste.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Paste.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Paste.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Block.Paste.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Paste.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Paste.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Paste.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Block.Paste.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Paste.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Paste.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Paste.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Paste.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Block.Paste.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Block.Paste.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Paste.Response
                     * @static
                     * @param {anytype.Rpc.Block.Paste.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Block.Paste.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Paste.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Block.Paste.Response
                         * @interface IError
                         * @property {anytype.Rpc.Block.Paste.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Block.Paste.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Block.Paste.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Block.Paste.Response.Error.Code} code
                         * @memberof anytype.Rpc.Block.Paste.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Block.Paste.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Paste.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Paste.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Paste.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Paste.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Paste.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Paste.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Paste.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Paste.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Paste.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Paste.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Paste.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Paste.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Paste.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Paste.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Paste.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Paste.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Paste.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Paste.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Paste.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Paste.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Paste.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Block.Paste.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Paste.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Block.Paste.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Paste;
            })();

            Block.Upload = (function() {

                /**
                 * Properties of an Upload.
                 * @memberof anytype.Rpc.Block
                 * @interface IUpload
                 */

                /**
                 * Constructs a new Upload.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents an Upload.
                 * @implements IUpload
                 * @constructor
                 * @param {anytype.Rpc.Block.IUpload=} [properties] Properties to set
                 */
                function Upload(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Upload instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Upload
                 * @static
                 * @param {anytype.Rpc.Block.IUpload=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Upload} Upload instance
                 */
                Upload.create = function create(properties) {
                    return new Upload(properties);
                };

                /**
                 * Encodes the specified Upload message. Does not implicitly {@link anytype.Rpc.Block.Upload.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Upload
                 * @static
                 * @param {anytype.Rpc.Block.IUpload} message Upload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Upload.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Upload message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Upload.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Upload
                 * @static
                 * @param {anytype.Rpc.Block.IUpload} message Upload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Upload.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Upload message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Upload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Upload} Upload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Upload.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Upload();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Upload message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Upload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Upload} Upload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Upload.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Upload message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Upload
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Upload.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an Upload message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Upload
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Upload} Upload
                 */
                Upload.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Upload)
                        return object;
                    return new $root.anytype.Rpc.Block.Upload();
                };

                /**
                 * Creates a plain object from an Upload message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Upload
                 * @static
                 * @param {anytype.Rpc.Block.Upload} message Upload
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Upload.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Upload to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Upload
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Upload.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Upload.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Block.Upload
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {string|null} [blockId] Request blockId
                     * @property {string|null} [localPath] Request localPath
                     * @property {string|null} [url] Request url
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Block.Upload
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Block.Upload.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request blockId.
                     * @member {string} blockId
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @instance
                     */
                    Request.prototype.blockId = "";

                    /**
                     * Request localPath.
                     * @member {string} localPath
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @instance
                     */
                    Request.prototype.localPath = "";

                    /**
                     * Request url.
                     * @member {string} url
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @instance
                     */
                    Request.prototype.url = "";

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @static
                     * @param {anytype.Rpc.Block.Upload.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Upload.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Upload.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @static
                     * @param {anytype.Rpc.Block.Upload.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                        if (message.localPath != null && message.hasOwnProperty("localPath"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.localPath);
                        if (message.url != null && message.hasOwnProperty("url"))
                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.url);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Upload.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @static
                     * @param {anytype.Rpc.Block.Upload.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Upload.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Upload.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                message.blockId = reader.string();
                                break;
                            case 3:
                                message.localPath = reader.string();
                                break;
                            case 4:
                                message.url = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Upload.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            if (!$util.isString(message.blockId))
                                return "blockId: string expected";
                        if (message.localPath != null && message.hasOwnProperty("localPath"))
                            if (!$util.isString(message.localPath))
                                return "localPath: string expected";
                        if (message.url != null && message.hasOwnProperty("url"))
                            if (!$util.isString(message.url))
                                return "url: string expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Upload.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Upload.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Upload.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.blockId != null)
                            message.blockId = String(object.blockId);
                        if (object.localPath != null)
                            message.localPath = String(object.localPath);
                        if (object.url != null)
                            message.url = String(object.url);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @static
                     * @param {anytype.Rpc.Block.Upload.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contextId = "";
                            object.blockId = "";
                            object.localPath = "";
                            object.url = "";
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            object.blockId = message.blockId;
                        if (message.localPath != null && message.hasOwnProperty("localPath"))
                            object.localPath = message.localPath;
                        if (message.url != null && message.hasOwnProperty("url"))
                            object.url = message.url;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Upload.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Upload.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Block.Upload
                     * @interface IResponse
                     * @property {anytype.Rpc.Block.Upload.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Block.Upload
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Block.Upload.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Block.Upload.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Block.Upload.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Upload.Response
                     * @static
                     * @param {anytype.Rpc.Block.Upload.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Upload.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Upload.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Upload.Response
                     * @static
                     * @param {anytype.Rpc.Block.Upload.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Block.Upload.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Upload.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Upload.Response
                     * @static
                     * @param {anytype.Rpc.Block.Upload.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Upload.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Upload.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Upload.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Block.Upload.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Upload.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Upload.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Upload.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Block.Upload.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Upload.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Upload.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Upload.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Upload.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Block.Upload.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Block.Upload.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Upload.Response
                     * @static
                     * @param {anytype.Rpc.Block.Upload.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Block.Upload.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Upload.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Block.Upload.Response
                         * @interface IError
                         * @property {anytype.Rpc.Block.Upload.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Block.Upload.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Block.Upload.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Block.Upload.Response.Error.Code} code
                         * @memberof anytype.Rpc.Block.Upload.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Block.Upload.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Upload.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Upload.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Upload.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Upload.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Upload.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Upload.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Upload.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Upload.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Upload.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Upload.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Upload.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Upload.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Upload.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Upload.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Upload.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Upload.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Upload.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Upload.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Upload.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Upload.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Upload.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Block.Upload.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Upload.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Block.Upload.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Upload;
            })();

            Block.Download = (function() {

                /**
                 * Properties of a Download.
                 * @memberof anytype.Rpc.Block
                 * @interface IDownload
                 */

                /**
                 * Constructs a new Download.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents a Download.
                 * @implements IDownload
                 * @constructor
                 * @param {anytype.Rpc.Block.IDownload=} [properties] Properties to set
                 */
                function Download(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Download instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Download
                 * @static
                 * @param {anytype.Rpc.Block.IDownload=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Download} Download instance
                 */
                Download.create = function create(properties) {
                    return new Download(properties);
                };

                /**
                 * Encodes the specified Download message. Does not implicitly {@link anytype.Rpc.Block.Download.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Download
                 * @static
                 * @param {anytype.Rpc.Block.IDownload} message Download message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Download.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Download message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Download.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Download
                 * @static
                 * @param {anytype.Rpc.Block.IDownload} message Download message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Download.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Download message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Download
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Download} Download
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Download.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Download();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Download message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Download
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Download} Download
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Download.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Download message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Download
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Download.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Download message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Download
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Download} Download
                 */
                Download.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Download)
                        return object;
                    return new $root.anytype.Rpc.Block.Download();
                };

                /**
                 * Creates a plain object from a Download message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Download
                 * @static
                 * @param {anytype.Rpc.Block.Download} message Download
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Download.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Download to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Download
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Download.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Download.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Block.Download
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {string|null} [blockId] Request blockId
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Block.Download
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Block.Download.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.Block.Download.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request blockId.
                     * @member {string} blockId
                     * @memberof anytype.Rpc.Block.Download.Request
                     * @instance
                     */
                    Request.prototype.blockId = "";

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Download.Request
                     * @static
                     * @param {anytype.Rpc.Block.Download.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Download.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Download.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Download.Request
                     * @static
                     * @param {anytype.Rpc.Block.Download.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Download.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Download.Request
                     * @static
                     * @param {anytype.Rpc.Block.Download.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Download.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Download.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Download.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                message.blockId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Download.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Download.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Download.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            if (!$util.isString(message.blockId))
                                return "blockId: string expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Download.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Download.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Download.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Download.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.blockId != null)
                            message.blockId = String(object.blockId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Download.Request
                     * @static
                     * @param {anytype.Rpc.Block.Download.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contextId = "";
                            object.blockId = "";
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            object.blockId = message.blockId;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Download.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Download.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Block.Download
                     * @interface IResponse
                     * @property {anytype.Rpc.Block.Download.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Block.Download
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Block.Download.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Block.Download.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Block.Download.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Download.Response
                     * @static
                     * @param {anytype.Rpc.Block.Download.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Download.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Download.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Download.Response
                     * @static
                     * @param {anytype.Rpc.Block.Download.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Block.Download.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Download.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Download.Response
                     * @static
                     * @param {anytype.Rpc.Block.Download.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Download.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Download.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Download.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Block.Download.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Download.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Download.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Download.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Block.Download.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Download.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Download.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Download.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Download.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Block.Download.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Block.Download.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Download.Response
                     * @static
                     * @param {anytype.Rpc.Block.Download.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Block.Download.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Download.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Block.Download.Response
                         * @interface IError
                         * @property {anytype.Rpc.Block.Download.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Block.Download.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Block.Download.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Block.Download.Response.Error.Code} code
                         * @memberof anytype.Rpc.Block.Download.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Block.Download.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Download.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Download.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Download.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Download.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Download.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Download.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Download.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Download.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Download.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Download.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Download.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Download.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Download.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Download.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Download.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Download.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Download.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Download.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Download.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Download.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Download.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Block.Download.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Download.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Block.Download.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Download;
            })();

            Block.Set = (function() {

                /**
                 * Properties of a Set.
                 * @memberof anytype.Rpc.Block
                 * @interface ISet
                 */

                /**
                 * Constructs a new Set.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents a Set.
                 * @implements ISet
                 * @constructor
                 * @param {anytype.Rpc.Block.ISet=} [properties] Properties to set
                 */
                function Set(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Set instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Set
                 * @static
                 * @param {anytype.Rpc.Block.ISet=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Set} Set instance
                 */
                Set.create = function create(properties) {
                    return new Set(properties);
                };

                /**
                 * Encodes the specified Set message. Does not implicitly {@link anytype.Rpc.Block.Set.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Set
                 * @static
                 * @param {anytype.Rpc.Block.ISet} message Set message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Set.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Set message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Set
                 * @static
                 * @param {anytype.Rpc.Block.ISet} message Set message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Set.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Set message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Set
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Set} Set
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Set.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Set message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Set
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Set} Set
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Set.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Set message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Set
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Set.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Set message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Set
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Set} Set
                 */
                Set.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Set)
                        return object;
                    return new $root.anytype.Rpc.Block.Set();
                };

                /**
                 * Creates a plain object from a Set message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Set
                 * @static
                 * @param {anytype.Rpc.Block.Set} message Set
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Set.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Set to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Set
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Set.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Set.Fields = (function() {

                    /**
                     * Properties of a Fields.
                     * @memberof anytype.Rpc.Block.Set
                     * @interface IFields
                     */

                    /**
                     * Constructs a new Fields.
                     * @memberof anytype.Rpc.Block.Set
                     * @classdesc Represents a Fields.
                     * @implements IFields
                     * @constructor
                     * @param {anytype.Rpc.Block.Set.IFields=} [properties] Properties to set
                     */
                    function Fields(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Fields instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Set.Fields
                     * @static
                     * @param {anytype.Rpc.Block.Set.IFields=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Set.Fields} Fields instance
                     */
                    Fields.create = function create(properties) {
                        return new Fields(properties);
                    };

                    /**
                     * Encodes the specified Fields message. Does not implicitly {@link anytype.Rpc.Block.Set.Fields.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Set.Fields
                     * @static
                     * @param {anytype.Rpc.Block.Set.IFields} message Fields message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Fields.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Fields message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Fields.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Set.Fields
                     * @static
                     * @param {anytype.Rpc.Block.Set.IFields} message Fields message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Fields.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Fields message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Set.Fields
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Set.Fields} Fields
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Fields.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Fields();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Fields message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Set.Fields
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Set.Fields} Fields
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Fields.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Fields message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Set.Fields
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Fields.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Fields message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Set.Fields
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Set.Fields} Fields
                     */
                    Fields.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Set.Fields)
                            return object;
                        return new $root.anytype.Rpc.Block.Set.Fields();
                    };

                    /**
                     * Creates a plain object from a Fields message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Set.Fields
                     * @static
                     * @param {anytype.Rpc.Block.Set.Fields} message Fields
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Fields.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Fields to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Set.Fields
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Fields.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Fields.Request = (function() {

                        /**
                         * Properties of a Request.
                         * @memberof anytype.Rpc.Block.Set.Fields
                         * @interface IRequest
                         * @property {string|null} [contextId] Request contextId
                         * @property {string|null} [blockId] Request blockId
                         * @property {google.protobuf.IStruct|null} [fields] Request fields
                         */

                        /**
                         * Constructs a new Request.
                         * @memberof anytype.Rpc.Block.Set.Fields
                         * @classdesc Represents a Request.
                         * @implements IRequest
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Fields.IRequest=} [properties] Properties to set
                         */
                        function Request(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Request contextId.
                         * @member {string} contextId
                         * @memberof anytype.Rpc.Block.Set.Fields.Request
                         * @instance
                         */
                        Request.prototype.contextId = "";

                        /**
                         * Request blockId.
                         * @member {string} blockId
                         * @memberof anytype.Rpc.Block.Set.Fields.Request
                         * @instance
                         */
                        Request.prototype.blockId = "";

                        /**
                         * Request fields.
                         * @member {google.protobuf.IStruct|null|undefined} fields
                         * @memberof anytype.Rpc.Block.Set.Fields.Request
                         * @instance
                         */
                        Request.prototype.fields = null;

                        /**
                         * Creates a new Request instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Fields.Request
                         * @static
                         * @param {anytype.Rpc.Block.Set.Fields.IRequest=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Fields.Request} Request instance
                         */
                        Request.create = function create(properties) {
                            return new Request(properties);
                        };

                        /**
                         * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.Fields.Request.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Fields.Request
                         * @static
                         * @param {anytype.Rpc.Block.Set.Fields.IRequest} message Request message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Request.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                            if (message.fields != null && message.hasOwnProperty("fields"))
                                $root.google.protobuf.Struct.encode(message.fields, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Fields.Request.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Fields.Request
                         * @static
                         * @param {anytype.Rpc.Block.Set.Fields.IRequest} message Request message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Request.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Request message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Fields.Request
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Fields.Request} Request
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Request.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Fields.Request();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.contextId = reader.string();
                                    break;
                                case 2:
                                    message.blockId = reader.string();
                                    break;
                                case 3:
                                    message.fields = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Request message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Fields.Request
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Fields.Request} Request
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Request.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Request message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Fields.Request
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Request.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                if (!$util.isString(message.contextId))
                                    return "contextId: string expected";
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                if (!$util.isString(message.blockId))
                                    return "blockId: string expected";
                            if (message.fields != null && message.hasOwnProperty("fields")) {
                                var error = $root.google.protobuf.Struct.verify(message.fields);
                                if (error)
                                    return "fields." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Request message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Fields.Request
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Fields.Request} Request
                         */
                        Request.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Fields.Request)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Set.Fields.Request();
                            if (object.contextId != null)
                                message.contextId = String(object.contextId);
                            if (object.blockId != null)
                                message.blockId = String(object.blockId);
                            if (object.fields != null) {
                                if (typeof object.fields !== "object")
                                    throw TypeError(".anytype.Rpc.Block.Set.Fields.Request.fields: object expected");
                                message.fields = $root.google.protobuf.Struct.fromObject(object.fields);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Request message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Fields.Request
                         * @static
                         * @param {anytype.Rpc.Block.Set.Fields.Request} message Request
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Request.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.contextId = "";
                                object.blockId = "";
                                object.fields = null;
                            }
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                object.contextId = message.contextId;
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                object.blockId = message.blockId;
                            if (message.fields != null && message.hasOwnProperty("fields"))
                                object.fields = $root.google.protobuf.Struct.toObject(message.fields, options);
                            return object;
                        };

                        /**
                         * Converts this Request to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Fields.Request
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Request.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Request;
                    })();

                    Fields.Response = (function() {

                        /**
                         * Properties of a Response.
                         * @memberof anytype.Rpc.Block.Set.Fields
                         * @interface IResponse
                         * @property {anytype.Rpc.Block.Set.Fields.Response.IError|null} [error] Response error
                         */

                        /**
                         * Constructs a new Response.
                         * @memberof anytype.Rpc.Block.Set.Fields
                         * @classdesc Represents a Response.
                         * @implements IResponse
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Fields.IResponse=} [properties] Properties to set
                         */
                        function Response(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Response error.
                         * @member {anytype.Rpc.Block.Set.Fields.Response.IError|null|undefined} error
                         * @memberof anytype.Rpc.Block.Set.Fields.Response
                         * @instance
                         */
                        Response.prototype.error = null;

                        /**
                         * Creates a new Response instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Fields.Response
                         * @static
                         * @param {anytype.Rpc.Block.Set.Fields.IResponse=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Fields.Response} Response instance
                         */
                        Response.create = function create(properties) {
                            return new Response(properties);
                        };

                        /**
                         * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.Fields.Response.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Fields.Response
                         * @static
                         * @param {anytype.Rpc.Block.Set.Fields.IResponse} message Response message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Response.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.error != null && message.hasOwnProperty("error"))
                                $root.anytype.Rpc.Block.Set.Fields.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Fields.Response.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Fields.Response
                         * @static
                         * @param {anytype.Rpc.Block.Set.Fields.IResponse} message Response message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Response.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Response message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Fields.Response
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Fields.Response} Response
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Response.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Fields.Response();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.error = $root.anytype.Rpc.Block.Set.Fields.Response.Error.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Response message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Fields.Response
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Fields.Response} Response
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Response.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Response message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Fields.Response
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Response.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.error != null && message.hasOwnProperty("error")) {
                                var error = $root.anytype.Rpc.Block.Set.Fields.Response.Error.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Response message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Fields.Response
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Fields.Response} Response
                         */
                        Response.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Fields.Response)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Set.Fields.Response();
                            if (object.error != null) {
                                if (typeof object.error !== "object")
                                    throw TypeError(".anytype.Rpc.Block.Set.Fields.Response.error: object expected");
                                message.error = $root.anytype.Rpc.Block.Set.Fields.Response.Error.fromObject(object.error);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Response message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Fields.Response
                         * @static
                         * @param {anytype.Rpc.Block.Set.Fields.Response} message Response
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Response.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.error = null;
                            if (message.error != null && message.hasOwnProperty("error"))
                                object.error = $root.anytype.Rpc.Block.Set.Fields.Response.Error.toObject(message.error, options);
                            return object;
                        };

                        /**
                         * Converts this Response to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Fields.Response
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Response.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Response.Error = (function() {

                            /**
                             * Properties of an Error.
                             * @memberof anytype.Rpc.Block.Set.Fields.Response
                             * @interface IError
                             * @property {anytype.Rpc.Block.Set.Fields.Response.Error.Code|null} [code] Error code
                             * @property {string|null} [description] Error description
                             */

                            /**
                             * Constructs a new Error.
                             * @memberof anytype.Rpc.Block.Set.Fields.Response
                             * @classdesc Represents an Error.
                             * @implements IError
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Fields.Response.IError=} [properties] Properties to set
                             */
                            function Error(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Error code.
                             * @member {anytype.Rpc.Block.Set.Fields.Response.Error.Code} code
                             * @memberof anytype.Rpc.Block.Set.Fields.Response.Error
                             * @instance
                             */
                            Error.prototype.code = 0;

                            /**
                             * Error description.
                             * @member {string} description
                             * @memberof anytype.Rpc.Block.Set.Fields.Response.Error
                             * @instance
                             */
                            Error.prototype.description = "";

                            /**
                             * Creates a new Error instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Fields.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Set.Fields.Response.IError=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Fields.Response.Error} Error instance
                             */
                            Error.create = function create(properties) {
                                return new Error(properties);
                            };

                            /**
                             * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.Fields.Response.Error.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Fields.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Set.Fields.Response.IError} message Error message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Error.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.code != null && message.hasOwnProperty("code"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                if (message.description != null && message.hasOwnProperty("description"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                return writer;
                            };

                            /**
                             * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Fields.Response.Error.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Fields.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Set.Fields.Response.IError} message Error message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Error.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes an Error message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Fields.Response.Error
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Fields.Response.Error} Error
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Error.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Fields.Response.Error();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.code = reader.int32();
                                        break;
                                    case 2:
                                        message.description = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes an Error message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Fields.Response.Error
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Fields.Response.Error} Error
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Error.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies an Error message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Fields.Response.Error
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Error.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.code != null && message.hasOwnProperty("code"))
                                    switch (message.code) {
                                    default:
                                        return "code: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                        break;
                                    }
                                if (message.description != null && message.hasOwnProperty("description"))
                                    if (!$util.isString(message.description))
                                        return "description: string expected";
                                return null;
                            };

                            /**
                             * Creates an Error message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Fields.Response.Error
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Fields.Response.Error} Error
                             */
                            Error.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Fields.Response.Error)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Fields.Response.Error();
                                switch (object.code) {
                                case "NULL":
                                case 0:
                                    message.code = 0;
                                    break;
                                case "UNKNOWN_ERROR":
                                case 1:
                                    message.code = 1;
                                    break;
                                case "BAD_INPUT":
                                case 2:
                                    message.code = 2;
                                    break;
                                }
                                if (object.description != null)
                                    message.description = String(object.description);
                                return message;
                            };

                            /**
                             * Creates a plain object from an Error message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Fields.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Set.Fields.Response.Error} message Error
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Error.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.code = options.enums === String ? "NULL" : 0;
                                    object.description = "";
                                }
                                if (message.code != null && message.hasOwnProperty("code"))
                                    object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.Fields.Response.Error.Code[message.code] : message.code;
                                if (message.description != null && message.hasOwnProperty("description"))
                                    object.description = message.description;
                                return object;
                            };

                            /**
                             * Converts this Error to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Fields.Response.Error
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Error.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Code enum.
                             * @name anytype.Rpc.Block.Set.Fields.Response.Error.Code
                             * @enum {string}
                             * @property {number} NULL=0 NULL value
                             * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                             * @property {number} BAD_INPUT=2 BAD_INPUT value
                             */
                            Error.Code = (function() {
                                var valuesById = {}, values = Object.create(valuesById);
                                values[valuesById[0] = "NULL"] = 0;
                                values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                values[valuesById[2] = "BAD_INPUT"] = 2;
                                return values;
                            })();

                            return Error;
                        })();

                        return Response;
                    })();

                    return Fields;
                })();

                Set.Restrictions = (function() {

                    /**
                     * Properties of a Restrictions.
                     * @memberof anytype.Rpc.Block.Set
                     * @interface IRestrictions
                     */

                    /**
                     * Constructs a new Restrictions.
                     * @memberof anytype.Rpc.Block.Set
                     * @classdesc Represents a Restrictions.
                     * @implements IRestrictions
                     * @constructor
                     * @param {anytype.Rpc.Block.Set.IRestrictions=} [properties] Properties to set
                     */
                    function Restrictions(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Restrictions instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Set.Restrictions
                     * @static
                     * @param {anytype.Rpc.Block.Set.IRestrictions=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Set.Restrictions} Restrictions instance
                     */
                    Restrictions.create = function create(properties) {
                        return new Restrictions(properties);
                    };

                    /**
                     * Encodes the specified Restrictions message. Does not implicitly {@link anytype.Rpc.Block.Set.Restrictions.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Set.Restrictions
                     * @static
                     * @param {anytype.Rpc.Block.Set.IRestrictions} message Restrictions message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Restrictions.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Restrictions message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Restrictions.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Set.Restrictions
                     * @static
                     * @param {anytype.Rpc.Block.Set.IRestrictions} message Restrictions message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Restrictions.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Restrictions message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Set.Restrictions
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Set.Restrictions} Restrictions
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Restrictions.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Restrictions();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Restrictions message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Set.Restrictions
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Set.Restrictions} Restrictions
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Restrictions.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Restrictions message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Set.Restrictions
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Restrictions.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Restrictions message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Set.Restrictions
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Set.Restrictions} Restrictions
                     */
                    Restrictions.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Set.Restrictions)
                            return object;
                        return new $root.anytype.Rpc.Block.Set.Restrictions();
                    };

                    /**
                     * Creates a plain object from a Restrictions message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Set.Restrictions
                     * @static
                     * @param {anytype.Rpc.Block.Set.Restrictions} message Restrictions
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Restrictions.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Restrictions to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Set.Restrictions
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Restrictions.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Restrictions.Request = (function() {

                        /**
                         * Properties of a Request.
                         * @memberof anytype.Rpc.Block.Set.Restrictions
                         * @interface IRequest
                         * @property {string|null} [contextId] Request contextId
                         * @property {string|null} [blockId] Request blockId
                         * @property {anytype.model.Block.IRestrictions|null} [restrictions] Request restrictions
                         */

                        /**
                         * Constructs a new Request.
                         * @memberof anytype.Rpc.Block.Set.Restrictions
                         * @classdesc Represents a Request.
                         * @implements IRequest
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Restrictions.IRequest=} [properties] Properties to set
                         */
                        function Request(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Request contextId.
                         * @member {string} contextId
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Request
                         * @instance
                         */
                        Request.prototype.contextId = "";

                        /**
                         * Request blockId.
                         * @member {string} blockId
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Request
                         * @instance
                         */
                        Request.prototype.blockId = "";

                        /**
                         * Request restrictions.
                         * @member {anytype.model.Block.IRestrictions|null|undefined} restrictions
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Request
                         * @instance
                         */
                        Request.prototype.restrictions = null;

                        /**
                         * Creates a new Request instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Request
                         * @static
                         * @param {anytype.Rpc.Block.Set.Restrictions.IRequest=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Restrictions.Request} Request instance
                         */
                        Request.create = function create(properties) {
                            return new Request(properties);
                        };

                        /**
                         * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.Restrictions.Request.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Request
                         * @static
                         * @param {anytype.Rpc.Block.Set.Restrictions.IRequest} message Request message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Request.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                            if (message.restrictions != null && message.hasOwnProperty("restrictions"))
                                $root.anytype.model.Block.Restrictions.encode(message.restrictions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Restrictions.Request.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Request
                         * @static
                         * @param {anytype.Rpc.Block.Set.Restrictions.IRequest} message Request message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Request.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Request message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Request
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Restrictions.Request} Request
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Request.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Restrictions.Request();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.contextId = reader.string();
                                    break;
                                case 2:
                                    message.blockId = reader.string();
                                    break;
                                case 3:
                                    message.restrictions = $root.anytype.model.Block.Restrictions.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Request message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Request
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Restrictions.Request} Request
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Request.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Request message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Request
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Request.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                if (!$util.isString(message.contextId))
                                    return "contextId: string expected";
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                if (!$util.isString(message.blockId))
                                    return "blockId: string expected";
                            if (message.restrictions != null && message.hasOwnProperty("restrictions")) {
                                var error = $root.anytype.model.Block.Restrictions.verify(message.restrictions);
                                if (error)
                                    return "restrictions." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Request message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Request
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Restrictions.Request} Request
                         */
                        Request.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Restrictions.Request)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Set.Restrictions.Request();
                            if (object.contextId != null)
                                message.contextId = String(object.contextId);
                            if (object.blockId != null)
                                message.blockId = String(object.blockId);
                            if (object.restrictions != null) {
                                if (typeof object.restrictions !== "object")
                                    throw TypeError(".anytype.Rpc.Block.Set.Restrictions.Request.restrictions: object expected");
                                message.restrictions = $root.anytype.model.Block.Restrictions.fromObject(object.restrictions);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Request message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Request
                         * @static
                         * @param {anytype.Rpc.Block.Set.Restrictions.Request} message Request
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Request.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.contextId = "";
                                object.blockId = "";
                                object.restrictions = null;
                            }
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                object.contextId = message.contextId;
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                object.blockId = message.blockId;
                            if (message.restrictions != null && message.hasOwnProperty("restrictions"))
                                object.restrictions = $root.anytype.model.Block.Restrictions.toObject(message.restrictions, options);
                            return object;
                        };

                        /**
                         * Converts this Request to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Request
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Request.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Request;
                    })();

                    Restrictions.Response = (function() {

                        /**
                         * Properties of a Response.
                         * @memberof anytype.Rpc.Block.Set.Restrictions
                         * @interface IResponse
                         * @property {anytype.Rpc.Block.Set.Restrictions.Response.IError|null} [error] Response error
                         */

                        /**
                         * Constructs a new Response.
                         * @memberof anytype.Rpc.Block.Set.Restrictions
                         * @classdesc Represents a Response.
                         * @implements IResponse
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Restrictions.IResponse=} [properties] Properties to set
                         */
                        function Response(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Response error.
                         * @member {anytype.Rpc.Block.Set.Restrictions.Response.IError|null|undefined} error
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Response
                         * @instance
                         */
                        Response.prototype.error = null;

                        /**
                         * Creates a new Response instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Response
                         * @static
                         * @param {anytype.Rpc.Block.Set.Restrictions.IResponse=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Restrictions.Response} Response instance
                         */
                        Response.create = function create(properties) {
                            return new Response(properties);
                        };

                        /**
                         * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.Restrictions.Response.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Response
                         * @static
                         * @param {anytype.Rpc.Block.Set.Restrictions.IResponse} message Response message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Response.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.error != null && message.hasOwnProperty("error"))
                                $root.anytype.Rpc.Block.Set.Restrictions.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Restrictions.Response.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Response
                         * @static
                         * @param {anytype.Rpc.Block.Set.Restrictions.IResponse} message Response message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Response.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Response message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Response
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Restrictions.Response} Response
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Response.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Restrictions.Response();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.error = $root.anytype.Rpc.Block.Set.Restrictions.Response.Error.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Response message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Response
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Restrictions.Response} Response
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Response.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Response message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Response
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Response.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.error != null && message.hasOwnProperty("error")) {
                                var error = $root.anytype.Rpc.Block.Set.Restrictions.Response.Error.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Response message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Response
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Restrictions.Response} Response
                         */
                        Response.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Restrictions.Response)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Set.Restrictions.Response();
                            if (object.error != null) {
                                if (typeof object.error !== "object")
                                    throw TypeError(".anytype.Rpc.Block.Set.Restrictions.Response.error: object expected");
                                message.error = $root.anytype.Rpc.Block.Set.Restrictions.Response.Error.fromObject(object.error);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Response message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Response
                         * @static
                         * @param {anytype.Rpc.Block.Set.Restrictions.Response} message Response
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Response.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.error = null;
                            if (message.error != null && message.hasOwnProperty("error"))
                                object.error = $root.anytype.Rpc.Block.Set.Restrictions.Response.Error.toObject(message.error, options);
                            return object;
                        };

                        /**
                         * Converts this Response to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Restrictions.Response
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Response.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Response.Error = (function() {

                            /**
                             * Properties of an Error.
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response
                             * @interface IError
                             * @property {anytype.Rpc.Block.Set.Restrictions.Response.Error.Code|null} [code] Error code
                             * @property {string|null} [description] Error description
                             */

                            /**
                             * Constructs a new Error.
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response
                             * @classdesc Represents an Error.
                             * @implements IError
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Restrictions.Response.IError=} [properties] Properties to set
                             */
                            function Error(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Error code.
                             * @member {anytype.Rpc.Block.Set.Restrictions.Response.Error.Code} code
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response.Error
                             * @instance
                             */
                            Error.prototype.code = 0;

                            /**
                             * Error description.
                             * @member {string} description
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response.Error
                             * @instance
                             */
                            Error.prototype.description = "";

                            /**
                             * Creates a new Error instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Set.Restrictions.Response.IError=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Restrictions.Response.Error} Error instance
                             */
                            Error.create = function create(properties) {
                                return new Error(properties);
                            };

                            /**
                             * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.Restrictions.Response.Error.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Set.Restrictions.Response.IError} message Error message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Error.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.code != null && message.hasOwnProperty("code"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                if (message.description != null && message.hasOwnProperty("description"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                return writer;
                            };

                            /**
                             * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Restrictions.Response.Error.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Set.Restrictions.Response.IError} message Error message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Error.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes an Error message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response.Error
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Restrictions.Response.Error} Error
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Error.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Restrictions.Response.Error();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.code = reader.int32();
                                        break;
                                    case 2:
                                        message.description = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes an Error message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response.Error
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Restrictions.Response.Error} Error
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Error.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies an Error message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response.Error
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Error.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.code != null && message.hasOwnProperty("code"))
                                    switch (message.code) {
                                    default:
                                        return "code: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                        break;
                                    }
                                if (message.description != null && message.hasOwnProperty("description"))
                                    if (!$util.isString(message.description))
                                        return "description: string expected";
                                return null;
                            };

                            /**
                             * Creates an Error message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response.Error
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Restrictions.Response.Error} Error
                             */
                            Error.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Restrictions.Response.Error)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Restrictions.Response.Error();
                                switch (object.code) {
                                case "NULL":
                                case 0:
                                    message.code = 0;
                                    break;
                                case "UNKNOWN_ERROR":
                                case 1:
                                    message.code = 1;
                                    break;
                                case "BAD_INPUT":
                                case 2:
                                    message.code = 2;
                                    break;
                                }
                                if (object.description != null)
                                    message.description = String(object.description);
                                return message;
                            };

                            /**
                             * Creates a plain object from an Error message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Set.Restrictions.Response.Error} message Error
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Error.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.code = options.enums === String ? "NULL" : 0;
                                    object.description = "";
                                }
                                if (message.code != null && message.hasOwnProperty("code"))
                                    object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.Restrictions.Response.Error.Code[message.code] : message.code;
                                if (message.description != null && message.hasOwnProperty("description"))
                                    object.description = message.description;
                                return object;
                            };

                            /**
                             * Converts this Error to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Restrictions.Response.Error
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Error.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Code enum.
                             * @name anytype.Rpc.Block.Set.Restrictions.Response.Error.Code
                             * @enum {string}
                             * @property {number} NULL=0 NULL value
                             * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                             * @property {number} BAD_INPUT=2 BAD_INPUT value
                             */
                            Error.Code = (function() {
                                var valuesById = {}, values = Object.create(valuesById);
                                values[valuesById[0] = "NULL"] = 0;
                                values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                values[valuesById[2] = "BAD_INPUT"] = 2;
                                return values;
                            })();

                            return Error;
                        })();

                        return Response;
                    })();

                    return Restrictions;
                })();

                Set.IsArchived = (function() {

                    /**
                     * Properties of an IsArchived.
                     * @memberof anytype.Rpc.Block.Set
                     * @interface IIsArchived
                     */

                    /**
                     * Constructs a new IsArchived.
                     * @memberof anytype.Rpc.Block.Set
                     * @classdesc Represents an IsArchived.
                     * @implements IIsArchived
                     * @constructor
                     * @param {anytype.Rpc.Block.Set.IIsArchived=} [properties] Properties to set
                     */
                    function IsArchived(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new IsArchived instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Set.IsArchived
                     * @static
                     * @param {anytype.Rpc.Block.Set.IIsArchived=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Set.IsArchived} IsArchived instance
                     */
                    IsArchived.create = function create(properties) {
                        return new IsArchived(properties);
                    };

                    /**
                     * Encodes the specified IsArchived message. Does not implicitly {@link anytype.Rpc.Block.Set.IsArchived.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Set.IsArchived
                     * @static
                     * @param {anytype.Rpc.Block.Set.IIsArchived} message IsArchived message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    IsArchived.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified IsArchived message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.IsArchived.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Set.IsArchived
                     * @static
                     * @param {anytype.Rpc.Block.Set.IIsArchived} message IsArchived message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    IsArchived.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an IsArchived message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Set.IsArchived
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Set.IsArchived} IsArchived
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    IsArchived.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.IsArchived();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an IsArchived message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Set.IsArchived
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Set.IsArchived} IsArchived
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    IsArchived.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an IsArchived message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Set.IsArchived
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    IsArchived.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates an IsArchived message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Set.IsArchived
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Set.IsArchived} IsArchived
                     */
                    IsArchived.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Set.IsArchived)
                            return object;
                        return new $root.anytype.Rpc.Block.Set.IsArchived();
                    };

                    /**
                     * Creates a plain object from an IsArchived message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Set.IsArchived
                     * @static
                     * @param {anytype.Rpc.Block.Set.IsArchived} message IsArchived
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    IsArchived.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this IsArchived to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Set.IsArchived
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    IsArchived.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    IsArchived.Request = (function() {

                        /**
                         * Properties of a Request.
                         * @memberof anytype.Rpc.Block.Set.IsArchived
                         * @interface IRequest
                         * @property {string|null} [contextId] Request contextId
                         * @property {string|null} [blockId] Request blockId
                         * @property {boolean|null} [IsArchived] Request IsArchived
                         */

                        /**
                         * Constructs a new Request.
                         * @memberof anytype.Rpc.Block.Set.IsArchived
                         * @classdesc Represents a Request.
                         * @implements IRequest
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.IsArchived.IRequest=} [properties] Properties to set
                         */
                        function Request(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Request contextId.
                         * @member {string} contextId
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Request
                         * @instance
                         */
                        Request.prototype.contextId = "";

                        /**
                         * Request blockId.
                         * @member {string} blockId
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Request
                         * @instance
                         */
                        Request.prototype.blockId = "";

                        /**
                         * Request IsArchived.
                         * @member {boolean} IsArchived
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Request
                         * @instance
                         */
                        Request.prototype.IsArchived = false;

                        /**
                         * Creates a new Request instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Request
                         * @static
                         * @param {anytype.Rpc.Block.Set.IsArchived.IRequest=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.IsArchived.Request} Request instance
                         */
                        Request.create = function create(properties) {
                            return new Request(properties);
                        };

                        /**
                         * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.IsArchived.Request.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Request
                         * @static
                         * @param {anytype.Rpc.Block.Set.IsArchived.IRequest} message Request message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Request.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                            if (message.IsArchived != null && message.hasOwnProperty("IsArchived"))
                                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.IsArchived);
                            return writer;
                        };

                        /**
                         * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.IsArchived.Request.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Request
                         * @static
                         * @param {anytype.Rpc.Block.Set.IsArchived.IRequest} message Request message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Request.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Request message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Request
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.IsArchived.Request} Request
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Request.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.IsArchived.Request();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.contextId = reader.string();
                                    break;
                                case 2:
                                    message.blockId = reader.string();
                                    break;
                                case 3:
                                    message.IsArchived = reader.bool();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Request message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Request
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.IsArchived.Request} Request
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Request.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Request message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Request
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Request.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                if (!$util.isString(message.contextId))
                                    return "contextId: string expected";
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                if (!$util.isString(message.blockId))
                                    return "blockId: string expected";
                            if (message.IsArchived != null && message.hasOwnProperty("IsArchived"))
                                if (typeof message.IsArchived !== "boolean")
                                    return "IsArchived: boolean expected";
                            return null;
                        };

                        /**
                         * Creates a Request message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Request
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.IsArchived.Request} Request
                         */
                        Request.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.IsArchived.Request)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Set.IsArchived.Request();
                            if (object.contextId != null)
                                message.contextId = String(object.contextId);
                            if (object.blockId != null)
                                message.blockId = String(object.blockId);
                            if (object.IsArchived != null)
                                message.IsArchived = Boolean(object.IsArchived);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Request message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Request
                         * @static
                         * @param {anytype.Rpc.Block.Set.IsArchived.Request} message Request
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Request.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.contextId = "";
                                object.blockId = "";
                                object.IsArchived = false;
                            }
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                object.contextId = message.contextId;
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                object.blockId = message.blockId;
                            if (message.IsArchived != null && message.hasOwnProperty("IsArchived"))
                                object.IsArchived = message.IsArchived;
                            return object;
                        };

                        /**
                         * Converts this Request to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Request
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Request.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Request;
                    })();

                    IsArchived.Response = (function() {

                        /**
                         * Properties of a Response.
                         * @memberof anytype.Rpc.Block.Set.IsArchived
                         * @interface IResponse
                         * @property {anytype.Rpc.Block.Set.IsArchived.Response.IError|null} [error] Response error
                         */

                        /**
                         * Constructs a new Response.
                         * @memberof anytype.Rpc.Block.Set.IsArchived
                         * @classdesc Represents a Response.
                         * @implements IResponse
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.IsArchived.IResponse=} [properties] Properties to set
                         */
                        function Response(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Response error.
                         * @member {anytype.Rpc.Block.Set.IsArchived.Response.IError|null|undefined} error
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Response
                         * @instance
                         */
                        Response.prototype.error = null;

                        /**
                         * Creates a new Response instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Response
                         * @static
                         * @param {anytype.Rpc.Block.Set.IsArchived.IResponse=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.IsArchived.Response} Response instance
                         */
                        Response.create = function create(properties) {
                            return new Response(properties);
                        };

                        /**
                         * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.IsArchived.Response.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Response
                         * @static
                         * @param {anytype.Rpc.Block.Set.IsArchived.IResponse} message Response message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Response.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.error != null && message.hasOwnProperty("error"))
                                $root.anytype.Rpc.Block.Set.IsArchived.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.IsArchived.Response.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Response
                         * @static
                         * @param {anytype.Rpc.Block.Set.IsArchived.IResponse} message Response message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Response.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Response message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Response
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.IsArchived.Response} Response
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Response.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.IsArchived.Response();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.error = $root.anytype.Rpc.Block.Set.IsArchived.Response.Error.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Response message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Response
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.IsArchived.Response} Response
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Response.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Response message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Response
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Response.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.error != null && message.hasOwnProperty("error")) {
                                var error = $root.anytype.Rpc.Block.Set.IsArchived.Response.Error.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Response message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Response
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.IsArchived.Response} Response
                         */
                        Response.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.IsArchived.Response)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Set.IsArchived.Response();
                            if (object.error != null) {
                                if (typeof object.error !== "object")
                                    throw TypeError(".anytype.Rpc.Block.Set.IsArchived.Response.error: object expected");
                                message.error = $root.anytype.Rpc.Block.Set.IsArchived.Response.Error.fromObject(object.error);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Response message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Response
                         * @static
                         * @param {anytype.Rpc.Block.Set.IsArchived.Response} message Response
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Response.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.error = null;
                            if (message.error != null && message.hasOwnProperty("error"))
                                object.error = $root.anytype.Rpc.Block.Set.IsArchived.Response.Error.toObject(message.error, options);
                            return object;
                        };

                        /**
                         * Converts this Response to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.IsArchived.Response
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Response.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Response.Error = (function() {

                            /**
                             * Properties of an Error.
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response
                             * @interface IError
                             * @property {anytype.Rpc.Block.Set.IsArchived.Response.Error.Code|null} [code] Error code
                             * @property {string|null} [description] Error description
                             */

                            /**
                             * Constructs a new Error.
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response
                             * @classdesc Represents an Error.
                             * @implements IError
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.IsArchived.Response.IError=} [properties] Properties to set
                             */
                            function Error(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Error code.
                             * @member {anytype.Rpc.Block.Set.IsArchived.Response.Error.Code} code
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response.Error
                             * @instance
                             */
                            Error.prototype.code = 0;

                            /**
                             * Error description.
                             * @member {string} description
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response.Error
                             * @instance
                             */
                            Error.prototype.description = "";

                            /**
                             * Creates a new Error instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Set.IsArchived.Response.IError=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.IsArchived.Response.Error} Error instance
                             */
                            Error.create = function create(properties) {
                                return new Error(properties);
                            };

                            /**
                             * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.IsArchived.Response.Error.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Set.IsArchived.Response.IError} message Error message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Error.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.code != null && message.hasOwnProperty("code"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                if (message.description != null && message.hasOwnProperty("description"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                return writer;
                            };

                            /**
                             * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.IsArchived.Response.Error.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Set.IsArchived.Response.IError} message Error message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Error.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes an Error message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response.Error
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.IsArchived.Response.Error} Error
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Error.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.IsArchived.Response.Error();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.code = reader.int32();
                                        break;
                                    case 2:
                                        message.description = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes an Error message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response.Error
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.IsArchived.Response.Error} Error
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Error.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies an Error message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response.Error
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Error.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.code != null && message.hasOwnProperty("code"))
                                    switch (message.code) {
                                    default:
                                        return "code: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                        break;
                                    }
                                if (message.description != null && message.hasOwnProperty("description"))
                                    if (!$util.isString(message.description))
                                        return "description: string expected";
                                return null;
                            };

                            /**
                             * Creates an Error message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response.Error
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.IsArchived.Response.Error} Error
                             */
                            Error.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.IsArchived.Response.Error)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.IsArchived.Response.Error();
                                switch (object.code) {
                                case "NULL":
                                case 0:
                                    message.code = 0;
                                    break;
                                case "UNKNOWN_ERROR":
                                case 1:
                                    message.code = 1;
                                    break;
                                case "BAD_INPUT":
                                case 2:
                                    message.code = 2;
                                    break;
                                }
                                if (object.description != null)
                                    message.description = String(object.description);
                                return message;
                            };

                            /**
                             * Creates a plain object from an Error message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Set.IsArchived.Response.Error} message Error
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Error.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.code = options.enums === String ? "NULL" : 0;
                                    object.description = "";
                                }
                                if (message.code != null && message.hasOwnProperty("code"))
                                    object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.IsArchived.Response.Error.Code[message.code] : message.code;
                                if (message.description != null && message.hasOwnProperty("description"))
                                    object.description = message.description;
                                return object;
                            };

                            /**
                             * Converts this Error to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.IsArchived.Response.Error
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Error.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Code enum.
                             * @name anytype.Rpc.Block.Set.IsArchived.Response.Error.Code
                             * @enum {string}
                             * @property {number} NULL=0 NULL value
                             * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                             * @property {number} BAD_INPUT=2 BAD_INPUT value
                             */
                            Error.Code = (function() {
                                var valuesById = {}, values = Object.create(valuesById);
                                values[valuesById[0] = "NULL"] = 0;
                                values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                values[valuesById[2] = "BAD_INPUT"] = 2;
                                return values;
                            })();

                            return Error;
                        })();

                        return Response;
                    })();

                    return IsArchived;
                })();

                Set.Text = (function() {

                    /**
                     * Properties of a Text.
                     * @memberof anytype.Rpc.Block.Set
                     * @interface IText
                     */

                    /**
                     * Constructs a new Text.
                     * @memberof anytype.Rpc.Block.Set
                     * @classdesc Represents a Text.
                     * @implements IText
                     * @constructor
                     * @param {anytype.Rpc.Block.Set.IText=} [properties] Properties to set
                     */
                    function Text(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Text instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Set.Text
                     * @static
                     * @param {anytype.Rpc.Block.Set.IText=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Set.Text} Text instance
                     */
                    Text.create = function create(properties) {
                        return new Text(properties);
                    };

                    /**
                     * Encodes the specified Text message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Set.Text
                     * @static
                     * @param {anytype.Rpc.Block.Set.IText} message Text message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Text.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Text message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Set.Text
                     * @static
                     * @param {anytype.Rpc.Block.Set.IText} message Text message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Text.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Text message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Set.Text
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Set.Text} Text
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Text.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Text message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Set.Text
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Set.Text} Text
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Text.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Text message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Set.Text
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Text.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Text message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Set.Text
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Set.Text} Text
                     */
                    Text.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Set.Text)
                            return object;
                        return new $root.anytype.Rpc.Block.Set.Text();
                    };

                    /**
                     * Creates a plain object from a Text message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Set.Text
                     * @static
                     * @param {anytype.Rpc.Block.Set.Text} message Text
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Text.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Text to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Set.Text
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Text.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Text.Text = (function() {

                        /**
                         * Properties of a Text.
                         * @memberof anytype.Rpc.Block.Set.Text
                         * @interface IText
                         */

                        /**
                         * Constructs a new Text.
                         * @memberof anytype.Rpc.Block.Set.Text
                         * @classdesc Represents a Text.
                         * @implements IText
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Text.IText=} [properties] Properties to set
                         */
                        function Text(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Text instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Text.Text
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IText=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Text.Text} Text instance
                         */
                        Text.create = function create(properties) {
                            return new Text(properties);
                        };

                        /**
                         * Encodes the specified Text message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Text.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Text.Text
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IText} message Text message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Text.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Text message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Text.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Text.Text
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IText} message Text message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Text.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Text message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Text.Text
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Text.Text} Text
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Text.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Text();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Text message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Text.Text
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Text.Text} Text
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Text.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Text message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Text.Text
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Text.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Text message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Text.Text
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Text.Text} Text
                         */
                        Text.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Text.Text)
                                return object;
                            return new $root.anytype.Rpc.Block.Set.Text.Text();
                        };

                        /**
                         * Creates a plain object from a Text message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Text.Text
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.Text} message Text
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Text.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Text to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Text.Text
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Text.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Text.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Block.Set.Text.Text
                             * @interface IRequest
                             * @property {string|null} [contextId] Request contextId
                             * @property {string|null} [blockId] Request blockId
                             * @property {string|null} [text] Request text
                             * @property {anytype.model.Block.Content.Text.IMarks|null} [marks] Request marks
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Block.Set.Text.Text
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Text.Text.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request contextId.
                             * @member {string} contextId
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @instance
                             */
                            Request.prototype.contextId = "";

                            /**
                             * Request blockId.
                             * @member {string} blockId
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @instance
                             */
                            Request.prototype.blockId = "";

                            /**
                             * Request text.
                             * @member {string} text
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @instance
                             */
                            Request.prototype.text = "";

                            /**
                             * Request marks.
                             * @member {anytype.model.Block.Content.Text.IMarks|null|undefined} marks
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @instance
                             */
                            Request.prototype.marks = null;

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Text.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Text.Text.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Text.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Text.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                                if (message.text != null && message.hasOwnProperty("text"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.text);
                                if (message.marks != null && message.hasOwnProperty("marks"))
                                    $root.anytype.model.Block.Content.Text.Marks.encode(message.marks, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Text.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Text.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Text.Text.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Text.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.contextId = reader.string();
                                        break;
                                    case 2:
                                        message.blockId = reader.string();
                                        break;
                                    case 3:
                                        message.text = reader.string();
                                        break;
                                    case 4:
                                        message.marks = $root.anytype.model.Block.Content.Text.Marks.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Text.Text.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    if (!$util.isString(message.contextId))
                                        return "contextId: string expected";
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    if (!$util.isString(message.blockId))
                                        return "blockId: string expected";
                                if (message.text != null && message.hasOwnProperty("text"))
                                    if (!$util.isString(message.text))
                                        return "text: string expected";
                                if (message.marks != null && message.hasOwnProperty("marks")) {
                                    var error = $root.anytype.model.Block.Content.Text.Marks.verify(message.marks);
                                    if (error)
                                        return "marks." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Text.Text.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Text.Text.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Text.Text.Request();
                                if (object.contextId != null)
                                    message.contextId = String(object.contextId);
                                if (object.blockId != null)
                                    message.blockId = String(object.blockId);
                                if (object.text != null)
                                    message.text = String(object.text);
                                if (object.marks != null) {
                                    if (typeof object.marks !== "object")
                                        throw TypeError(".anytype.Rpc.Block.Set.Text.Text.Request.marks: object expected");
                                    message.marks = $root.anytype.model.Block.Content.Text.Marks.fromObject(object.marks);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Text.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.contextId = "";
                                    object.blockId = "";
                                    object.text = "";
                                    object.marks = null;
                                }
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    object.contextId = message.contextId;
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    object.blockId = message.blockId;
                                if (message.text != null && message.hasOwnProperty("text"))
                                    object.text = message.text;
                                if (message.marks != null && message.hasOwnProperty("marks"))
                                    object.marks = $root.anytype.model.Block.Content.Text.Marks.toObject(message.marks, options);
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        Text.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Block.Set.Text.Text
                             * @interface IResponse
                             * @property {anytype.Rpc.Block.Set.Text.Text.Response.IError|null} [error] Response error
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Block.Set.Text.Text
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Text.Text.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Block.Set.Text.Text.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Text.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Text.Text.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Text.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Text.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Block.Set.Text.Text.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Text.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Text.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Text.Text.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Text.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Block.Set.Text.Text.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Text.Text.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Block.Set.Text.Text.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Text.Text.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Text.Text.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Text.Text.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Block.Set.Text.Text.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Block.Set.Text.Text.Response.Error.fromObject(object.error);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Text.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.error = null;
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Block.Set.Text.Text.Response.Error.toObject(message.error, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Text.Text.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Block.Set.Text.Text.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Block.Set.Text.Text.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Block.Set.Text.Text.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Text.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Block.Set.Text.Text.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Text.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Text.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Text.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Text.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Block.Set.Text.Text.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Text.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Block.Set.Text.Text.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Block.Set.Text.Text.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Block.Set.Text.Text.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Block.Set.Text.Text.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Text.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.Text.Text.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Block.Set.Text.Text.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Block.Set.Text.Text.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return Text;
                    })();

                    Text.Color = (function() {

                        /**
                         * Properties of a Color.
                         * @memberof anytype.Rpc.Block.Set.Text
                         * @interface IColor
                         */

                        /**
                         * Constructs a new Color.
                         * @memberof anytype.Rpc.Block.Set.Text
                         * @classdesc Represents a Color.
                         * @implements IColor
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Text.IColor=} [properties] Properties to set
                         */
                        function Color(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Color instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Text.Color
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IColor=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Text.Color} Color instance
                         */
                        Color.create = function create(properties) {
                            return new Color(properties);
                        };

                        /**
                         * Encodes the specified Color message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Color.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Text.Color
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IColor} message Color message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Color.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Color message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Color.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Text.Color
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IColor} message Color message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Color.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Color message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Text.Color
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Text.Color} Color
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Color.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Color();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Color message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Text.Color
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Text.Color} Color
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Color.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Color message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Text.Color
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Color.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Color message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Text.Color
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Text.Color} Color
                         */
                        Color.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Text.Color)
                                return object;
                            return new $root.anytype.Rpc.Block.Set.Text.Color();
                        };

                        /**
                         * Creates a plain object from a Color message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Text.Color
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.Color} message Color
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Color.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Color to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Text.Color
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Color.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Color.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Block.Set.Text.Color
                             * @interface IRequest
                             * @property {string|null} [contextId] Request contextId
                             * @property {string|null} [blockId] Request blockId
                             * @property {string|null} [color] Request color
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Block.Set.Text.Color
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Text.Color.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request contextId.
                             * @member {string} contextId
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Request
                             * @instance
                             */
                            Request.prototype.contextId = "";

                            /**
                             * Request blockId.
                             * @member {string} blockId
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Request
                             * @instance
                             */
                            Request.prototype.blockId = "";

                            /**
                             * Request color.
                             * @member {string} color
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Request
                             * @instance
                             */
                            Request.prototype.color = "";

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Color.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Text.Color.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Color.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Color.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                                if (message.color != null && message.hasOwnProperty("color"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.color);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Color.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Color.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Text.Color.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Color.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.contextId = reader.string();
                                        break;
                                    case 2:
                                        message.blockId = reader.string();
                                        break;
                                    case 3:
                                        message.color = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Text.Color.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    if (!$util.isString(message.contextId))
                                        return "contextId: string expected";
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    if (!$util.isString(message.blockId))
                                        return "blockId: string expected";
                                if (message.color != null && message.hasOwnProperty("color"))
                                    if (!$util.isString(message.color))
                                        return "color: string expected";
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Text.Color.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Text.Color.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Text.Color.Request();
                                if (object.contextId != null)
                                    message.contextId = String(object.contextId);
                                if (object.blockId != null)
                                    message.blockId = String(object.blockId);
                                if (object.color != null)
                                    message.color = String(object.color);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Color.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.contextId = "";
                                    object.blockId = "";
                                    object.color = "";
                                }
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    object.contextId = message.contextId;
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    object.blockId = message.blockId;
                                if (message.color != null && message.hasOwnProperty("color"))
                                    object.color = message.color;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        Color.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Block.Set.Text.Color
                             * @interface IResponse
                             * @property {anytype.Rpc.Block.Set.Text.Color.Response.IError|null} [error] Response error
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Block.Set.Text.Color
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Text.Color.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Block.Set.Text.Color.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Color.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Text.Color.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Color.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Color.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Block.Set.Text.Color.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Color.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Color.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Text.Color.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Color.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Block.Set.Text.Color.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Text.Color.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Block.Set.Text.Color.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Text.Color.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Text.Color.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Text.Color.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Block.Set.Text.Color.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Block.Set.Text.Color.Response.Error.fromObject(object.error);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Color.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.error = null;
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Block.Set.Text.Color.Response.Error.toObject(message.error, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Text.Color.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Block.Set.Text.Color.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Block.Set.Text.Color.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Block.Set.Text.Color.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Color.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Block.Set.Text.Color.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Color.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Color.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Color.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Color.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Block.Set.Text.Color.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Color.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Block.Set.Text.Color.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Block.Set.Text.Color.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Block.Set.Text.Color.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Block.Set.Text.Color.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Color.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.Text.Color.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Block.Set.Text.Color.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Block.Set.Text.Color.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return Color;
                    })();

                    Text.BackgroundColor = (function() {

                        /**
                         * Properties of a BackgroundColor.
                         * @memberof anytype.Rpc.Block.Set.Text
                         * @interface IBackgroundColor
                         */

                        /**
                         * Constructs a new BackgroundColor.
                         * @memberof anytype.Rpc.Block.Set.Text
                         * @classdesc Represents a BackgroundColor.
                         * @implements IBackgroundColor
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Text.IBackgroundColor=} [properties] Properties to set
                         */
                        function BackgroundColor(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new BackgroundColor instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IBackgroundColor=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor} BackgroundColor instance
                         */
                        BackgroundColor.create = function create(properties) {
                            return new BackgroundColor(properties);
                        };

                        /**
                         * Encodes the specified BackgroundColor message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.BackgroundColor.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IBackgroundColor} message BackgroundColor message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BackgroundColor.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified BackgroundColor message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.BackgroundColor.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IBackgroundColor} message BackgroundColor message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BackgroundColor.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a BackgroundColor message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor} BackgroundColor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BackgroundColor.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.BackgroundColor();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a BackgroundColor message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor} BackgroundColor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BackgroundColor.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a BackgroundColor message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        BackgroundColor.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a BackgroundColor message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor} BackgroundColor
                         */
                        BackgroundColor.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Text.BackgroundColor)
                                return object;
                            return new $root.anytype.Rpc.Block.Set.Text.BackgroundColor();
                        };

                        /**
                         * Creates a plain object from a BackgroundColor message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.BackgroundColor} message BackgroundColor
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        BackgroundColor.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this BackgroundColor to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        BackgroundColor.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        BackgroundColor.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                             * @interface IRequest
                             * @property {string|null} [contextId] Request contextId
                             * @property {string|null} [blockId] Request blockId
                             * @property {string|null} [color] Request color
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request contextId.
                             * @member {string} contextId
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Request
                             * @instance
                             */
                            Request.prototype.contextId = "";

                            /**
                             * Request blockId.
                             * @member {string} blockId
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Request
                             * @instance
                             */
                            Request.prototype.blockId = "";

                            /**
                             * Request color.
                             * @member {string} color
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Request
                             * @instance
                             */
                            Request.prototype.color = "";

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.BackgroundColor.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                                if (message.color != null && message.hasOwnProperty("color"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.color);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.BackgroundColor.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.contextId = reader.string();
                                        break;
                                    case 2:
                                        message.blockId = reader.string();
                                        break;
                                    case 3:
                                        message.color = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    if (!$util.isString(message.contextId))
                                        return "contextId: string expected";
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    if (!$util.isString(message.blockId))
                                        return "blockId: string expected";
                                if (message.color != null && message.hasOwnProperty("color"))
                                    if (!$util.isString(message.color))
                                        return "color: string expected";
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Request();
                                if (object.contextId != null)
                                    message.contextId = String(object.contextId);
                                if (object.blockId != null)
                                    message.blockId = String(object.blockId);
                                if (object.color != null)
                                    message.color = String(object.color);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.contextId = "";
                                    object.blockId = "";
                                    object.color = "";
                                }
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    object.contextId = message.contextId;
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    object.blockId = message.blockId;
                                if (message.color != null && message.hasOwnProperty("color"))
                                    object.color = message.color;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        BackgroundColor.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                             * @interface IResponse
                             * @property {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.IError|null} [error] Response error
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.BackgroundColor.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.BackgroundColor.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Block.Set.Text.BackgroundColor.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error.fromObject(object.error);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.error = null;
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error.toObject(message.error, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Block.Set.Text.BackgroundColor.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return BackgroundColor;
                    })();

                    Text.Style = (function() {

                        /**
                         * Properties of a Style.
                         * @memberof anytype.Rpc.Block.Set.Text
                         * @interface IStyle
                         */

                        /**
                         * Constructs a new Style.
                         * @memberof anytype.Rpc.Block.Set.Text
                         * @classdesc Represents a Style.
                         * @implements IStyle
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Text.IStyle=} [properties] Properties to set
                         */
                        function Style(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Style instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Text.Style
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IStyle=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Text.Style} Style instance
                         */
                        Style.create = function create(properties) {
                            return new Style(properties);
                        };

                        /**
                         * Encodes the specified Style message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Style.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Text.Style
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IStyle} message Style message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Style.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Style message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Style.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Text.Style
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IStyle} message Style message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Style.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Style message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Text.Style
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Text.Style} Style
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Style.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Style();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Style message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Text.Style
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Text.Style} Style
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Style.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Style message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Text.Style
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Style.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Style message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Text.Style
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Text.Style} Style
                         */
                        Style.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Text.Style)
                                return object;
                            return new $root.anytype.Rpc.Block.Set.Text.Style();
                        };

                        /**
                         * Creates a plain object from a Style message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Text.Style
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.Style} message Style
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Style.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Style to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Text.Style
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Style.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Style.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Block.Set.Text.Style
                             * @interface IRequest
                             * @property {string|null} [contextId] Request contextId
                             * @property {string|null} [blockId] Request blockId
                             * @property {anytype.model.Block.Content.Text.Style|null} [style] Request style
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Block.Set.Text.Style
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Text.Style.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request contextId.
                             * @member {string} contextId
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Request
                             * @instance
                             */
                            Request.prototype.contextId = "";

                            /**
                             * Request blockId.
                             * @member {string} blockId
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Request
                             * @instance
                             */
                            Request.prototype.blockId = "";

                            /**
                             * Request style.
                             * @member {anytype.model.Block.Content.Text.Style} style
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Request
                             * @instance
                             */
                            Request.prototype.style = 0;

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Style.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Text.Style.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Style.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Style.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                                if (message.style != null && message.hasOwnProperty("style"))
                                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.style);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Style.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Style.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Text.Style.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Style.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.contextId = reader.string();
                                        break;
                                    case 2:
                                        message.blockId = reader.string();
                                        break;
                                    case 3:
                                        message.style = reader.int32();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Text.Style.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    if (!$util.isString(message.contextId))
                                        return "contextId: string expected";
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    if (!$util.isString(message.blockId))
                                        return "blockId: string expected";
                                if (message.style != null && message.hasOwnProperty("style"))
                                    switch (message.style) {
                                    default:
                                        return "style: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                    case 4:
                                    case 5:
                                    case 6:
                                    case 7:
                                    case 8:
                                    case 9:
                                    case 10:
                                    case 11:
                                        break;
                                    }
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Text.Style.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Text.Style.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Text.Style.Request();
                                if (object.contextId != null)
                                    message.contextId = String(object.contextId);
                                if (object.blockId != null)
                                    message.blockId = String(object.blockId);
                                switch (object.style) {
                                case "Paragraph":
                                case 0:
                                    message.style = 0;
                                    break;
                                case "Header1":
                                case 1:
                                    message.style = 1;
                                    break;
                                case "Header2":
                                case 2:
                                    message.style = 2;
                                    break;
                                case "Header3":
                                case 3:
                                    message.style = 3;
                                    break;
                                case "Header4":
                                case 4:
                                    message.style = 4;
                                    break;
                                case "Quote":
                                case 5:
                                    message.style = 5;
                                    break;
                                case "Code":
                                case 6:
                                    message.style = 6;
                                    break;
                                case "Title":
                                case 7:
                                    message.style = 7;
                                    break;
                                case "Checkbox":
                                case 8:
                                    message.style = 8;
                                    break;
                                case "Marked":
                                case 9:
                                    message.style = 9;
                                    break;
                                case "Numbered":
                                case 10:
                                    message.style = 10;
                                    break;
                                case "Toggle":
                                case 11:
                                    message.style = 11;
                                    break;
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Style.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.contextId = "";
                                    object.blockId = "";
                                    object.style = options.enums === String ? "Paragraph" : 0;
                                }
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    object.contextId = message.contextId;
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    object.blockId = message.blockId;
                                if (message.style != null && message.hasOwnProperty("style"))
                                    object.style = options.enums === String ? $root.anytype.model.Block.Content.Text.Style[message.style] : message.style;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        Style.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Block.Set.Text.Style
                             * @interface IResponse
                             * @property {anytype.Rpc.Block.Set.Text.Style.Response.IError|null} [error] Response error
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Block.Set.Text.Style
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Text.Style.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Block.Set.Text.Style.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Style.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Text.Style.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Style.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Style.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Block.Set.Text.Style.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Style.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Style.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Text.Style.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Style.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Block.Set.Text.Style.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Text.Style.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Block.Set.Text.Style.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Text.Style.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Text.Style.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Text.Style.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Block.Set.Text.Style.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Block.Set.Text.Style.Response.Error.fromObject(object.error);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Style.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.error = null;
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Block.Set.Text.Style.Response.Error.toObject(message.error, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Text.Style.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Block.Set.Text.Style.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Block.Set.Text.Style.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Block.Set.Text.Style.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Style.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Block.Set.Text.Style.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Style.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Style.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Style.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Style.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Block.Set.Text.Style.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Style.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Block.Set.Text.Style.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Block.Set.Text.Style.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Block.Set.Text.Style.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Block.Set.Text.Style.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Style.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.Text.Style.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Block.Set.Text.Style.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Block.Set.Text.Style.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return Style;
                    })();

                    Text.Checked = (function() {

                        /**
                         * Properties of a Checked.
                         * @memberof anytype.Rpc.Block.Set.Text
                         * @interface IChecked
                         */

                        /**
                         * Constructs a new Checked.
                         * @memberof anytype.Rpc.Block.Set.Text
                         * @classdesc Represents a Checked.
                         * @implements IChecked
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Text.IChecked=} [properties] Properties to set
                         */
                        function Checked(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Checked instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Text.Checked
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IChecked=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Text.Checked} Checked instance
                         */
                        Checked.create = function create(properties) {
                            return new Checked(properties);
                        };

                        /**
                         * Encodes the specified Checked message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Checked.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Text.Checked
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IChecked} message Checked message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Checked.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Checked message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Checked.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Text.Checked
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.IChecked} message Checked message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Checked.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Checked message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Text.Checked
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Text.Checked} Checked
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Checked.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Checked();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Checked message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Text.Checked
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Text.Checked} Checked
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Checked.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Checked message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Text.Checked
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Checked.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Checked message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Text.Checked
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Text.Checked} Checked
                         */
                        Checked.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Text.Checked)
                                return object;
                            return new $root.anytype.Rpc.Block.Set.Text.Checked();
                        };

                        /**
                         * Creates a plain object from a Checked message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Text.Checked
                         * @static
                         * @param {anytype.Rpc.Block.Set.Text.Checked} message Checked
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Checked.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Checked to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Text.Checked
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Checked.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Checked.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Block.Set.Text.Checked
                             * @interface IRequest
                             * @property {string|null} [contextId] Request contextId
                             * @property {string|null} [blockId] Request blockId
                             * @property {boolean|null} [checked] Request checked
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Block.Set.Text.Checked
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Text.Checked.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request contextId.
                             * @member {string} contextId
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Request
                             * @instance
                             */
                            Request.prototype.contextId = "";

                            /**
                             * Request blockId.
                             * @member {string} blockId
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Request
                             * @instance
                             */
                            Request.prototype.blockId = "";

                            /**
                             * Request checked.
                             * @member {boolean} checked
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Request
                             * @instance
                             */
                            Request.prototype.checked = false;

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Checked.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Text.Checked.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Checked.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Checked.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                                if (message.checked != null && message.hasOwnProperty("checked"))
                                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.checked);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Checked.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Checked.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Text.Checked.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Checked.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.contextId = reader.string();
                                        break;
                                    case 2:
                                        message.blockId = reader.string();
                                        break;
                                    case 3:
                                        message.checked = reader.bool();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Text.Checked.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    if (!$util.isString(message.contextId))
                                        return "contextId: string expected";
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    if (!$util.isString(message.blockId))
                                        return "blockId: string expected";
                                if (message.checked != null && message.hasOwnProperty("checked"))
                                    if (typeof message.checked !== "boolean")
                                        return "checked: boolean expected";
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Text.Checked.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Text.Checked.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Text.Checked.Request();
                                if (object.contextId != null)
                                    message.contextId = String(object.contextId);
                                if (object.blockId != null)
                                    message.blockId = String(object.blockId);
                                if (object.checked != null)
                                    message.checked = Boolean(object.checked);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Checked.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.contextId = "";
                                    object.blockId = "";
                                    object.checked = false;
                                }
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    object.contextId = message.contextId;
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    object.blockId = message.blockId;
                                if (message.checked != null && message.hasOwnProperty("checked"))
                                    object.checked = message.checked;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        Checked.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Block.Set.Text.Checked
                             * @interface IResponse
                             * @property {anytype.Rpc.Block.Set.Text.Checked.Response.IError|null} [error] Response error
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Block.Set.Text.Checked
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Text.Checked.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Block.Set.Text.Checked.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Checked.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Text.Checked.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Checked.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Checked.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Block.Set.Text.Checked.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Checked.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Checked.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Text.Checked.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Checked.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Block.Set.Text.Checked.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Text.Checked.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Block.Set.Text.Checked.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Text.Checked.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Text.Checked.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Text.Checked.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Block.Set.Text.Checked.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Block.Set.Text.Checked.Response.Error.fromObject(object.error);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Text.Checked.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.error = null;
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Block.Set.Text.Checked.Response.Error.toObject(message.error, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Text.Checked.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Block.Set.Text.Checked.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Block.Set.Text.Checked.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Block.Set.Text.Checked.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Checked.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Block.Set.Text.Checked.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Checked.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Checked.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Text.Checked.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Checked.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Block.Set.Text.Checked.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Text.Checked.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Block.Set.Text.Checked.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Block.Set.Text.Checked.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Block.Set.Text.Checked.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Block.Set.Text.Checked.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Text.Checked.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.Text.Checked.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Block.Set.Text.Checked.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Block.Set.Text.Checked.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return Checked;
                    })();

                    return Text;
                })();

                Set.File = (function() {

                    /**
                     * Properties of a File.
                     * @memberof anytype.Rpc.Block.Set
                     * @interface IFile
                     */

                    /**
                     * Constructs a new File.
                     * @memberof anytype.Rpc.Block.Set
                     * @classdesc Represents a File.
                     * @implements IFile
                     * @constructor
                     * @param {anytype.Rpc.Block.Set.IFile=} [properties] Properties to set
                     */
                    function File(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new File instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Set.File
                     * @static
                     * @param {anytype.Rpc.Block.Set.IFile=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Set.File} File instance
                     */
                    File.create = function create(properties) {
                        return new File(properties);
                    };

                    /**
                     * Encodes the specified File message. Does not implicitly {@link anytype.Rpc.Block.Set.File.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Set.File
                     * @static
                     * @param {anytype.Rpc.Block.Set.IFile} message File message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    File.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified File message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.File.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Set.File
                     * @static
                     * @param {anytype.Rpc.Block.Set.IFile} message File message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    File.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a File message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Set.File
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Set.File} File
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    File.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.File();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a File message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Set.File
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Set.File} File
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    File.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a File message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Set.File
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    File.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a File message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Set.File
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Set.File} File
                     */
                    File.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Set.File)
                            return object;
                        return new $root.anytype.Rpc.Block.Set.File();
                    };

                    /**
                     * Creates a plain object from a File message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Set.File
                     * @static
                     * @param {anytype.Rpc.Block.Set.File} message File
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    File.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this File to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Set.File
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    File.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    File.Name = (function() {

                        /**
                         * Properties of a Name.
                         * @memberof anytype.Rpc.Block.Set.File
                         * @interface IName
                         */

                        /**
                         * Constructs a new Name.
                         * @memberof anytype.Rpc.Block.Set.File
                         * @classdesc Represents a Name.
                         * @implements IName
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.File.IName=} [properties] Properties to set
                         */
                        function Name(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Name instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.File.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.File.IName=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.File.Name} Name instance
                         */
                        Name.create = function create(properties) {
                            return new Name(properties);
                        };

                        /**
                         * Encodes the specified Name message. Does not implicitly {@link anytype.Rpc.Block.Set.File.Name.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.File.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.File.IName} message Name message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Name.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Name message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.File.Name.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.File.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.File.IName} message Name message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Name.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Name message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.File.Name
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.File.Name} Name
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Name.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.File.Name();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Name message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.File.Name
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.File.Name} Name
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Name.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Name message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.File.Name
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Name.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Name message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.File.Name
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.File.Name} Name
                         */
                        Name.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.File.Name)
                                return object;
                            return new $root.anytype.Rpc.Block.Set.File.Name();
                        };

                        /**
                         * Creates a plain object from a Name message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.File.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.File.Name} message Name
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Name.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Name to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.File.Name
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Name.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Name.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Block.Set.File.Name
                             * @interface IRequest
                             * @property {string|null} [contextId] Request contextId
                             * @property {string|null} [blockId] Request blockId
                             * @property {string|null} [name] Request name
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Block.Set.File.Name
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.File.Name.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request contextId.
                             * @member {string} contextId
                             * @memberof anytype.Rpc.Block.Set.File.Name.Request
                             * @instance
                             */
                            Request.prototype.contextId = "";

                            /**
                             * Request blockId.
                             * @member {string} blockId
                             * @memberof anytype.Rpc.Block.Set.File.Name.Request
                             * @instance
                             */
                            Request.prototype.blockId = "";

                            /**
                             * Request name.
                             * @member {string} name
                             * @memberof anytype.Rpc.Block.Set.File.Name.Request
                             * @instance
                             */
                            Request.prototype.name = "";

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.File.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.File.Name.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.File.Name.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.File.Name.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.File.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.File.Name.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                                if (message.name != null && message.hasOwnProperty("name"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.File.Name.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.File.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.File.Name.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.File.Name.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.File.Name.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.File.Name.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.contextId = reader.string();
                                        break;
                                    case 2:
                                        message.blockId = reader.string();
                                        break;
                                    case 3:
                                        message.name = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.File.Name.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.File.Name.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.File.Name.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    if (!$util.isString(message.contextId))
                                        return "contextId: string expected";
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    if (!$util.isString(message.blockId))
                                        return "blockId: string expected";
                                if (message.name != null && message.hasOwnProperty("name"))
                                    if (!$util.isString(message.name))
                                        return "name: string expected";
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.File.Name.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.File.Name.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.File.Name.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.File.Name.Request();
                                if (object.contextId != null)
                                    message.contextId = String(object.contextId);
                                if (object.blockId != null)
                                    message.blockId = String(object.blockId);
                                if (object.name != null)
                                    message.name = String(object.name);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.File.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.File.Name.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.contextId = "";
                                    object.blockId = "";
                                    object.name = "";
                                }
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    object.contextId = message.contextId;
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    object.blockId = message.blockId;
                                if (message.name != null && message.hasOwnProperty("name"))
                                    object.name = message.name;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.File.Name.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        Name.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Block.Set.File.Name
                             * @interface IResponse
                             * @property {anytype.Rpc.Block.Set.File.Name.Response.IError|null} [error] Response error
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Block.Set.File.Name
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.File.Name.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Block.Set.File.Name.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Block.Set.File.Name.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.File.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.File.Name.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.File.Name.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.File.Name.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.File.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.File.Name.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Block.Set.File.Name.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.File.Name.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.File.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.File.Name.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.File.Name.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.File.Name.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.File.Name.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Block.Set.File.Name.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.File.Name.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.File.Name.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.File.Name.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Block.Set.File.Name.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.File.Name.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.File.Name.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.File.Name.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.File.Name.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Block.Set.File.Name.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Block.Set.File.Name.Response.Error.fromObject(object.error);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.File.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.File.Name.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.error = null;
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Block.Set.File.Name.Response.Error.toObject(message.error, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.File.Name.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Block.Set.File.Name.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Block.Set.File.Name.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Block.Set.File.Name.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.File.Name.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Block.Set.File.Name.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.File.Name.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.File.Name.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.File.Name.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.File.Name.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Block.Set.File.Name.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.File.Name.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Block.Set.File.Name.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Block.Set.File.Name.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Block.Set.File.Name.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Block.Set.File.Name.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.File.Name.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.File.Name.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Block.Set.File.Name.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Block.Set.File.Name.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return Name;
                    })();

                    return File;
                })();

                Set.Image = (function() {

                    /**
                     * Properties of an Image.
                     * @memberof anytype.Rpc.Block.Set
                     * @interface IImage
                     */

                    /**
                     * Constructs a new Image.
                     * @memberof anytype.Rpc.Block.Set
                     * @classdesc Represents an Image.
                     * @implements IImage
                     * @constructor
                     * @param {anytype.Rpc.Block.Set.IImage=} [properties] Properties to set
                     */
                    function Image(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Image instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Set.Image
                     * @static
                     * @param {anytype.Rpc.Block.Set.IImage=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Set.Image} Image instance
                     */
                    Image.create = function create(properties) {
                        return new Image(properties);
                    };

                    /**
                     * Encodes the specified Image message. Does not implicitly {@link anytype.Rpc.Block.Set.Image.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Set.Image
                     * @static
                     * @param {anytype.Rpc.Block.Set.IImage} message Image message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Image.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Image message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Image.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Set.Image
                     * @static
                     * @param {anytype.Rpc.Block.Set.IImage} message Image message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Image.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Image message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Set.Image
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Set.Image} Image
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Image.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Image();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Image message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Set.Image
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Set.Image} Image
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Image.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Image message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Set.Image
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Image.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates an Image message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Set.Image
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Set.Image} Image
                     */
                    Image.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Set.Image)
                            return object;
                        return new $root.anytype.Rpc.Block.Set.Image();
                    };

                    /**
                     * Creates a plain object from an Image message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Set.Image
                     * @static
                     * @param {anytype.Rpc.Block.Set.Image} message Image
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Image.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Image to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Set.Image
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Image.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Image.Name = (function() {

                        /**
                         * Properties of a Name.
                         * @memberof anytype.Rpc.Block.Set.Image
                         * @interface IName
                         */

                        /**
                         * Constructs a new Name.
                         * @memberof anytype.Rpc.Block.Set.Image
                         * @classdesc Represents a Name.
                         * @implements IName
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Image.IName=} [properties] Properties to set
                         */
                        function Name(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Name instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Image.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.Image.IName=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Image.Name} Name instance
                         */
                        Name.create = function create(properties) {
                            return new Name(properties);
                        };

                        /**
                         * Encodes the specified Name message. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Name.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Image.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.Image.IName} message Name message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Name.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Name message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Name.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Image.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.Image.IName} message Name message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Name.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Name message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Image.Name
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Image.Name} Name
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Name.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Image.Name();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Name message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Image.Name
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Image.Name} Name
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Name.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Name message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Image.Name
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Name.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Name message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Image.Name
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Image.Name} Name
                         */
                        Name.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Image.Name)
                                return object;
                            return new $root.anytype.Rpc.Block.Set.Image.Name();
                        };

                        /**
                         * Creates a plain object from a Name message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Image.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.Image.Name} message Name
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Name.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Name to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Image.Name
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Name.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Name.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Block.Set.Image.Name
                             * @interface IRequest
                             * @property {string|null} [contextId] Request contextId
                             * @property {string|null} [blockId] Request blockId
                             * @property {string|null} [name] Request name
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Block.Set.Image.Name
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Image.Name.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request contextId.
                             * @member {string} contextId
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Request
                             * @instance
                             */
                            Request.prototype.contextId = "";

                            /**
                             * Request blockId.
                             * @member {string} blockId
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Request
                             * @instance
                             */
                            Request.prototype.blockId = "";

                            /**
                             * Request name.
                             * @member {string} name
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Request
                             * @instance
                             */
                            Request.prototype.name = "";

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Name.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Image.Name.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Name.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Name.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                                if (message.name != null && message.hasOwnProperty("name"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Name.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Name.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Image.Name.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Image.Name.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.contextId = reader.string();
                                        break;
                                    case 2:
                                        message.blockId = reader.string();
                                        break;
                                    case 3:
                                        message.name = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Image.Name.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    if (!$util.isString(message.contextId))
                                        return "contextId: string expected";
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    if (!$util.isString(message.blockId))
                                        return "blockId: string expected";
                                if (message.name != null && message.hasOwnProperty("name"))
                                    if (!$util.isString(message.name))
                                        return "name: string expected";
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Image.Name.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Image.Name.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Image.Name.Request();
                                if (object.contextId != null)
                                    message.contextId = String(object.contextId);
                                if (object.blockId != null)
                                    message.blockId = String(object.blockId);
                                if (object.name != null)
                                    message.name = String(object.name);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Name.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.contextId = "";
                                    object.blockId = "";
                                    object.name = "";
                                }
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    object.contextId = message.contextId;
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    object.blockId = message.blockId;
                                if (message.name != null && message.hasOwnProperty("name"))
                                    object.name = message.name;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        Name.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Block.Set.Image.Name
                             * @interface IResponse
                             * @property {anytype.Rpc.Block.Set.Image.Name.Response.IError|null} [error] Response error
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Block.Set.Image.Name
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Image.Name.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Block.Set.Image.Name.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Name.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Image.Name.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Name.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Name.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Block.Set.Image.Name.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Name.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Name.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Image.Name.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Image.Name.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Block.Set.Image.Name.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Image.Name.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Block.Set.Image.Name.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Image.Name.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Image.Name.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Image.Name.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Block.Set.Image.Name.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Block.Set.Image.Name.Response.Error.fromObject(object.error);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Name.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.error = null;
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Block.Set.Image.Name.Response.Error.toObject(message.error, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Image.Name.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Block.Set.Image.Name.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Block.Set.Image.Name.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Block.Set.Image.Name.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Image.Name.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Block.Set.Image.Name.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Name.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Image.Name.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Name.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Image.Name.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Block.Set.Image.Name.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Image.Name.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Block.Set.Image.Name.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Block.Set.Image.Name.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Block.Set.Image.Name.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Block.Set.Image.Name.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Image.Name.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.Image.Name.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Block.Set.Image.Name.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Block.Set.Image.Name.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return Name;
                    })();

                    Image.Width = (function() {

                        /**
                         * Properties of a Width.
                         * @memberof anytype.Rpc.Block.Set.Image
                         * @interface IWidth
                         */

                        /**
                         * Constructs a new Width.
                         * @memberof anytype.Rpc.Block.Set.Image
                         * @classdesc Represents a Width.
                         * @implements IWidth
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Image.IWidth=} [properties] Properties to set
                         */
                        function Width(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Width instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Image.Width
                         * @static
                         * @param {anytype.Rpc.Block.Set.Image.IWidth=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Image.Width} Width instance
                         */
                        Width.create = function create(properties) {
                            return new Width(properties);
                        };

                        /**
                         * Encodes the specified Width message. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Width.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Image.Width
                         * @static
                         * @param {anytype.Rpc.Block.Set.Image.IWidth} message Width message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Width.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Width message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Width.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Image.Width
                         * @static
                         * @param {anytype.Rpc.Block.Set.Image.IWidth} message Width message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Width.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Width message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Image.Width
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Image.Width} Width
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Width.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Image.Width();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Width message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Image.Width
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Image.Width} Width
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Width.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Width message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Image.Width
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Width.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Width message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Image.Width
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Image.Width} Width
                         */
                        Width.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Image.Width)
                                return object;
                            return new $root.anytype.Rpc.Block.Set.Image.Width();
                        };

                        /**
                         * Creates a plain object from a Width message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Image.Width
                         * @static
                         * @param {anytype.Rpc.Block.Set.Image.Width} message Width
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Width.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Width to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Image.Width
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Width.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Width.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Block.Set.Image.Width
                             * @interface IRequest
                             * @property {string|null} [contextId] Request contextId
                             * @property {string|null} [blockId] Request blockId
                             * @property {number|null} [width] Request width
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Block.Set.Image.Width
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Image.Width.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request contextId.
                             * @member {string} contextId
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Request
                             * @instance
                             */
                            Request.prototype.contextId = "";

                            /**
                             * Request blockId.
                             * @member {string} blockId
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Request
                             * @instance
                             */
                            Request.prototype.blockId = "";

                            /**
                             * Request width.
                             * @member {number} width
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Request
                             * @instance
                             */
                            Request.prototype.width = 0;

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Width.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Image.Width.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Width.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Width.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                                if (message.width != null && message.hasOwnProperty("width"))
                                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.width);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Width.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Width.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Image.Width.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Image.Width.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.contextId = reader.string();
                                        break;
                                    case 2:
                                        message.blockId = reader.string();
                                        break;
                                    case 3:
                                        message.width = reader.int32();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Image.Width.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    if (!$util.isString(message.contextId))
                                        return "contextId: string expected";
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    if (!$util.isString(message.blockId))
                                        return "blockId: string expected";
                                if (message.width != null && message.hasOwnProperty("width"))
                                    if (!$util.isInteger(message.width))
                                        return "width: integer expected";
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Image.Width.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Image.Width.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Image.Width.Request();
                                if (object.contextId != null)
                                    message.contextId = String(object.contextId);
                                if (object.blockId != null)
                                    message.blockId = String(object.blockId);
                                if (object.width != null)
                                    message.width = object.width | 0;
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Width.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.contextId = "";
                                    object.blockId = "";
                                    object.width = 0;
                                }
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    object.contextId = message.contextId;
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    object.blockId = message.blockId;
                                if (message.width != null && message.hasOwnProperty("width"))
                                    object.width = message.width;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        Width.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Block.Set.Image.Width
                             * @interface IResponse
                             * @property {anytype.Rpc.Block.Set.Image.Width.Response.IError|null} [error] Response error
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Block.Set.Image.Width
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Image.Width.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Block.Set.Image.Width.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Width.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Image.Width.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Width.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Width.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Block.Set.Image.Width.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Width.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Width.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Image.Width.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Image.Width.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Block.Set.Image.Width.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Image.Width.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Block.Set.Image.Width.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Image.Width.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Image.Width.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Image.Width.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Block.Set.Image.Width.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Block.Set.Image.Width.Response.Error.fromObject(object.error);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Image.Width.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.error = null;
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Block.Set.Image.Width.Response.Error.toObject(message.error, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Image.Width.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Block.Set.Image.Width.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Block.Set.Image.Width.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Block.Set.Image.Width.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Image.Width.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Block.Set.Image.Width.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Width.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Image.Width.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Image.Width.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Image.Width.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Block.Set.Image.Width.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Image.Width.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Block.Set.Image.Width.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Block.Set.Image.Width.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Block.Set.Image.Width.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Block.Set.Image.Width.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Image.Width.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.Image.Width.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Block.Set.Image.Width.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Block.Set.Image.Width.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return Width;
                    })();

                    return Image;
                })();

                Set.Video = (function() {

                    /**
                     * Properties of a Video.
                     * @memberof anytype.Rpc.Block.Set
                     * @interface IVideo
                     */

                    /**
                     * Constructs a new Video.
                     * @memberof anytype.Rpc.Block.Set
                     * @classdesc Represents a Video.
                     * @implements IVideo
                     * @constructor
                     * @param {anytype.Rpc.Block.Set.IVideo=} [properties] Properties to set
                     */
                    function Video(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Video instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Set.Video
                     * @static
                     * @param {anytype.Rpc.Block.Set.IVideo=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Set.Video} Video instance
                     */
                    Video.create = function create(properties) {
                        return new Video(properties);
                    };

                    /**
                     * Encodes the specified Video message. Does not implicitly {@link anytype.Rpc.Block.Set.Video.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Set.Video
                     * @static
                     * @param {anytype.Rpc.Block.Set.IVideo} message Video message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Video.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Video message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Video.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Set.Video
                     * @static
                     * @param {anytype.Rpc.Block.Set.IVideo} message Video message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Video.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Video message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Set.Video
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Set.Video} Video
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Video.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Video();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Video message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Set.Video
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Set.Video} Video
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Video.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Video message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Set.Video
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Video.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Video message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Set.Video
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Set.Video} Video
                     */
                    Video.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Set.Video)
                            return object;
                        return new $root.anytype.Rpc.Block.Set.Video();
                    };

                    /**
                     * Creates a plain object from a Video message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Set.Video
                     * @static
                     * @param {anytype.Rpc.Block.Set.Video} message Video
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Video.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Video to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Set.Video
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Video.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Video.Name = (function() {

                        /**
                         * Properties of a Name.
                         * @memberof anytype.Rpc.Block.Set.Video
                         * @interface IName
                         */

                        /**
                         * Constructs a new Name.
                         * @memberof anytype.Rpc.Block.Set.Video
                         * @classdesc Represents a Name.
                         * @implements IName
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Video.IName=} [properties] Properties to set
                         */
                        function Name(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Name instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Video.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.Video.IName=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Video.Name} Name instance
                         */
                        Name.create = function create(properties) {
                            return new Name(properties);
                        };

                        /**
                         * Encodes the specified Name message. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Name.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Video.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.Video.IName} message Name message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Name.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Name message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Name.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Video.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.Video.IName} message Name message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Name.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Name message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Video.Name
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Video.Name} Name
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Name.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Video.Name();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Name message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Video.Name
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Video.Name} Name
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Name.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Name message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Video.Name
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Name.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Name message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Video.Name
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Video.Name} Name
                         */
                        Name.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Video.Name)
                                return object;
                            return new $root.anytype.Rpc.Block.Set.Video.Name();
                        };

                        /**
                         * Creates a plain object from a Name message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Video.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.Video.Name} message Name
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Name.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Name to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Video.Name
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Name.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Name.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Block.Set.Video.Name
                             * @interface IRequest
                             * @property {string|null} [contextId] Request contextId
                             * @property {string|null} [blockId] Request blockId
                             * @property {string|null} [name] Request name
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Block.Set.Video.Name
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Video.Name.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request contextId.
                             * @member {string} contextId
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Request
                             * @instance
                             */
                            Request.prototype.contextId = "";

                            /**
                             * Request blockId.
                             * @member {string} blockId
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Request
                             * @instance
                             */
                            Request.prototype.blockId = "";

                            /**
                             * Request name.
                             * @member {string} name
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Request
                             * @instance
                             */
                            Request.prototype.name = "";

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Name.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Video.Name.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Name.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Name.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                                if (message.name != null && message.hasOwnProperty("name"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Name.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Name.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Video.Name.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Video.Name.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.contextId = reader.string();
                                        break;
                                    case 2:
                                        message.blockId = reader.string();
                                        break;
                                    case 3:
                                        message.name = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Video.Name.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    if (!$util.isString(message.contextId))
                                        return "contextId: string expected";
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    if (!$util.isString(message.blockId))
                                        return "blockId: string expected";
                                if (message.name != null && message.hasOwnProperty("name"))
                                    if (!$util.isString(message.name))
                                        return "name: string expected";
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Video.Name.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Video.Name.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Video.Name.Request();
                                if (object.contextId != null)
                                    message.contextId = String(object.contextId);
                                if (object.blockId != null)
                                    message.blockId = String(object.blockId);
                                if (object.name != null)
                                    message.name = String(object.name);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Name.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.contextId = "";
                                    object.blockId = "";
                                    object.name = "";
                                }
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    object.contextId = message.contextId;
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    object.blockId = message.blockId;
                                if (message.name != null && message.hasOwnProperty("name"))
                                    object.name = message.name;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        Name.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Block.Set.Video.Name
                             * @interface IResponse
                             * @property {anytype.Rpc.Block.Set.Video.Name.Response.IError|null} [error] Response error
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Block.Set.Video.Name
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Video.Name.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Block.Set.Video.Name.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Name.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Video.Name.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Name.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Name.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Block.Set.Video.Name.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Name.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Name.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Video.Name.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Video.Name.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Block.Set.Video.Name.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Video.Name.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Block.Set.Video.Name.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Video.Name.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Video.Name.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Video.Name.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Block.Set.Video.Name.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Block.Set.Video.Name.Response.Error.fromObject(object.error);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Name.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.error = null;
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Block.Set.Video.Name.Response.Error.toObject(message.error, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Video.Name.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Block.Set.Video.Name.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Block.Set.Video.Name.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Block.Set.Video.Name.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Video.Name.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Block.Set.Video.Name.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Name.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Video.Name.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Name.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Video.Name.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Block.Set.Video.Name.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Video.Name.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Block.Set.Video.Name.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Block.Set.Video.Name.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Block.Set.Video.Name.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Block.Set.Video.Name.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Video.Name.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.Video.Name.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Block.Set.Video.Name.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Block.Set.Video.Name.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return Name;
                    })();

                    Video.Width = (function() {

                        /**
                         * Properties of a Width.
                         * @memberof anytype.Rpc.Block.Set.Video
                         * @interface IWidth
                         */

                        /**
                         * Constructs a new Width.
                         * @memberof anytype.Rpc.Block.Set.Video
                         * @classdesc Represents a Width.
                         * @implements IWidth
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Video.IWidth=} [properties] Properties to set
                         */
                        function Width(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Width instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Video.Width
                         * @static
                         * @param {anytype.Rpc.Block.Set.Video.IWidth=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Video.Width} Width instance
                         */
                        Width.create = function create(properties) {
                            return new Width(properties);
                        };

                        /**
                         * Encodes the specified Width message. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Width.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Video.Width
                         * @static
                         * @param {anytype.Rpc.Block.Set.Video.IWidth} message Width message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Width.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Width message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Width.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Video.Width
                         * @static
                         * @param {anytype.Rpc.Block.Set.Video.IWidth} message Width message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Width.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Width message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Video.Width
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Video.Width} Width
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Width.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Video.Width();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Width message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Video.Width
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Video.Width} Width
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Width.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Width message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Video.Width
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Width.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Width message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Video.Width
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Video.Width} Width
                         */
                        Width.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Video.Width)
                                return object;
                            return new $root.anytype.Rpc.Block.Set.Video.Width();
                        };

                        /**
                         * Creates a plain object from a Width message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Video.Width
                         * @static
                         * @param {anytype.Rpc.Block.Set.Video.Width} message Width
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Width.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Width to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Video.Width
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Width.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Width.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Block.Set.Video.Width
                             * @interface IRequest
                             * @property {string|null} [contextId] Request contextId
                             * @property {string|null} [blockId] Request blockId
                             * @property {number|null} [width] Request width
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Block.Set.Video.Width
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Video.Width.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request contextId.
                             * @member {string} contextId
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Request
                             * @instance
                             */
                            Request.prototype.contextId = "";

                            /**
                             * Request blockId.
                             * @member {string} blockId
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Request
                             * @instance
                             */
                            Request.prototype.blockId = "";

                            /**
                             * Request width.
                             * @member {number} width
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Request
                             * @instance
                             */
                            Request.prototype.width = 0;

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Width.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Video.Width.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Width.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Width.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                                if (message.width != null && message.hasOwnProperty("width"))
                                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.width);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Width.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Width.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Video.Width.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Video.Width.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.contextId = reader.string();
                                        break;
                                    case 2:
                                        message.blockId = reader.string();
                                        break;
                                    case 3:
                                        message.width = reader.int32();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Video.Width.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    if (!$util.isString(message.contextId))
                                        return "contextId: string expected";
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    if (!$util.isString(message.blockId))
                                        return "blockId: string expected";
                                if (message.width != null && message.hasOwnProperty("width"))
                                    if (!$util.isInteger(message.width))
                                        return "width: integer expected";
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Video.Width.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Video.Width.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Video.Width.Request();
                                if (object.contextId != null)
                                    message.contextId = String(object.contextId);
                                if (object.blockId != null)
                                    message.blockId = String(object.blockId);
                                if (object.width != null)
                                    message.width = object.width | 0;
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Width.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.contextId = "";
                                    object.blockId = "";
                                    object.width = 0;
                                }
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    object.contextId = message.contextId;
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    object.blockId = message.blockId;
                                if (message.width != null && message.hasOwnProperty("width"))
                                    object.width = message.width;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        Width.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Block.Set.Video.Width
                             * @interface IResponse
                             * @property {anytype.Rpc.Block.Set.Video.Width.Response.IError|null} [error] Response error
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Block.Set.Video.Width
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Video.Width.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Block.Set.Video.Width.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Width.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Video.Width.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Width.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Width.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Block.Set.Video.Width.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Width.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Width.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Video.Width.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Video.Width.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Block.Set.Video.Width.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Video.Width.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Block.Set.Video.Width.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Video.Width.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Video.Width.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Video.Width.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Block.Set.Video.Width.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Block.Set.Video.Width.Response.Error.fromObject(object.error);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Video.Width.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.error = null;
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Block.Set.Video.Width.Response.Error.toObject(message.error, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Video.Width.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Block.Set.Video.Width.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Block.Set.Video.Width.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Block.Set.Video.Width.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Video.Width.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Block.Set.Video.Width.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Width.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Video.Width.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Video.Width.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Video.Width.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Block.Set.Video.Width.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Video.Width.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Block.Set.Video.Width.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Block.Set.Video.Width.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Block.Set.Video.Width.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Block.Set.Video.Width.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Video.Width.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.Video.Width.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Block.Set.Video.Width.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Block.Set.Video.Width.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return Width;
                    })();

                    return Video;
                })();

                Set.Icon = (function() {

                    /**
                     * Properties of an Icon.
                     * @memberof anytype.Rpc.Block.Set
                     * @interface IIcon
                     */

                    /**
                     * Constructs a new Icon.
                     * @memberof anytype.Rpc.Block.Set
                     * @classdesc Represents an Icon.
                     * @implements IIcon
                     * @constructor
                     * @param {anytype.Rpc.Block.Set.IIcon=} [properties] Properties to set
                     */
                    function Icon(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Icon instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Set.Icon
                     * @static
                     * @param {anytype.Rpc.Block.Set.IIcon=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Set.Icon} Icon instance
                     */
                    Icon.create = function create(properties) {
                        return new Icon(properties);
                    };

                    /**
                     * Encodes the specified Icon message. Does not implicitly {@link anytype.Rpc.Block.Set.Icon.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Set.Icon
                     * @static
                     * @param {anytype.Rpc.Block.Set.IIcon} message Icon message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Icon.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Icon message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Icon.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Set.Icon
                     * @static
                     * @param {anytype.Rpc.Block.Set.IIcon} message Icon message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Icon.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Icon message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Set.Icon
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Set.Icon} Icon
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Icon.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Icon();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Icon message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Set.Icon
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Set.Icon} Icon
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Icon.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Icon message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Set.Icon
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Icon.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates an Icon message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Set.Icon
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Set.Icon} Icon
                     */
                    Icon.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Set.Icon)
                            return object;
                        return new $root.anytype.Rpc.Block.Set.Icon();
                    };

                    /**
                     * Creates a plain object from an Icon message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Set.Icon
                     * @static
                     * @param {anytype.Rpc.Block.Set.Icon} message Icon
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Icon.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Icon to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Set.Icon
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Icon.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Icon.Name = (function() {

                        /**
                         * Properties of a Name.
                         * @memberof anytype.Rpc.Block.Set.Icon
                         * @interface IName
                         */

                        /**
                         * Constructs a new Name.
                         * @memberof anytype.Rpc.Block.Set.Icon
                         * @classdesc Represents a Name.
                         * @implements IName
                         * @constructor
                         * @param {anytype.Rpc.Block.Set.Icon.IName=} [properties] Properties to set
                         */
                        function Name(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Name instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Set.Icon.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.Icon.IName=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Set.Icon.Name} Name instance
                         */
                        Name.create = function create(properties) {
                            return new Name(properties);
                        };

                        /**
                         * Encodes the specified Name message. Does not implicitly {@link anytype.Rpc.Block.Set.Icon.Name.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Set.Icon.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.Icon.IName} message Name message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Name.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Name message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Icon.Name.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Icon.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.Icon.IName} message Name message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Name.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Name message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Set.Icon.Name
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Set.Icon.Name} Name
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Name.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Icon.Name();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Name message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Set.Icon.Name
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Set.Icon.Name} Name
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Name.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Name message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Set.Icon.Name
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Name.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Name message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Set.Icon.Name
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Set.Icon.Name} Name
                         */
                        Name.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Set.Icon.Name)
                                return object;
                            return new $root.anytype.Rpc.Block.Set.Icon.Name();
                        };

                        /**
                         * Creates a plain object from a Name message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Set.Icon.Name
                         * @static
                         * @param {anytype.Rpc.Block.Set.Icon.Name} message Name
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Name.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Name to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Set.Icon.Name
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Name.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Name.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Block.Set.Icon.Name
                             * @interface IRequest
                             * @property {string|null} [contextId] Request contextId
                             * @property {string|null} [blockId] Request blockId
                             * @property {string|null} [name] Request name
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Block.Set.Icon.Name
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Icon.Name.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request contextId.
                             * @member {string} contextId
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Request
                             * @instance
                             */
                            Request.prototype.contextId = "";

                            /**
                             * Request blockId.
                             * @member {string} blockId
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Request
                             * @instance
                             */
                            Request.prototype.blockId = "";

                            /**
                             * Request name.
                             * @member {string} name
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Request
                             * @instance
                             */
                            Request.prototype.name = "";

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Icon.Name.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Icon.Name.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Set.Icon.Name.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Icon.Name.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                                if (message.name != null && message.hasOwnProperty("name"))
                                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Icon.Name.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Icon.Name.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Icon.Name.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Icon.Name.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.contextId = reader.string();
                                        break;
                                    case 2:
                                        message.blockId = reader.string();
                                        break;
                                    case 3:
                                        message.name = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Icon.Name.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    if (!$util.isString(message.contextId))
                                        return "contextId: string expected";
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    if (!$util.isString(message.blockId))
                                        return "blockId: string expected";
                                if (message.name != null && message.hasOwnProperty("name"))
                                    if (!$util.isString(message.name))
                                        return "name: string expected";
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Icon.Name.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Icon.Name.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Icon.Name.Request();
                                if (object.contextId != null)
                                    message.contextId = String(object.contextId);
                                if (object.blockId != null)
                                    message.blockId = String(object.blockId);
                                if (object.name != null)
                                    message.name = String(object.name);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Request
                             * @static
                             * @param {anytype.Rpc.Block.Set.Icon.Name.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.contextId = "";
                                    object.blockId = "";
                                    object.name = "";
                                }
                                if (message.contextId != null && message.hasOwnProperty("contextId"))
                                    object.contextId = message.contextId;
                                if (message.blockId != null && message.hasOwnProperty("blockId"))
                                    object.blockId = message.blockId;
                                if (message.name != null && message.hasOwnProperty("name"))
                                    object.name = message.name;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        Name.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Block.Set.Icon.Name
                             * @interface IResponse
                             * @property {anytype.Rpc.Block.Set.Icon.Name.Response.IError|null} [error] Response error
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Block.Set.Icon.Name
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Block.Set.Icon.Name.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Block.Set.Icon.Name.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Icon.Name.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Set.Icon.Name.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Set.Icon.Name.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Icon.Name.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Block.Set.Icon.Name.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Icon.Name.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Icon.Name.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Set.Icon.Name.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Icon.Name.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Block.Set.Icon.Name.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Set.Icon.Name.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Block.Set.Icon.Name.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Set.Icon.Name.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Set.Icon.Name.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Set.Icon.Name.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Block.Set.Icon.Name.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Block.Set.Icon.Name.Response.Error.fromObject(object.error);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Response
                             * @static
                             * @param {anytype.Rpc.Block.Set.Icon.Name.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults)
                                    object.error = null;
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Block.Set.Icon.Name.Response.Error.toObject(message.error, options);
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Set.Icon.Name.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Block.Set.Icon.Name.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Block.Set.Icon.Name.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Block.Set.Icon.Name.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Icon.Name.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Block.Set.Icon.Name.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Set.Icon.Name.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Icon.Name.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Set.Icon.Name.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Icon.Name.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Block.Set.Icon.Name.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Set.Icon.Name.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Block.Set.Icon.Name.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Block.Set.Icon.Name.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Block.Set.Icon.Name.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Block.Set.Icon.Name.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Block.Set.Icon.Name.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Block.Set.Icon.Name.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Block.Set.Icon.Name.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Block.Set.Icon.Name.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return Name;
                    })();

                    return Icon;
                })();

                return Set;
            })();

            Block.Get = (function() {

                /**
                 * Properties of a Get.
                 * @memberof anytype.Rpc.Block
                 * @interface IGet
                 */

                /**
                 * Constructs a new Get.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents a Get.
                 * @implements IGet
                 * @constructor
                 * @param {anytype.Rpc.Block.IGet=} [properties] Properties to set
                 */
                function Get(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Get instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Get
                 * @static
                 * @param {anytype.Rpc.Block.IGet=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Get} Get instance
                 */
                Get.create = function create(properties) {
                    return new Get(properties);
                };

                /**
                 * Encodes the specified Get message. Does not implicitly {@link anytype.Rpc.Block.Get.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Get
                 * @static
                 * @param {anytype.Rpc.Block.IGet} message Get message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Get.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Get message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Get.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Get
                 * @static
                 * @param {anytype.Rpc.Block.IGet} message Get message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Get.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Get message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Get
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Get} Get
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Get.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Get();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Get message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Get
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Get} Get
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Get.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Get message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Get
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Get.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Get message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Get
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Get} Get
                 */
                Get.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Get)
                        return object;
                    return new $root.anytype.Rpc.Block.Get();
                };

                /**
                 * Creates a plain object from a Get message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Get
                 * @static
                 * @param {anytype.Rpc.Block.Get} message Get
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Get.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Get to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Get
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Get.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Get.Marks = (function() {

                    /**
                     * Properties of a Marks.
                     * @memberof anytype.Rpc.Block.Get
                     * @interface IMarks
                     */

                    /**
                     * Constructs a new Marks.
                     * @memberof anytype.Rpc.Block.Get
                     * @classdesc Represents a Marks.
                     * @implements IMarks
                     * @constructor
                     * @param {anytype.Rpc.Block.Get.IMarks=} [properties] Properties to set
                     */
                    function Marks(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Marks instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Get.Marks
                     * @static
                     * @param {anytype.Rpc.Block.Get.IMarks=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Get.Marks} Marks instance
                     */
                    Marks.create = function create(properties) {
                        return new Marks(properties);
                    };

                    /**
                     * Encodes the specified Marks message. Does not implicitly {@link anytype.Rpc.Block.Get.Marks.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Get.Marks
                     * @static
                     * @param {anytype.Rpc.Block.Get.IMarks} message Marks message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Marks.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Marks message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Get.Marks.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Get.Marks
                     * @static
                     * @param {anytype.Rpc.Block.Get.IMarks} message Marks message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Marks.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Marks message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Get.Marks
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Get.Marks} Marks
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Marks.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Get.Marks();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Marks message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Get.Marks
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Get.Marks} Marks
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Marks.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Marks message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Get.Marks
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Marks.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Marks message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Get.Marks
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Get.Marks} Marks
                     */
                    Marks.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Get.Marks)
                            return object;
                        return new $root.anytype.Rpc.Block.Get.Marks();
                    };

                    /**
                     * Creates a plain object from a Marks message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Get.Marks
                     * @static
                     * @param {anytype.Rpc.Block.Get.Marks} message Marks
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Marks.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Marks to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Get.Marks
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Marks.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Marks.Request = (function() {

                        /**
                         * Properties of a Request.
                         * @memberof anytype.Rpc.Block.Get.Marks
                         * @interface IRequest
                         * @property {string|null} [contextId] Request contextId
                         * @property {string|null} [blockId] Request blockId
                         * @property {anytype.model.IRange|null} [range] Request range
                         */

                        /**
                         * Constructs a new Request.
                         * @memberof anytype.Rpc.Block.Get.Marks
                         * @classdesc Represents a Request.
                         * @implements IRequest
                         * @constructor
                         * @param {anytype.Rpc.Block.Get.Marks.IRequest=} [properties] Properties to set
                         */
                        function Request(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Request contextId.
                         * @member {string} contextId
                         * @memberof anytype.Rpc.Block.Get.Marks.Request
                         * @instance
                         */
                        Request.prototype.contextId = "";

                        /**
                         * Request blockId.
                         * @member {string} blockId
                         * @memberof anytype.Rpc.Block.Get.Marks.Request
                         * @instance
                         */
                        Request.prototype.blockId = "";

                        /**
                         * Request range.
                         * @member {anytype.model.IRange|null|undefined} range
                         * @memberof anytype.Rpc.Block.Get.Marks.Request
                         * @instance
                         */
                        Request.prototype.range = null;

                        /**
                         * Creates a new Request instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Get.Marks.Request
                         * @static
                         * @param {anytype.Rpc.Block.Get.Marks.IRequest=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Get.Marks.Request} Request instance
                         */
                        Request.create = function create(properties) {
                            return new Request(properties);
                        };

                        /**
                         * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Get.Marks.Request.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Get.Marks.Request
                         * @static
                         * @param {anytype.Rpc.Block.Get.Marks.IRequest} message Request message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Request.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                            if (message.range != null && message.hasOwnProperty("range"))
                                $root.anytype.model.Range.encode(message.range, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Get.Marks.Request.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Get.Marks.Request
                         * @static
                         * @param {anytype.Rpc.Block.Get.Marks.IRequest} message Request message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Request.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Request message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Get.Marks.Request
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Get.Marks.Request} Request
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Request.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Get.Marks.Request();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.contextId = reader.string();
                                    break;
                                case 2:
                                    message.blockId = reader.string();
                                    break;
                                case 3:
                                    message.range = $root.anytype.model.Range.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Request message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Get.Marks.Request
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Get.Marks.Request} Request
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Request.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Request message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Get.Marks.Request
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Request.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                if (!$util.isString(message.contextId))
                                    return "contextId: string expected";
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                if (!$util.isString(message.blockId))
                                    return "blockId: string expected";
                            if (message.range != null && message.hasOwnProperty("range")) {
                                var error = $root.anytype.model.Range.verify(message.range);
                                if (error)
                                    return "range." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Request message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Get.Marks.Request
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Get.Marks.Request} Request
                         */
                        Request.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Get.Marks.Request)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Get.Marks.Request();
                            if (object.contextId != null)
                                message.contextId = String(object.contextId);
                            if (object.blockId != null)
                                message.blockId = String(object.blockId);
                            if (object.range != null) {
                                if (typeof object.range !== "object")
                                    throw TypeError(".anytype.Rpc.Block.Get.Marks.Request.range: object expected");
                                message.range = $root.anytype.model.Range.fromObject(object.range);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Request message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Get.Marks.Request
                         * @static
                         * @param {anytype.Rpc.Block.Get.Marks.Request} message Request
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Request.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.contextId = "";
                                object.blockId = "";
                                object.range = null;
                            }
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                object.contextId = message.contextId;
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                object.blockId = message.blockId;
                            if (message.range != null && message.hasOwnProperty("range"))
                                object.range = $root.anytype.model.Range.toObject(message.range, options);
                            return object;
                        };

                        /**
                         * Converts this Request to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Get.Marks.Request
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Request.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Request;
                    })();

                    Marks.Response = (function() {

                        /**
                         * Properties of a Response.
                         * @memberof anytype.Rpc.Block.Get.Marks
                         * @interface IResponse
                         * @property {anytype.Rpc.Block.Get.Marks.Response.IError|null} [error] Response error
                         */

                        /**
                         * Constructs a new Response.
                         * @memberof anytype.Rpc.Block.Get.Marks
                         * @classdesc Represents a Response.
                         * @implements IResponse
                         * @constructor
                         * @param {anytype.Rpc.Block.Get.Marks.IResponse=} [properties] Properties to set
                         */
                        function Response(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Response error.
                         * @member {anytype.Rpc.Block.Get.Marks.Response.IError|null|undefined} error
                         * @memberof anytype.Rpc.Block.Get.Marks.Response
                         * @instance
                         */
                        Response.prototype.error = null;

                        /**
                         * Creates a new Response instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Get.Marks.Response
                         * @static
                         * @param {anytype.Rpc.Block.Get.Marks.IResponse=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Get.Marks.Response} Response instance
                         */
                        Response.create = function create(properties) {
                            return new Response(properties);
                        };

                        /**
                         * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Get.Marks.Response.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Get.Marks.Response
                         * @static
                         * @param {anytype.Rpc.Block.Get.Marks.IResponse} message Response message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Response.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.error != null && message.hasOwnProperty("error"))
                                $root.anytype.Rpc.Block.Get.Marks.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Get.Marks.Response.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Get.Marks.Response
                         * @static
                         * @param {anytype.Rpc.Block.Get.Marks.IResponse} message Response message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Response.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Response message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Get.Marks.Response
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Get.Marks.Response} Response
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Response.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Get.Marks.Response();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.error = $root.anytype.Rpc.Block.Get.Marks.Response.Error.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Response message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Get.Marks.Response
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Get.Marks.Response} Response
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Response.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Response message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Get.Marks.Response
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Response.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.error != null && message.hasOwnProperty("error")) {
                                var error = $root.anytype.Rpc.Block.Get.Marks.Response.Error.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Response message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Get.Marks.Response
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Get.Marks.Response} Response
                         */
                        Response.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Get.Marks.Response)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Get.Marks.Response();
                            if (object.error != null) {
                                if (typeof object.error !== "object")
                                    throw TypeError(".anytype.Rpc.Block.Get.Marks.Response.error: object expected");
                                message.error = $root.anytype.Rpc.Block.Get.Marks.Response.Error.fromObject(object.error);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Response message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Get.Marks.Response
                         * @static
                         * @param {anytype.Rpc.Block.Get.Marks.Response} message Response
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Response.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.error = null;
                            if (message.error != null && message.hasOwnProperty("error"))
                                object.error = $root.anytype.Rpc.Block.Get.Marks.Response.Error.toObject(message.error, options);
                            return object;
                        };

                        /**
                         * Converts this Response to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Get.Marks.Response
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Response.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Response.Error = (function() {

                            /**
                             * Properties of an Error.
                             * @memberof anytype.Rpc.Block.Get.Marks.Response
                             * @interface IError
                             * @property {anytype.Rpc.Block.Get.Marks.Response.Error.Code|null} [code] Error code
                             * @property {string|null} [description] Error description
                             */

                            /**
                             * Constructs a new Error.
                             * @memberof anytype.Rpc.Block.Get.Marks.Response
                             * @classdesc Represents an Error.
                             * @implements IError
                             * @constructor
                             * @param {anytype.Rpc.Block.Get.Marks.Response.IError=} [properties] Properties to set
                             */
                            function Error(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Error code.
                             * @member {anytype.Rpc.Block.Get.Marks.Response.Error.Code} code
                             * @memberof anytype.Rpc.Block.Get.Marks.Response.Error
                             * @instance
                             */
                            Error.prototype.code = 0;

                            /**
                             * Error description.
                             * @member {string} description
                             * @memberof anytype.Rpc.Block.Get.Marks.Response.Error
                             * @instance
                             */
                            Error.prototype.description = "";

                            /**
                             * Creates a new Error instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.Get.Marks.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Get.Marks.Response.IError=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.Get.Marks.Response.Error} Error instance
                             */
                            Error.create = function create(properties) {
                                return new Error(properties);
                            };

                            /**
                             * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Get.Marks.Response.Error.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.Get.Marks.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Get.Marks.Response.IError} message Error message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Error.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.code != null && message.hasOwnProperty("code"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                if (message.description != null && message.hasOwnProperty("description"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                return writer;
                            };

                            /**
                             * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Get.Marks.Response.Error.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.Get.Marks.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Get.Marks.Response.IError} message Error message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Error.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes an Error message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.Get.Marks.Response.Error
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.Get.Marks.Response.Error} Error
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Error.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Get.Marks.Response.Error();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.code = reader.int32();
                                        break;
                                    case 2:
                                        message.description = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes an Error message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.Get.Marks.Response.Error
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.Get.Marks.Response.Error} Error
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Error.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies an Error message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.Get.Marks.Response.Error
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Error.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.code != null && message.hasOwnProperty("code"))
                                    switch (message.code) {
                                    default:
                                        return "code: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                        break;
                                    }
                                if (message.description != null && message.hasOwnProperty("description"))
                                    if (!$util.isString(message.description))
                                        return "description: string expected";
                                return null;
                            };

                            /**
                             * Creates an Error message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.Get.Marks.Response.Error
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.Get.Marks.Response.Error} Error
                             */
                            Error.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.Get.Marks.Response.Error)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.Get.Marks.Response.Error();
                                switch (object.code) {
                                case "NULL":
                                case 0:
                                    message.code = 0;
                                    break;
                                case "UNKNOWN_ERROR":
                                case 1:
                                    message.code = 1;
                                    break;
                                case "BAD_INPUT":
                                case 2:
                                    message.code = 2;
                                    break;
                                }
                                if (object.description != null)
                                    message.description = String(object.description);
                                return message;
                            };

                            /**
                             * Creates a plain object from an Error message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.Get.Marks.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.Get.Marks.Response.Error} message Error
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Error.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.code = options.enums === String ? "NULL" : 0;
                                    object.description = "";
                                }
                                if (message.code != null && message.hasOwnProperty("code"))
                                    object.code = options.enums === String ? $root.anytype.Rpc.Block.Get.Marks.Response.Error.Code[message.code] : message.code;
                                if (message.description != null && message.hasOwnProperty("description"))
                                    object.description = message.description;
                                return object;
                            };

                            /**
                             * Converts this Error to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.Get.Marks.Response.Error
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Error.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Code enum.
                             * @name anytype.Rpc.Block.Get.Marks.Response.Error.Code
                             * @enum {string}
                             * @property {number} NULL=0 NULL value
                             * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                             * @property {number} BAD_INPUT=2 BAD_INPUT value
                             */
                            Error.Code = (function() {
                                var valuesById = {}, values = Object.create(valuesById);
                                values[valuesById[0] = "NULL"] = 0;
                                values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                values[valuesById[2] = "BAD_INPUT"] = 2;
                                return values;
                            })();

                            return Error;
                        })();

                        return Response;
                    })();

                    return Marks;
                })();

                return Get;
            })();

            Block.History = (function() {

                /**
                 * Properties of a History.
                 * @memberof anytype.Rpc.Block
                 * @interface IHistory
                 */

                /**
                 * Constructs a new History.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents a History.
                 * @implements IHistory
                 * @constructor
                 * @param {anytype.Rpc.Block.IHistory=} [properties] Properties to set
                 */
                function History(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new History instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.History
                 * @static
                 * @param {anytype.Rpc.Block.IHistory=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.History} History instance
                 */
                History.create = function create(properties) {
                    return new History(properties);
                };

                /**
                 * Encodes the specified History message. Does not implicitly {@link anytype.Rpc.Block.History.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.History
                 * @static
                 * @param {anytype.Rpc.Block.IHistory} message History message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                History.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified History message, length delimited. Does not implicitly {@link anytype.Rpc.Block.History.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.History
                 * @static
                 * @param {anytype.Rpc.Block.IHistory} message History message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                History.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a History message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.History
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.History} History
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                History.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.History();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a History message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.History
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.History} History
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                History.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a History message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.History
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                History.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a History message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.History
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.History} History
                 */
                History.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.History)
                        return object;
                    return new $root.anytype.Rpc.Block.History();
                };

                /**
                 * Creates a plain object from a History message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.History
                 * @static
                 * @param {anytype.Rpc.Block.History} message History
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                History.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this History to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.History
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                History.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                History.Move = (function() {

                    /**
                     * Properties of a Move.
                     * @memberof anytype.Rpc.Block.History
                     * @interface IMove
                     */

                    /**
                     * Constructs a new Move.
                     * @memberof anytype.Rpc.Block.History
                     * @classdesc Represents a Move.
                     * @implements IMove
                     * @constructor
                     * @param {anytype.Rpc.Block.History.IMove=} [properties] Properties to set
                     */
                    function Move(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Move instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.History.Move
                     * @static
                     * @param {anytype.Rpc.Block.History.IMove=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.History.Move} Move instance
                     */
                    Move.create = function create(properties) {
                        return new Move(properties);
                    };

                    /**
                     * Encodes the specified Move message. Does not implicitly {@link anytype.Rpc.Block.History.Move.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.History.Move
                     * @static
                     * @param {anytype.Rpc.Block.History.IMove} message Move message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Move.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Move message, length delimited. Does not implicitly {@link anytype.Rpc.Block.History.Move.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.History.Move
                     * @static
                     * @param {anytype.Rpc.Block.History.IMove} message Move message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Move.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Move message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.History.Move
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.History.Move} Move
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Move.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.History.Move();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Move message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.History.Move
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.History.Move} Move
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Move.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Move message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.History.Move
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Move.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Move message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.History.Move
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.History.Move} Move
                     */
                    Move.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.History.Move)
                            return object;
                        return new $root.anytype.Rpc.Block.History.Move();
                    };

                    /**
                     * Creates a plain object from a Move message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.History.Move
                     * @static
                     * @param {anytype.Rpc.Block.History.Move} message Move
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Move.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Move to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.History.Move
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Move.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Move.Request = (function() {

                        /**
                         * Properties of a Request.
                         * @memberof anytype.Rpc.Block.History.Move
                         * @interface IRequest
                         * @property {string|null} [contextId] Request contextId
                         * @property {string|null} [blockId] Request blockId
                         * @property {boolean|null} [moveForward] Request moveForward
                         */

                        /**
                         * Constructs a new Request.
                         * @memberof anytype.Rpc.Block.History.Move
                         * @classdesc Represents a Request.
                         * @implements IRequest
                         * @constructor
                         * @param {anytype.Rpc.Block.History.Move.IRequest=} [properties] Properties to set
                         */
                        function Request(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Request contextId.
                         * @member {string} contextId
                         * @memberof anytype.Rpc.Block.History.Move.Request
                         * @instance
                         */
                        Request.prototype.contextId = "";

                        /**
                         * Request blockId.
                         * @member {string} blockId
                         * @memberof anytype.Rpc.Block.History.Move.Request
                         * @instance
                         */
                        Request.prototype.blockId = "";

                        /**
                         * Request moveForward.
                         * @member {boolean} moveForward
                         * @memberof anytype.Rpc.Block.History.Move.Request
                         * @instance
                         */
                        Request.prototype.moveForward = false;

                        /**
                         * Creates a new Request instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.History.Move.Request
                         * @static
                         * @param {anytype.Rpc.Block.History.Move.IRequest=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.History.Move.Request} Request instance
                         */
                        Request.create = function create(properties) {
                            return new Request(properties);
                        };

                        /**
                         * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.History.Move.Request.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.History.Move.Request
                         * @static
                         * @param {anytype.Rpc.Block.History.Move.IRequest} message Request message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Request.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                            if (message.moveForward != null && message.hasOwnProperty("moveForward"))
                                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.moveForward);
                            return writer;
                        };

                        /**
                         * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.History.Move.Request.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.History.Move.Request
                         * @static
                         * @param {anytype.Rpc.Block.History.Move.IRequest} message Request message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Request.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Request message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.History.Move.Request
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.History.Move.Request} Request
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Request.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.History.Move.Request();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.contextId = reader.string();
                                    break;
                                case 2:
                                    message.blockId = reader.string();
                                    break;
                                case 3:
                                    message.moveForward = reader.bool();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Request message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.History.Move.Request
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.History.Move.Request} Request
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Request.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Request message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.History.Move.Request
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Request.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                if (!$util.isString(message.contextId))
                                    return "contextId: string expected";
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                if (!$util.isString(message.blockId))
                                    return "blockId: string expected";
                            if (message.moveForward != null && message.hasOwnProperty("moveForward"))
                                if (typeof message.moveForward !== "boolean")
                                    return "moveForward: boolean expected";
                            return null;
                        };

                        /**
                         * Creates a Request message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.History.Move.Request
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.History.Move.Request} Request
                         */
                        Request.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.History.Move.Request)
                                return object;
                            var message = new $root.anytype.Rpc.Block.History.Move.Request();
                            if (object.contextId != null)
                                message.contextId = String(object.contextId);
                            if (object.blockId != null)
                                message.blockId = String(object.blockId);
                            if (object.moveForward != null)
                                message.moveForward = Boolean(object.moveForward);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Request message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.History.Move.Request
                         * @static
                         * @param {anytype.Rpc.Block.History.Move.Request} message Request
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Request.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.contextId = "";
                                object.blockId = "";
                                object.moveForward = false;
                            }
                            if (message.contextId != null && message.hasOwnProperty("contextId"))
                                object.contextId = message.contextId;
                            if (message.blockId != null && message.hasOwnProperty("blockId"))
                                object.blockId = message.blockId;
                            if (message.moveForward != null && message.hasOwnProperty("moveForward"))
                                object.moveForward = message.moveForward;
                            return object;
                        };

                        /**
                         * Converts this Request to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.History.Move.Request
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Request.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Request;
                    })();

                    Move.Response = (function() {

                        /**
                         * Properties of a Response.
                         * @memberof anytype.Rpc.Block.History.Move
                         * @interface IResponse
                         * @property {anytype.Rpc.Block.History.Move.Response.IError|null} [error] Response error
                         */

                        /**
                         * Constructs a new Response.
                         * @memberof anytype.Rpc.Block.History.Move
                         * @classdesc Represents a Response.
                         * @implements IResponse
                         * @constructor
                         * @param {anytype.Rpc.Block.History.Move.IResponse=} [properties] Properties to set
                         */
                        function Response(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Response error.
                         * @member {anytype.Rpc.Block.History.Move.Response.IError|null|undefined} error
                         * @memberof anytype.Rpc.Block.History.Move.Response
                         * @instance
                         */
                        Response.prototype.error = null;

                        /**
                         * Creates a new Response instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.History.Move.Response
                         * @static
                         * @param {anytype.Rpc.Block.History.Move.IResponse=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.History.Move.Response} Response instance
                         */
                        Response.create = function create(properties) {
                            return new Response(properties);
                        };

                        /**
                         * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.History.Move.Response.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.History.Move.Response
                         * @static
                         * @param {anytype.Rpc.Block.History.Move.IResponse} message Response message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Response.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.error != null && message.hasOwnProperty("error"))
                                $root.anytype.Rpc.Block.History.Move.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.History.Move.Response.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.History.Move.Response
                         * @static
                         * @param {anytype.Rpc.Block.History.Move.IResponse} message Response message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Response.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Response message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.History.Move.Response
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.History.Move.Response} Response
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Response.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.History.Move.Response();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.error = $root.anytype.Rpc.Block.History.Move.Response.Error.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Response message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.History.Move.Response
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.History.Move.Response} Response
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Response.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Response message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.History.Move.Response
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Response.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.error != null && message.hasOwnProperty("error")) {
                                var error = $root.anytype.Rpc.Block.History.Move.Response.Error.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Response message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.History.Move.Response
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.History.Move.Response} Response
                         */
                        Response.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.History.Move.Response)
                                return object;
                            var message = new $root.anytype.Rpc.Block.History.Move.Response();
                            if (object.error != null) {
                                if (typeof object.error !== "object")
                                    throw TypeError(".anytype.Rpc.Block.History.Move.Response.error: object expected");
                                message.error = $root.anytype.Rpc.Block.History.Move.Response.Error.fromObject(object.error);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Response message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.History.Move.Response
                         * @static
                         * @param {anytype.Rpc.Block.History.Move.Response} message Response
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Response.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.error = null;
                            if (message.error != null && message.hasOwnProperty("error"))
                                object.error = $root.anytype.Rpc.Block.History.Move.Response.Error.toObject(message.error, options);
                            return object;
                        };

                        /**
                         * Converts this Response to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.History.Move.Response
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Response.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Response.Error = (function() {

                            /**
                             * Properties of an Error.
                             * @memberof anytype.Rpc.Block.History.Move.Response
                             * @interface IError
                             * @property {anytype.Rpc.Block.History.Move.Response.Error.Code|null} [code] Error code
                             * @property {string|null} [description] Error description
                             */

                            /**
                             * Constructs a new Error.
                             * @memberof anytype.Rpc.Block.History.Move.Response
                             * @classdesc Represents an Error.
                             * @implements IError
                             * @constructor
                             * @param {anytype.Rpc.Block.History.Move.Response.IError=} [properties] Properties to set
                             */
                            function Error(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Error code.
                             * @member {anytype.Rpc.Block.History.Move.Response.Error.Code} code
                             * @memberof anytype.Rpc.Block.History.Move.Response.Error
                             * @instance
                             */
                            Error.prototype.code = 0;

                            /**
                             * Error description.
                             * @member {string} description
                             * @memberof anytype.Rpc.Block.History.Move.Response.Error
                             * @instance
                             */
                            Error.prototype.description = "";

                            /**
                             * Creates a new Error instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Block.History.Move.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.History.Move.Response.IError=} [properties] Properties to set
                             * @returns {anytype.Rpc.Block.History.Move.Response.Error} Error instance
                             */
                            Error.create = function create(properties) {
                                return new Error(properties);
                            };

                            /**
                             * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.History.Move.Response.Error.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Block.History.Move.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.History.Move.Response.IError} message Error message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Error.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.code != null && message.hasOwnProperty("code"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                if (message.description != null && message.hasOwnProperty("description"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                return writer;
                            };

                            /**
                             * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.History.Move.Response.Error.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Block.History.Move.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.History.Move.Response.IError} message Error message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Error.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes an Error message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Block.History.Move.Response.Error
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Block.History.Move.Response.Error} Error
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Error.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.History.Move.Response.Error();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.code = reader.int32();
                                        break;
                                    case 2:
                                        message.description = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes an Error message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Block.History.Move.Response.Error
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Block.History.Move.Response.Error} Error
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Error.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies an Error message.
                             * @function verify
                             * @memberof anytype.Rpc.Block.History.Move.Response.Error
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Error.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.code != null && message.hasOwnProperty("code"))
                                    switch (message.code) {
                                    default:
                                        return "code: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                        break;
                                    }
                                if (message.description != null && message.hasOwnProperty("description"))
                                    if (!$util.isString(message.description))
                                        return "description: string expected";
                                return null;
                            };

                            /**
                             * Creates an Error message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Block.History.Move.Response.Error
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Block.History.Move.Response.Error} Error
                             */
                            Error.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Block.History.Move.Response.Error)
                                    return object;
                                var message = new $root.anytype.Rpc.Block.History.Move.Response.Error();
                                switch (object.code) {
                                case "NULL":
                                case 0:
                                    message.code = 0;
                                    break;
                                case "UNKNOWN_ERROR":
                                case 1:
                                    message.code = 1;
                                    break;
                                case "BAD_INPUT":
                                case 2:
                                    message.code = 2;
                                    break;
                                case "CAN_NOT_MOVE":
                                case 3:
                                    message.code = 3;
                                    break;
                                }
                                if (object.description != null)
                                    message.description = String(object.description);
                                return message;
                            };

                            /**
                             * Creates a plain object from an Error message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Block.History.Move.Response.Error
                             * @static
                             * @param {anytype.Rpc.Block.History.Move.Response.Error} message Error
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Error.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.code = options.enums === String ? "NULL" : 0;
                                    object.description = "";
                                }
                                if (message.code != null && message.hasOwnProperty("code"))
                                    object.code = options.enums === String ? $root.anytype.Rpc.Block.History.Move.Response.Error.Code[message.code] : message.code;
                                if (message.description != null && message.hasOwnProperty("description"))
                                    object.description = message.description;
                                return object;
                            };

                            /**
                             * Converts this Error to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Block.History.Move.Response.Error
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Error.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Code enum.
                             * @name anytype.Rpc.Block.History.Move.Response.Error.Code
                             * @enum {string}
                             * @property {number} NULL=0 NULL value
                             * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                             * @property {number} BAD_INPUT=2 BAD_INPUT value
                             * @property {number} CAN_NOT_MOVE=3 CAN_NOT_MOVE value
                             */
                            Error.Code = (function() {
                                var valuesById = {}, values = Object.create(valuesById);
                                values[valuesById[0] = "NULL"] = 0;
                                values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                values[valuesById[2] = "BAD_INPUT"] = 2;
                                values[valuesById[3] = "CAN_NOT_MOVE"] = 3;
                                return values;
                            })();

                            return Error;
                        })();

                        return Response;
                    })();

                    return Move;
                })();

                return History;
            })();

            Block.Open = (function() {

                /**
                 * Properties of an Open.
                 * @memberof anytype.Rpc.Block
                 * @interface IOpen
                 */

                /**
                 * Constructs a new Open.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents an Open.
                 * @implements IOpen
                 * @constructor
                 * @param {anytype.Rpc.Block.IOpen=} [properties] Properties to set
                 */
                function Open(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Open instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Open
                 * @static
                 * @param {anytype.Rpc.Block.IOpen=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Open} Open instance
                 */
                Open.create = function create(properties) {
                    return new Open(properties);
                };

                /**
                 * Encodes the specified Open message. Does not implicitly {@link anytype.Rpc.Block.Open.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Open
                 * @static
                 * @param {anytype.Rpc.Block.IOpen} message Open message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Open.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Open message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Open.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Open
                 * @static
                 * @param {anytype.Rpc.Block.IOpen} message Open message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Open.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Open message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Open
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Open} Open
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Open.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Open();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Open message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Open
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Open} Open
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Open.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Open message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Open
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Open.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an Open message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Open
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Open} Open
                 */
                Open.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Open)
                        return object;
                    return new $root.anytype.Rpc.Block.Open();
                };

                /**
                 * Creates a plain object from an Open message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Open
                 * @static
                 * @param {anytype.Rpc.Block.Open} message Open
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Open.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Open to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Open
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Open.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Open.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Block.Open
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {string|null} [blockId] Request blockId
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Block.Open
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Block.Open.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.Block.Open.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request blockId.
                     * @member {string} blockId
                     * @memberof anytype.Rpc.Block.Open.Request
                     * @instance
                     */
                    Request.prototype.blockId = "";

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Open.Request
                     * @static
                     * @param {anytype.Rpc.Block.Open.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Open.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Open.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Open.Request
                     * @static
                     * @param {anytype.Rpc.Block.Open.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Open.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Open.Request
                     * @static
                     * @param {anytype.Rpc.Block.Open.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Open.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Open.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Open.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                message.blockId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Open.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Open.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Open.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            if (!$util.isString(message.blockId))
                                return "blockId: string expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Open.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Open.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Open.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Open.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.blockId != null)
                            message.blockId = String(object.blockId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Open.Request
                     * @static
                     * @param {anytype.Rpc.Block.Open.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contextId = "";
                            object.blockId = "";
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            object.blockId = message.blockId;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Open.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Open.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Block.Open
                     * @interface IResponse
                     * @property {anytype.Rpc.Block.Open.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Block.Open
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Block.Open.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Block.Open.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Block.Open.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Open.Response
                     * @static
                     * @param {anytype.Rpc.Block.Open.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Open.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Open.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Open.Response
                     * @static
                     * @param {anytype.Rpc.Block.Open.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Block.Open.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Open.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Open.Response
                     * @static
                     * @param {anytype.Rpc.Block.Open.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Open.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Open.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Open.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Block.Open.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Open.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Open.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Open.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Block.Open.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Open.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Open.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Open.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Open.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Block.Open.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Block.Open.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Open.Response
                     * @static
                     * @param {anytype.Rpc.Block.Open.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Block.Open.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Open.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Block.Open.Response
                         * @interface IError
                         * @property {anytype.Rpc.Block.Open.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Block.Open.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Block.Open.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Block.Open.Response.Error.Code} code
                         * @memberof anytype.Rpc.Block.Open.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Block.Open.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Open.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Open.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Open.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Open.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Open.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Open.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Open.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Open.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Open.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Open.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Open.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Open.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Open.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Open.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Open.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Open.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Open.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Open.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Open.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Open.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Open.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Block.Open.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Open.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Block.Open.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Open;
            })();

            Block.Create = (function() {

                /**
                 * Properties of a Create.
                 * @memberof anytype.Rpc.Block
                 * @interface ICreate
                 */

                /**
                 * Constructs a new Create.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents a Create.
                 * @implements ICreate
                 * @constructor
                 * @param {anytype.Rpc.Block.ICreate=} [properties] Properties to set
                 */
                function Create(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Create instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Create
                 * @static
                 * @param {anytype.Rpc.Block.ICreate=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Create} Create instance
                 */
                Create.create = function create(properties) {
                    return new Create(properties);
                };

                /**
                 * Encodes the specified Create message. Does not implicitly {@link anytype.Rpc.Block.Create.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Create
                 * @static
                 * @param {anytype.Rpc.Block.ICreate} message Create message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Create.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Create message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Create.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Create
                 * @static
                 * @param {anytype.Rpc.Block.ICreate} message Create message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Create.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Create message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Create
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Create} Create
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Create.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Create();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Create message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Create
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Create} Create
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Create.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Create message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Create
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Create.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Create message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Create
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Create} Create
                 */
                Create.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Create)
                        return object;
                    return new $root.anytype.Rpc.Block.Create();
                };

                /**
                 * Creates a plain object from a Create message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Create
                 * @static
                 * @param {anytype.Rpc.Block.Create} message Create
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Create.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Create to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Create
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Create.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Create.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Block.Create
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {string|null} [targetId] Request targetId
                     * @property {anytype.model.IBlock|null} [block] Request block
                     * @property {anytype.model.Block.Position|null} [position] Request position
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Block.Create
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Block.Create.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request targetId.
                     * @member {string} targetId
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @instance
                     */
                    Request.prototype.targetId = "";

                    /**
                     * Request block.
                     * @member {anytype.model.IBlock|null|undefined} block
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @instance
                     */
                    Request.prototype.block = null;

                    /**
                     * Request position.
                     * @member {anytype.model.Block.Position} position
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @instance
                     */
                    Request.prototype.position = 0;

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @static
                     * @param {anytype.Rpc.Block.Create.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Create.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Create.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @static
                     * @param {anytype.Rpc.Block.Create.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.targetId != null && message.hasOwnProperty("targetId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetId);
                        if (message.block != null && message.hasOwnProperty("block"))
                            $root.anytype.model.Block.encode(message.block, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.position != null && message.hasOwnProperty("position"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.position);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Create.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @static
                     * @param {anytype.Rpc.Block.Create.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Create.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Create.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                message.targetId = reader.string();
                                break;
                            case 3:
                                message.block = $root.anytype.model.Block.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.position = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Create.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.targetId != null && message.hasOwnProperty("targetId"))
                            if (!$util.isString(message.targetId))
                                return "targetId: string expected";
                        if (message.block != null && message.hasOwnProperty("block")) {
                            var error = $root.anytype.model.Block.verify(message.block);
                            if (error)
                                return "block." + error;
                        }
                        if (message.position != null && message.hasOwnProperty("position"))
                            switch (message.position) {
                            default:
                                return "position: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Create.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Create.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Create.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.targetId != null)
                            message.targetId = String(object.targetId);
                        if (object.block != null) {
                            if (typeof object.block !== "object")
                                throw TypeError(".anytype.Rpc.Block.Create.Request.block: object expected");
                            message.block = $root.anytype.model.Block.fromObject(object.block);
                        }
                        switch (object.position) {
                        case "None":
                        case 0:
                            message.position = 0;
                            break;
                        case "Top":
                        case 1:
                            message.position = 1;
                            break;
                        case "Bottom":
                        case 2:
                            message.position = 2;
                            break;
                        case "Left":
                        case 3:
                            message.position = 3;
                            break;
                        case "Right":
                        case 4:
                            message.position = 4;
                            break;
                        case "Inner":
                        case 5:
                            message.position = 5;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @static
                     * @param {anytype.Rpc.Block.Create.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contextId = "";
                            object.targetId = "";
                            object.block = null;
                            object.position = options.enums === String ? "None" : 0;
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.targetId != null && message.hasOwnProperty("targetId"))
                            object.targetId = message.targetId;
                        if (message.block != null && message.hasOwnProperty("block"))
                            object.block = $root.anytype.model.Block.toObject(message.block, options);
                        if (message.position != null && message.hasOwnProperty("position"))
                            object.position = options.enums === String ? $root.anytype.model.Block.Position[message.position] : message.position;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Create.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Create.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Block.Create
                     * @interface IResponse
                     * @property {anytype.Rpc.Block.Create.Response.IError|null} [error] Response error
                     * @property {string|null} [blockId] Response blockId
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Block.Create
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Block.Create.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Block.Create.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Block.Create.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Response blockId.
                     * @member {string} blockId
                     * @memberof anytype.Rpc.Block.Create.Response
                     * @instance
                     */
                    Response.prototype.blockId = "";

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Create.Response
                     * @static
                     * @param {anytype.Rpc.Block.Create.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Create.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Create.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Create.Response
                     * @static
                     * @param {anytype.Rpc.Block.Create.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Block.Create.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Create.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Create.Response
                     * @static
                     * @param {anytype.Rpc.Block.Create.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Create.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Create.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Create.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Block.Create.Response.Error.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.blockId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Create.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Create.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Create.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Block.Create.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            if (!$util.isString(message.blockId))
                                return "blockId: string expected";
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Create.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Create.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Create.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Create.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Block.Create.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Block.Create.Response.Error.fromObject(object.error);
                        }
                        if (object.blockId != null)
                            message.blockId = String(object.blockId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Create.Response
                     * @static
                     * @param {anytype.Rpc.Block.Create.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.error = null;
                            object.blockId = "";
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Block.Create.Response.Error.toObject(message.error, options);
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            object.blockId = message.blockId;
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Create.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Block.Create.Response
                         * @interface IError
                         * @property {anytype.Rpc.Block.Create.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Block.Create.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Block.Create.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Block.Create.Response.Error.Code} code
                         * @memberof anytype.Rpc.Block.Create.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Block.Create.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Create.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Create.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Create.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Create.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Create.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Create.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Create.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Create.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Create.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Create.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Create.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Create.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Create.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Create.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Create.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Create.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Create.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Create.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Create.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Create.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Create.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Block.Create.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Create.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Block.Create.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Create;
            })();

            Block.Unlink = (function() {

                /**
                 * Properties of an Unlink.
                 * @memberof anytype.Rpc.Block
                 * @interface IUnlink
                 */

                /**
                 * Constructs a new Unlink.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents an Unlink.
                 * @implements IUnlink
                 * @constructor
                 * @param {anytype.Rpc.Block.IUnlink=} [properties] Properties to set
                 */
                function Unlink(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Unlink instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Unlink
                 * @static
                 * @param {anytype.Rpc.Block.IUnlink=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Unlink} Unlink instance
                 */
                Unlink.create = function create(properties) {
                    return new Unlink(properties);
                };

                /**
                 * Encodes the specified Unlink message. Does not implicitly {@link anytype.Rpc.Block.Unlink.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Unlink
                 * @static
                 * @param {anytype.Rpc.Block.IUnlink} message Unlink message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Unlink.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Unlink message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Unlink.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Unlink
                 * @static
                 * @param {anytype.Rpc.Block.IUnlink} message Unlink message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Unlink.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Unlink message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Unlink
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Unlink} Unlink
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Unlink.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Unlink();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Unlink message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Unlink
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Unlink} Unlink
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Unlink.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Unlink message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Unlink
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Unlink.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an Unlink message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Unlink
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Unlink} Unlink
                 */
                Unlink.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Unlink)
                        return object;
                    return new $root.anytype.Rpc.Block.Unlink();
                };

                /**
                 * Creates a plain object from an Unlink message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Unlink
                 * @static
                 * @param {anytype.Rpc.Block.Unlink} message Unlink
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Unlink.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Unlink to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Unlink
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Unlink.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Unlink.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Block.Unlink
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {Array.<string>|null} [blockIds] Request blockIds
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Block.Unlink
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Block.Unlink.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        this.blockIds = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.Block.Unlink.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request blockIds.
                     * @member {Array.<string>} blockIds
                     * @memberof anytype.Rpc.Block.Unlink.Request
                     * @instance
                     */
                    Request.prototype.blockIds = $util.emptyArray;

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Unlink.Request
                     * @static
                     * @param {anytype.Rpc.Block.Unlink.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Unlink.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Unlink.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Unlink.Request
                     * @static
                     * @param {anytype.Rpc.Block.Unlink.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.blockIds != null && message.blockIds.length)
                            for (var i = 0; i < message.blockIds.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockIds[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Unlink.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Unlink.Request
                     * @static
                     * @param {anytype.Rpc.Block.Unlink.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Unlink.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Unlink.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Unlink.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                if (!(message.blockIds && message.blockIds.length))
                                    message.blockIds = [];
                                message.blockIds.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Unlink.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Unlink.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Unlink.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.blockIds != null && message.hasOwnProperty("blockIds")) {
                            if (!Array.isArray(message.blockIds))
                                return "blockIds: array expected";
                            for (var i = 0; i < message.blockIds.length; ++i)
                                if (!$util.isString(message.blockIds[i]))
                                    return "blockIds: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Unlink.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Unlink.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Unlink.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Unlink.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.blockIds) {
                            if (!Array.isArray(object.blockIds))
                                throw TypeError(".anytype.Rpc.Block.Unlink.Request.blockIds: array expected");
                            message.blockIds = [];
                            for (var i = 0; i < object.blockIds.length; ++i)
                                message.blockIds[i] = String(object.blockIds[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Unlink.Request
                     * @static
                     * @param {anytype.Rpc.Block.Unlink.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.blockIds = [];
                        if (options.defaults)
                            object.contextId = "";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.blockIds && message.blockIds.length) {
                            object.blockIds = [];
                            for (var j = 0; j < message.blockIds.length; ++j)
                                object.blockIds[j] = message.blockIds[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Unlink.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Unlink.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Block.Unlink
                     * @interface IResponse
                     * @property {anytype.Rpc.Block.Unlink.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Block.Unlink
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Block.Unlink.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Block.Unlink.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Block.Unlink.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Unlink.Response
                     * @static
                     * @param {anytype.Rpc.Block.Unlink.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Unlink.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Unlink.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Unlink.Response
                     * @static
                     * @param {anytype.Rpc.Block.Unlink.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Block.Unlink.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Unlink.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Unlink.Response
                     * @static
                     * @param {anytype.Rpc.Block.Unlink.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Unlink.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Unlink.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Unlink.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Block.Unlink.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Unlink.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Unlink.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Unlink.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Block.Unlink.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Unlink.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Unlink.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Unlink.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Unlink.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Block.Unlink.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Block.Unlink.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Unlink.Response
                     * @static
                     * @param {anytype.Rpc.Block.Unlink.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Block.Unlink.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Unlink.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Block.Unlink.Response
                         * @interface IError
                         * @property {anytype.Rpc.Block.Unlink.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Block.Unlink.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Block.Unlink.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Block.Unlink.Response.Error.Code} code
                         * @memberof anytype.Rpc.Block.Unlink.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Block.Unlink.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Unlink.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Unlink.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Unlink.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Unlink.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Unlink.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Unlink.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Unlink.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Unlink.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Unlink.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Unlink.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Unlink.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Unlink.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Unlink.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Unlink.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Unlink.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Unlink.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Unlink.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Unlink.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Unlink.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Unlink.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Unlink.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Block.Unlink.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Unlink.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Block.Unlink.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Unlink;
            })();

            Block.Close = (function() {

                /**
                 * Properties of a Close.
                 * @memberof anytype.Rpc.Block
                 * @interface IClose
                 */

                /**
                 * Constructs a new Close.
                 * @memberof anytype.Rpc.Block
                 * @classdesc Represents a Close.
                 * @implements IClose
                 * @constructor
                 * @param {anytype.Rpc.Block.IClose=} [properties] Properties to set
                 */
                function Close(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Close instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Block.Close
                 * @static
                 * @param {anytype.Rpc.Block.IClose=} [properties] Properties to set
                 * @returns {anytype.Rpc.Block.Close} Close instance
                 */
                Close.create = function create(properties) {
                    return new Close(properties);
                };

                /**
                 * Encodes the specified Close message. Does not implicitly {@link anytype.Rpc.Block.Close.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Block.Close
                 * @static
                 * @param {anytype.Rpc.Block.IClose} message Close message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Close.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Close message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Close.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Block.Close
                 * @static
                 * @param {anytype.Rpc.Block.IClose} message Close message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Close.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Close message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Block.Close
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Block.Close} Close
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Close.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Close();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Close message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Block.Close
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Block.Close} Close
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Close.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Close message.
                 * @function verify
                 * @memberof anytype.Rpc.Block.Close
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Close.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Close message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Block.Close
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Block.Close} Close
                 */
                Close.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Block.Close)
                        return object;
                    return new $root.anytype.Rpc.Block.Close();
                };

                /**
                 * Creates a plain object from a Close message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Block.Close
                 * @static
                 * @param {anytype.Rpc.Block.Close} message Close
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Close.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Close to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Block.Close
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Close.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Close.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Block.Close
                     * @interface IRequest
                     * @property {string|null} [contextId] Request contextId
                     * @property {string|null} [blockId] Request blockId
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Block.Close
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Block.Close.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request contextId.
                     * @member {string} contextId
                     * @memberof anytype.Rpc.Block.Close.Request
                     * @instance
                     */
                    Request.prototype.contextId = "";

                    /**
                     * Request blockId.
                     * @member {string} blockId
                     * @memberof anytype.Rpc.Block.Close.Request
                     * @instance
                     */
                    Request.prototype.blockId = "";

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Close.Request
                     * @static
                     * @param {anytype.Rpc.Block.Close.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Close.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Block.Close.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Close.Request
                     * @static
                     * @param {anytype.Rpc.Block.Close.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.contextId);
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Close.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Close.Request
                     * @static
                     * @param {anytype.Rpc.Block.Close.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Close.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Close.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Close.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.contextId = reader.string();
                                break;
                            case 2:
                                message.blockId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Close.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Close.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Close.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            if (!$util.isString(message.contextId))
                                return "contextId: string expected";
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            if (!$util.isString(message.blockId))
                                return "blockId: string expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Close.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Close.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Close.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Close.Request();
                        if (object.contextId != null)
                            message.contextId = String(object.contextId);
                        if (object.blockId != null)
                            message.blockId = String(object.blockId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Close.Request
                     * @static
                     * @param {anytype.Rpc.Block.Close.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.contextId = "";
                            object.blockId = "";
                        }
                        if (message.contextId != null && message.hasOwnProperty("contextId"))
                            object.contextId = message.contextId;
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            object.blockId = message.blockId;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Close.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Close.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Block.Close
                     * @interface IResponse
                     * @property {anytype.Rpc.Block.Close.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Block.Close
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Block.Close.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Block.Close.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Block.Close.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Block.Close.Response
                     * @static
                     * @param {anytype.Rpc.Block.Close.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Block.Close.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Block.Close.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Block.Close.Response
                     * @static
                     * @param {anytype.Rpc.Block.Close.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Block.Close.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Close.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Block.Close.Response
                     * @static
                     * @param {anytype.Rpc.Block.Close.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Block.Close.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Block.Close.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Close.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Block.Close.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Block.Close.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Block.Close.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Block.Close.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Block.Close.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Block.Close.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Block.Close.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Block.Close.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Block.Close.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Block.Close.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Block.Close.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Block.Close.Response
                     * @static
                     * @param {anytype.Rpc.Block.Close.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Block.Close.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Block.Close.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Block.Close.Response
                         * @interface IError
                         * @property {anytype.Rpc.Block.Close.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Block.Close.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Block.Close.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Block.Close.Response.Error.Code} code
                         * @memberof anytype.Rpc.Block.Close.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Block.Close.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Block.Close.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Close.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Block.Close.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Block.Close.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Block.Close.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Close.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Block.Close.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Block.Close.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Close.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Block.Close.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Block.Close.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Block.Close.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Block.Close.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Block.Close.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Block.Close.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Block.Close.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Block.Close.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Block.Close.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Block.Close.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Block.Close.Response.Error
                         * @static
                         * @param {anytype.Rpc.Block.Close.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Block.Close.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Block.Close.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Block.Close.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Close;
            })();

            return Block;
        })();

        Rpc.Wallet = (function() {

            /**
             * Properties of a Wallet.
             * @memberof anytype.Rpc
             * @interface IWallet
             */

            /**
             * Constructs a new Wallet.
             * @memberof anytype.Rpc
             * @classdesc Represents a Wallet.
             * @implements IWallet
             * @constructor
             * @param {anytype.Rpc.IWallet=} [properties] Properties to set
             */
            function Wallet(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Wallet instance using the specified properties.
             * @function create
             * @memberof anytype.Rpc.Wallet
             * @static
             * @param {anytype.Rpc.IWallet=} [properties] Properties to set
             * @returns {anytype.Rpc.Wallet} Wallet instance
             */
            Wallet.create = function create(properties) {
                return new Wallet(properties);
            };

            /**
             * Encodes the specified Wallet message. Does not implicitly {@link anytype.Rpc.Wallet.verify|verify} messages.
             * @function encode
             * @memberof anytype.Rpc.Wallet
             * @static
             * @param {anytype.Rpc.IWallet} message Wallet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Wallet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Wallet message, length delimited. Does not implicitly {@link anytype.Rpc.Wallet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Rpc.Wallet
             * @static
             * @param {anytype.Rpc.IWallet} message Wallet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Wallet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Wallet message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Rpc.Wallet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Rpc.Wallet} Wallet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Wallet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Wallet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Wallet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Rpc.Wallet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Rpc.Wallet} Wallet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Wallet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Wallet message.
             * @function verify
             * @memberof anytype.Rpc.Wallet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Wallet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Wallet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Rpc.Wallet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Rpc.Wallet} Wallet
             */
            Wallet.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Rpc.Wallet)
                    return object;
                return new $root.anytype.Rpc.Wallet();
            };

            /**
             * Creates a plain object from a Wallet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Rpc.Wallet
             * @static
             * @param {anytype.Rpc.Wallet} message Wallet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Wallet.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Wallet to JSON.
             * @function toJSON
             * @memberof anytype.Rpc.Wallet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Wallet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Wallet.Create = (function() {

                /**
                 * Properties of a Create.
                 * @memberof anytype.Rpc.Wallet
                 * @interface ICreate
                 */

                /**
                 * Constructs a new Create.
                 * @memberof anytype.Rpc.Wallet
                 * @classdesc Represents a Create.
                 * @implements ICreate
                 * @constructor
                 * @param {anytype.Rpc.Wallet.ICreate=} [properties] Properties to set
                 */
                function Create(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Create instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Wallet.Create
                 * @static
                 * @param {anytype.Rpc.Wallet.ICreate=} [properties] Properties to set
                 * @returns {anytype.Rpc.Wallet.Create} Create instance
                 */
                Create.create = function create(properties) {
                    return new Create(properties);
                };

                /**
                 * Encodes the specified Create message. Does not implicitly {@link anytype.Rpc.Wallet.Create.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Wallet.Create
                 * @static
                 * @param {anytype.Rpc.Wallet.ICreate} message Create message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Create.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Create message, length delimited. Does not implicitly {@link anytype.Rpc.Wallet.Create.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Wallet.Create
                 * @static
                 * @param {anytype.Rpc.Wallet.ICreate} message Create message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Create.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Create message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Wallet.Create
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Wallet.Create} Create
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Create.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Wallet.Create();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Create message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Wallet.Create
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Wallet.Create} Create
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Create.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Create message.
                 * @function verify
                 * @memberof anytype.Rpc.Wallet.Create
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Create.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Create message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Wallet.Create
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Wallet.Create} Create
                 */
                Create.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Wallet.Create)
                        return object;
                    return new $root.anytype.Rpc.Wallet.Create();
                };

                /**
                 * Creates a plain object from a Create message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Wallet.Create
                 * @static
                 * @param {anytype.Rpc.Wallet.Create} message Create
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Create.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Create to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Wallet.Create
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Create.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Create.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Wallet.Create
                     * @interface IRequest
                     * @property {string|null} [rootPath] Request rootPath
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Wallet.Create
                     * @classdesc Front-end-to-middleware request to create a new wallet
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Wallet.Create.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request rootPath.
                     * @member {string} rootPath
                     * @memberof anytype.Rpc.Wallet.Create.Request
                     * @instance
                     */
                    Request.prototype.rootPath = "";

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Wallet.Create.Request
                     * @static
                     * @param {anytype.Rpc.Wallet.Create.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Wallet.Create.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Wallet.Create.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Wallet.Create.Request
                     * @static
                     * @param {anytype.Rpc.Wallet.Create.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.rootPath != null && message.hasOwnProperty("rootPath"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.rootPath);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Wallet.Create.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Wallet.Create.Request
                     * @static
                     * @param {anytype.Rpc.Wallet.Create.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Wallet.Create.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Wallet.Create.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Wallet.Create.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.rootPath = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Wallet.Create.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Wallet.Create.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Wallet.Create.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.rootPath != null && message.hasOwnProperty("rootPath"))
                            if (!$util.isString(message.rootPath))
                                return "rootPath: string expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Wallet.Create.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Wallet.Create.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Wallet.Create.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Wallet.Create.Request();
                        if (object.rootPath != null)
                            message.rootPath = String(object.rootPath);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Wallet.Create.Request
                     * @static
                     * @param {anytype.Rpc.Wallet.Create.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.rootPath = "";
                        if (message.rootPath != null && message.hasOwnProperty("rootPath"))
                            object.rootPath = message.rootPath;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Wallet.Create.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Create.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Wallet.Create
                     * @interface IResponse
                     * @property {anytype.Rpc.Wallet.Create.Response.IError|null} [error] Response error
                     * @property {string|null} [mnemonic] Response mnemonic
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Wallet.Create
                     * @classdesc Middleware-to-front-end response, that can contain mnemonic of a created account and a NULL error or an empty mnemonic and a non-NULL error
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Wallet.Create.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Wallet.Create.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Wallet.Create.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Response mnemonic.
                     * @member {string} mnemonic
                     * @memberof anytype.Rpc.Wallet.Create.Response
                     * @instance
                     */
                    Response.prototype.mnemonic = "";

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Wallet.Create.Response
                     * @static
                     * @param {anytype.Rpc.Wallet.Create.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Wallet.Create.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Wallet.Create.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Wallet.Create.Response
                     * @static
                     * @param {anytype.Rpc.Wallet.Create.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Wallet.Create.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.mnemonic != null && message.hasOwnProperty("mnemonic"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.mnemonic);
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Wallet.Create.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Wallet.Create.Response
                     * @static
                     * @param {anytype.Rpc.Wallet.Create.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Wallet.Create.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Wallet.Create.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Wallet.Create.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Wallet.Create.Response.Error.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.mnemonic = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Wallet.Create.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Wallet.Create.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Wallet.Create.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Wallet.Create.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        if (message.mnemonic != null && message.hasOwnProperty("mnemonic"))
                            if (!$util.isString(message.mnemonic))
                                return "mnemonic: string expected";
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Wallet.Create.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Wallet.Create.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Wallet.Create.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Wallet.Create.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Wallet.Create.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Wallet.Create.Response.Error.fromObject(object.error);
                        }
                        if (object.mnemonic != null)
                            message.mnemonic = String(object.mnemonic);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Wallet.Create.Response
                     * @static
                     * @param {anytype.Rpc.Wallet.Create.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.error = null;
                            object.mnemonic = "";
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Wallet.Create.Response.Error.toObject(message.error, options);
                        if (message.mnemonic != null && message.hasOwnProperty("mnemonic"))
                            object.mnemonic = message.mnemonic;
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Wallet.Create.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Wallet.Create.Response
                         * @interface IError
                         * @property {anytype.Rpc.Wallet.Create.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Wallet.Create.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Wallet.Create.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Wallet.Create.Response.Error.Code} code
                         * @memberof anytype.Rpc.Wallet.Create.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Wallet.Create.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Wallet.Create.Response.Error
                         * @static
                         * @param {anytype.Rpc.Wallet.Create.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Wallet.Create.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Wallet.Create.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Wallet.Create.Response.Error
                         * @static
                         * @param {anytype.Rpc.Wallet.Create.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Wallet.Create.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Wallet.Create.Response.Error
                         * @static
                         * @param {anytype.Rpc.Wallet.Create.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Wallet.Create.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Wallet.Create.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Wallet.Create.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Wallet.Create.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Wallet.Create.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Wallet.Create.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 101:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Wallet.Create.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Wallet.Create.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Wallet.Create.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Wallet.Create.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            case "FAILED_TO_CREATE_LOCAL_REPO":
                            case 101:
                                message.code = 101;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Wallet.Create.Response.Error
                         * @static
                         * @param {anytype.Rpc.Wallet.Create.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Wallet.Create.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Wallet.Create.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Wallet.Create.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         * @property {number} FAILED_TO_CREATE_LOCAL_REPO=101 FAILED_TO_CREATE_LOCAL_REPO value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            values[valuesById[101] = "FAILED_TO_CREATE_LOCAL_REPO"] = 101;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Create;
            })();

            Wallet.Recover = (function() {

                /**
                 * Properties of a Recover.
                 * @memberof anytype.Rpc.Wallet
                 * @interface IRecover
                 */

                /**
                 * Constructs a new Recover.
                 * @memberof anytype.Rpc.Wallet
                 * @classdesc Represents a Recover.
                 * @implements IRecover
                 * @constructor
                 * @param {anytype.Rpc.Wallet.IRecover=} [properties] Properties to set
                 */
                function Recover(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Recover instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Wallet.Recover
                 * @static
                 * @param {anytype.Rpc.Wallet.IRecover=} [properties] Properties to set
                 * @returns {anytype.Rpc.Wallet.Recover} Recover instance
                 */
                Recover.create = function create(properties) {
                    return new Recover(properties);
                };

                /**
                 * Encodes the specified Recover message. Does not implicitly {@link anytype.Rpc.Wallet.Recover.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Wallet.Recover
                 * @static
                 * @param {anytype.Rpc.Wallet.IRecover} message Recover message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Recover.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Recover message, length delimited. Does not implicitly {@link anytype.Rpc.Wallet.Recover.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Wallet.Recover
                 * @static
                 * @param {anytype.Rpc.Wallet.IRecover} message Recover message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Recover.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Recover message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Wallet.Recover
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Wallet.Recover} Recover
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Recover.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Wallet.Recover();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Recover message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Wallet.Recover
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Wallet.Recover} Recover
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Recover.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Recover message.
                 * @function verify
                 * @memberof anytype.Rpc.Wallet.Recover
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Recover.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Recover message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Wallet.Recover
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Wallet.Recover} Recover
                 */
                Recover.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Wallet.Recover)
                        return object;
                    return new $root.anytype.Rpc.Wallet.Recover();
                };

                /**
                 * Creates a plain object from a Recover message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Wallet.Recover
                 * @static
                 * @param {anytype.Rpc.Wallet.Recover} message Recover
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Recover.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Recover to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Wallet.Recover
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Recover.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Recover.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Wallet.Recover
                     * @interface IRequest
                     * @property {string|null} [rootPath] Request rootPath
                     * @property {string|null} [mnemonic] Request mnemonic
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Wallet.Recover
                     * @classdesc Front end to middleware request-to-recover-a wallet with this mnemonic and a rootPath
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Wallet.Recover.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request rootPath.
                     * @member {string} rootPath
                     * @memberof anytype.Rpc.Wallet.Recover.Request
                     * @instance
                     */
                    Request.prototype.rootPath = "";

                    /**
                     * Request mnemonic.
                     * @member {string} mnemonic
                     * @memberof anytype.Rpc.Wallet.Recover.Request
                     * @instance
                     */
                    Request.prototype.mnemonic = "";

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Wallet.Recover.Request
                     * @static
                     * @param {anytype.Rpc.Wallet.Recover.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Wallet.Recover.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Wallet.Recover.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Wallet.Recover.Request
                     * @static
                     * @param {anytype.Rpc.Wallet.Recover.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.rootPath != null && message.hasOwnProperty("rootPath"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.rootPath);
                        if (message.mnemonic != null && message.hasOwnProperty("mnemonic"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.mnemonic);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Wallet.Recover.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Wallet.Recover.Request
                     * @static
                     * @param {anytype.Rpc.Wallet.Recover.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Wallet.Recover.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Wallet.Recover.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Wallet.Recover.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.rootPath = reader.string();
                                break;
                            case 2:
                                message.mnemonic = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Wallet.Recover.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Wallet.Recover.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Wallet.Recover.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.rootPath != null && message.hasOwnProperty("rootPath"))
                            if (!$util.isString(message.rootPath))
                                return "rootPath: string expected";
                        if (message.mnemonic != null && message.hasOwnProperty("mnemonic"))
                            if (!$util.isString(message.mnemonic))
                                return "mnemonic: string expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Wallet.Recover.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Wallet.Recover.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Wallet.Recover.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Wallet.Recover.Request();
                        if (object.rootPath != null)
                            message.rootPath = String(object.rootPath);
                        if (object.mnemonic != null)
                            message.mnemonic = String(object.mnemonic);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Wallet.Recover.Request
                     * @static
                     * @param {anytype.Rpc.Wallet.Recover.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.rootPath = "";
                            object.mnemonic = "";
                        }
                        if (message.rootPath != null && message.hasOwnProperty("rootPath"))
                            object.rootPath = message.rootPath;
                        if (message.mnemonic != null && message.hasOwnProperty("mnemonic"))
                            object.mnemonic = message.mnemonic;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Wallet.Recover.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Recover.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Wallet.Recover
                     * @interface IResponse
                     * @property {anytype.Rpc.Wallet.Recover.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Wallet.Recover
                     * @classdesc Middleware-to-front-end response, that can contain a NULL error or a non-NULL error
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Wallet.Recover.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Wallet.Recover.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Wallet.Recover.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Wallet.Recover.Response
                     * @static
                     * @param {anytype.Rpc.Wallet.Recover.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Wallet.Recover.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Wallet.Recover.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Wallet.Recover.Response
                     * @static
                     * @param {anytype.Rpc.Wallet.Recover.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Wallet.Recover.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Wallet.Recover.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Wallet.Recover.Response
                     * @static
                     * @param {anytype.Rpc.Wallet.Recover.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Wallet.Recover.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Wallet.Recover.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Wallet.Recover.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Wallet.Recover.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Wallet.Recover.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Wallet.Recover.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Wallet.Recover.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Wallet.Recover.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Wallet.Recover.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Wallet.Recover.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Wallet.Recover.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Wallet.Recover.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Wallet.Recover.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Wallet.Recover.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Wallet.Recover.Response
                     * @static
                     * @param {anytype.Rpc.Wallet.Recover.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Wallet.Recover.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Wallet.Recover.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Wallet.Recover.Response
                         * @interface IError
                         * @property {anytype.Rpc.Wallet.Recover.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Wallet.Recover.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Wallet.Recover.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Wallet.Recover.Response.Error.Code} code
                         * @memberof anytype.Rpc.Wallet.Recover.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Wallet.Recover.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Wallet.Recover.Response.Error
                         * @static
                         * @param {anytype.Rpc.Wallet.Recover.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Wallet.Recover.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Wallet.Recover.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Wallet.Recover.Response.Error
                         * @static
                         * @param {anytype.Rpc.Wallet.Recover.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Wallet.Recover.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Wallet.Recover.Response.Error
                         * @static
                         * @param {anytype.Rpc.Wallet.Recover.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Wallet.Recover.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Wallet.Recover.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Wallet.Recover.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Wallet.Recover.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Wallet.Recover.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Wallet.Recover.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 101:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Wallet.Recover.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Wallet.Recover.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Wallet.Recover.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Wallet.Recover.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            case "FAILED_TO_CREATE_LOCAL_REPO":
                            case 101:
                                message.code = 101;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Wallet.Recover.Response.Error
                         * @static
                         * @param {anytype.Rpc.Wallet.Recover.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Wallet.Recover.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Wallet.Recover.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Wallet.Recover.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         * @property {number} FAILED_TO_CREATE_LOCAL_REPO=101 FAILED_TO_CREATE_LOCAL_REPO value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            values[valuesById[101] = "FAILED_TO_CREATE_LOCAL_REPO"] = 101;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Recover;
            })();

            return Wallet;
        })();

        Rpc.Account = (function() {

            /**
             * Properties of an Account.
             * @memberof anytype.Rpc
             * @interface IAccount
             */

            /**
             * Constructs a new Account.
             * @memberof anytype.Rpc
             * @classdesc Represents an Account.
             * @implements IAccount
             * @constructor
             * @param {anytype.Rpc.IAccount=} [properties] Properties to set
             */
            function Account(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Account instance using the specified properties.
             * @function create
             * @memberof anytype.Rpc.Account
             * @static
             * @param {anytype.Rpc.IAccount=} [properties] Properties to set
             * @returns {anytype.Rpc.Account} Account instance
             */
            Account.create = function create(properties) {
                return new Account(properties);
            };

            /**
             * Encodes the specified Account message. Does not implicitly {@link anytype.Rpc.Account.verify|verify} messages.
             * @function encode
             * @memberof anytype.Rpc.Account
             * @static
             * @param {anytype.Rpc.IAccount} message Account message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Account.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Account message, length delimited. Does not implicitly {@link anytype.Rpc.Account.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Rpc.Account
             * @static
             * @param {anytype.Rpc.IAccount} message Account message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Account.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Account message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Rpc.Account
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Rpc.Account} Account
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Account.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Account message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Rpc.Account
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Rpc.Account} Account
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Account.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Account message.
             * @function verify
             * @memberof anytype.Rpc.Account
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Account.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Account message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Rpc.Account
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Rpc.Account} Account
             */
            Account.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Rpc.Account)
                    return object;
                return new $root.anytype.Rpc.Account();
            };

            /**
             * Creates a plain object from an Account message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Rpc.Account
             * @static
             * @param {anytype.Rpc.Account} message Account
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Account.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Account to JSON.
             * @function toJSON
             * @memberof anytype.Rpc.Account
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Account.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Account.Create = (function() {

                /**
                 * Properties of a Create.
                 * @memberof anytype.Rpc.Account
                 * @interface ICreate
                 */

                /**
                 * Constructs a new Create.
                 * @memberof anytype.Rpc.Account
                 * @classdesc Represents a Create.
                 * @implements ICreate
                 * @constructor
                 * @param {anytype.Rpc.Account.ICreate=} [properties] Properties to set
                 */
                function Create(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Create instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Account.Create
                 * @static
                 * @param {anytype.Rpc.Account.ICreate=} [properties] Properties to set
                 * @returns {anytype.Rpc.Account.Create} Create instance
                 */
                Create.create = function create(properties) {
                    return new Create(properties);
                };

                /**
                 * Encodes the specified Create message. Does not implicitly {@link anytype.Rpc.Account.Create.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Account.Create
                 * @static
                 * @param {anytype.Rpc.Account.ICreate} message Create message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Create.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Create message, length delimited. Does not implicitly {@link anytype.Rpc.Account.Create.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Account.Create
                 * @static
                 * @param {anytype.Rpc.Account.ICreate} message Create message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Create.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Create message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Account.Create
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Account.Create} Create
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Create.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account.Create();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Create message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Account.Create
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Account.Create} Create
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Create.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Create message.
                 * @function verify
                 * @memberof anytype.Rpc.Account.Create
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Create.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Create message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Account.Create
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Account.Create} Create
                 */
                Create.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Account.Create)
                        return object;
                    return new $root.anytype.Rpc.Account.Create();
                };

                /**
                 * Creates a plain object from a Create message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Account.Create
                 * @static
                 * @param {anytype.Rpc.Account.Create} message Create
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Create.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Create to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Account.Create
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Create.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Create.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Account.Create
                     * @interface IRequest
                     * @property {string|null} [name] Request name
                     * @property {string|null} [avatarLocalPath] Request avatarLocalPath
                     * @property {string|null} [avatarColor] Request avatarColor
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Account.Create
                     * @classdesc Front end to middleware request-to-create-an account
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Account.Create.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request name.
                     * @member {string} name
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @instance
                     */
                    Request.prototype.name = "";

                    /**
                     * Request avatarLocalPath.
                     * @member {string} avatarLocalPath
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @instance
                     */
                    Request.prototype.avatarLocalPath = "";

                    /**
                     * Request avatarColor.
                     * @member {string} avatarColor
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @instance
                     */
                    Request.prototype.avatarColor = "";

                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;

                    /**
                     * Request avatar.
                     * @member {"avatarLocalPath"|"avatarColor"|undefined} avatar
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @instance
                     */
                    Object.defineProperty(Request.prototype, "avatar", {
                        get: $util.oneOfGetter($oneOfFields = ["avatarLocalPath", "avatarColor"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @static
                     * @param {anytype.Rpc.Account.Create.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Account.Create.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Account.Create.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @static
                     * @param {anytype.Rpc.Account.Create.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        if (message.avatarLocalPath != null && message.hasOwnProperty("avatarLocalPath"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.avatarLocalPath);
                        if (message.avatarColor != null && message.hasOwnProperty("avatarColor"))
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarColor);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Account.Create.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @static
                     * @param {anytype.Rpc.Account.Create.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Account.Create.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account.Create.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            case 2:
                                message.avatarLocalPath = reader.string();
                                break;
                            case 3:
                                message.avatarColor = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Account.Create.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.avatarLocalPath != null && message.hasOwnProperty("avatarLocalPath")) {
                            properties.avatar = 1;
                            if (!$util.isString(message.avatarLocalPath))
                                return "avatarLocalPath: string expected";
                        }
                        if (message.avatarColor != null && message.hasOwnProperty("avatarColor")) {
                            if (properties.avatar === 1)
                                return "avatar: multiple values";
                            properties.avatar = 1;
                            if (!$util.isString(message.avatarColor))
                                return "avatarColor: string expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Account.Create.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Account.Create.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Account.Create.Request();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.avatarLocalPath != null)
                            message.avatarLocalPath = String(object.avatarLocalPath);
                        if (object.avatarColor != null)
                            message.avatarColor = String(object.avatarColor);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @static
                     * @param {anytype.Rpc.Account.Create.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.name = "";
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.avatarLocalPath != null && message.hasOwnProperty("avatarLocalPath")) {
                            object.avatarLocalPath = message.avatarLocalPath;
                            if (options.oneofs)
                                object.avatar = "avatarLocalPath";
                        }
                        if (message.avatarColor != null && message.hasOwnProperty("avatarColor")) {
                            object.avatarColor = message.avatarColor;
                            if (options.oneofs)
                                object.avatar = "avatarColor";
                        }
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Account.Create.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Create.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Account.Create
                     * @interface IResponse
                     * @property {anytype.Rpc.Account.Create.Response.IError|null} [error] Response error
                     * @property {anytype.model.IAccount|null} [account] Response account
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Account.Create
                     * @classdesc Middleware-to-front-end response for an account creation request, that can contain a NULL error and created account or a non-NULL error and an empty account
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Account.Create.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Account.Create.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Account.Create.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Response account.
                     * @member {anytype.model.IAccount|null|undefined} account
                     * @memberof anytype.Rpc.Account.Create.Response
                     * @instance
                     */
                    Response.prototype.account = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Account.Create.Response
                     * @static
                     * @param {anytype.Rpc.Account.Create.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Account.Create.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Account.Create.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Account.Create.Response
                     * @static
                     * @param {anytype.Rpc.Account.Create.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Account.Create.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.account != null && message.hasOwnProperty("account"))
                            $root.anytype.model.Account.encode(message.account, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Account.Create.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Account.Create.Response
                     * @static
                     * @param {anytype.Rpc.Account.Create.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Account.Create.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Account.Create.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account.Create.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Account.Create.Response.Error.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.account = $root.anytype.model.Account.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Account.Create.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Account.Create.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Account.Create.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Account.Create.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        if (message.account != null && message.hasOwnProperty("account")) {
                            var error = $root.anytype.model.Account.verify(message.account);
                            if (error)
                                return "account." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Account.Create.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Account.Create.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Account.Create.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Account.Create.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Account.Create.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Account.Create.Response.Error.fromObject(object.error);
                        }
                        if (object.account != null) {
                            if (typeof object.account !== "object")
                                throw TypeError(".anytype.Rpc.Account.Create.Response.account: object expected");
                            message.account = $root.anytype.model.Account.fromObject(object.account);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Account.Create.Response
                     * @static
                     * @param {anytype.Rpc.Account.Create.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.error = null;
                            object.account = null;
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Account.Create.Response.Error.toObject(message.error, options);
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = $root.anytype.model.Account.toObject(message.account, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Account.Create.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Account.Create.Response
                         * @interface IError
                         * @property {anytype.Rpc.Account.Create.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Account.Create.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Account.Create.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Account.Create.Response.Error.Code} code
                         * @memberof anytype.Rpc.Account.Create.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Account.Create.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Account.Create.Response.Error
                         * @static
                         * @param {anytype.Rpc.Account.Create.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Account.Create.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Account.Create.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Account.Create.Response.Error
                         * @static
                         * @param {anytype.Rpc.Account.Create.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Account.Create.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Account.Create.Response.Error
                         * @static
                         * @param {anytype.Rpc.Account.Create.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Account.Create.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Account.Create.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account.Create.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Account.Create.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Account.Create.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Account.Create.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 101:
                                case 102:
                                case 103:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Account.Create.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Account.Create.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Account.Create.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Account.Create.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            case "ACCOUNT_CREATED_BUT_FAILED_TO_START_NODE":
                            case 101:
                                message.code = 101;
                                break;
                            case "ACCOUNT_CREATED_BUT_FAILED_TO_SET_NAME":
                            case 102:
                                message.code = 102;
                                break;
                            case "ACCOUNT_CREATED_BUT_FAILED_TO_SET_AVATAR":
                            case 103:
                                message.code = 103;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Account.Create.Response.Error
                         * @static
                         * @param {anytype.Rpc.Account.Create.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Account.Create.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Account.Create.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Account.Create.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         * @property {number} ACCOUNT_CREATED_BUT_FAILED_TO_START_NODE=101 ACCOUNT_CREATED_BUT_FAILED_TO_START_NODE value
                         * @property {number} ACCOUNT_CREATED_BUT_FAILED_TO_SET_NAME=102 ACCOUNT_CREATED_BUT_FAILED_TO_SET_NAME value
                         * @property {number} ACCOUNT_CREATED_BUT_FAILED_TO_SET_AVATAR=103 ACCOUNT_CREATED_BUT_FAILED_TO_SET_AVATAR value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            values[valuesById[101] = "ACCOUNT_CREATED_BUT_FAILED_TO_START_NODE"] = 101;
                            values[valuesById[102] = "ACCOUNT_CREATED_BUT_FAILED_TO_SET_NAME"] = 102;
                            values[valuesById[103] = "ACCOUNT_CREATED_BUT_FAILED_TO_SET_AVATAR"] = 103;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Create;
            })();

            Account.Recover = (function() {

                /**
                 * Properties of a Recover.
                 * @memberof anytype.Rpc.Account
                 * @interface IRecover
                 */

                /**
                 * Constructs a new Recover.
                 * @memberof anytype.Rpc.Account
                 * @classdesc Represents a Recover.
                 * @implements IRecover
                 * @constructor
                 * @param {anytype.Rpc.Account.IRecover=} [properties] Properties to set
                 */
                function Recover(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Recover instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Account.Recover
                 * @static
                 * @param {anytype.Rpc.Account.IRecover=} [properties] Properties to set
                 * @returns {anytype.Rpc.Account.Recover} Recover instance
                 */
                Recover.create = function create(properties) {
                    return new Recover(properties);
                };

                /**
                 * Encodes the specified Recover message. Does not implicitly {@link anytype.Rpc.Account.Recover.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Account.Recover
                 * @static
                 * @param {anytype.Rpc.Account.IRecover} message Recover message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Recover.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Recover message, length delimited. Does not implicitly {@link anytype.Rpc.Account.Recover.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Account.Recover
                 * @static
                 * @param {anytype.Rpc.Account.IRecover} message Recover message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Recover.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Recover message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Account.Recover
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Account.Recover} Recover
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Recover.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account.Recover();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Recover message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Account.Recover
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Account.Recover} Recover
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Recover.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Recover message.
                 * @function verify
                 * @memberof anytype.Rpc.Account.Recover
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Recover.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Recover message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Account.Recover
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Account.Recover} Recover
                 */
                Recover.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Account.Recover)
                        return object;
                    return new $root.anytype.Rpc.Account.Recover();
                };

                /**
                 * Creates a plain object from a Recover message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Account.Recover
                 * @static
                 * @param {anytype.Rpc.Account.Recover} message Recover
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Recover.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Recover to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Account.Recover
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Recover.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Recover.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Account.Recover
                     * @interface IRequest
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Account.Recover
                     * @classdesc Front end to middleware request-to-start-search of an accounts for a recovered mnemonic.
                     * Each of an account that would be found will come with an AccountAdd event
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Account.Recover.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Account.Recover.Request
                     * @static
                     * @param {anytype.Rpc.Account.Recover.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Account.Recover.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Account.Recover.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Account.Recover.Request
                     * @static
                     * @param {anytype.Rpc.Account.Recover.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Account.Recover.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Account.Recover.Request
                     * @static
                     * @param {anytype.Rpc.Account.Recover.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Account.Recover.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Account.Recover.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account.Recover.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Account.Recover.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Account.Recover.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Account.Recover.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Account.Recover.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Account.Recover.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Account.Recover.Request)
                            return object;
                        return new $root.anytype.Rpc.Account.Recover.Request();
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Account.Recover.Request
                     * @static
                     * @param {anytype.Rpc.Account.Recover.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Account.Recover.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Recover.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Account.Recover
                     * @interface IResponse
                     * @property {anytype.Rpc.Account.Recover.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Account.Recover
                     * @classdesc Middleware-to-front-end response to an account recover request, that can contain a NULL error and created account or a non-NULL error and an empty account
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Account.Recover.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Account.Recover.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Account.Recover.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Account.Recover.Response
                     * @static
                     * @param {anytype.Rpc.Account.Recover.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Account.Recover.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Account.Recover.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Account.Recover.Response
                     * @static
                     * @param {anytype.Rpc.Account.Recover.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Account.Recover.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Account.Recover.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Account.Recover.Response
                     * @static
                     * @param {anytype.Rpc.Account.Recover.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Account.Recover.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Account.Recover.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account.Recover.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Account.Recover.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Account.Recover.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Account.Recover.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Account.Recover.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Account.Recover.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Account.Recover.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Account.Recover.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Account.Recover.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Account.Recover.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Account.Recover.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Account.Recover.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Account.Recover.Response
                     * @static
                     * @param {anytype.Rpc.Account.Recover.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Account.Recover.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Account.Recover.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Account.Recover.Response
                         * @interface IError
                         * @property {anytype.Rpc.Account.Recover.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Account.Recover.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Account.Recover.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Account.Recover.Response.Error.Code} code
                         * @memberof anytype.Rpc.Account.Recover.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Account.Recover.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Account.Recover.Response.Error
                         * @static
                         * @param {anytype.Rpc.Account.Recover.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Account.Recover.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Account.Recover.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Account.Recover.Response.Error
                         * @static
                         * @param {anytype.Rpc.Account.Recover.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Account.Recover.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Account.Recover.Response.Error
                         * @static
                         * @param {anytype.Rpc.Account.Recover.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Account.Recover.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Account.Recover.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account.Recover.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Account.Recover.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Account.Recover.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Account.Recover.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 101:
                                case 102:
                                case 103:
                                case 104:
                                case 105:
                                case 106:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Account.Recover.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Account.Recover.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Account.Recover.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Account.Recover.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            case "NO_ACCOUNTS_FOUND":
                            case 101:
                                message.code = 101;
                                break;
                            case "NEED_TO_RECOVER_WALLET_FIRST":
                            case 102:
                                message.code = 102;
                                break;
                            case "FAILED_TO_CREATE_LOCAL_REPO":
                            case 103:
                                message.code = 103;
                                break;
                            case "LOCAL_REPO_EXISTS_BUT_CORRUPTED":
                            case 104:
                                message.code = 104;
                                break;
                            case "FAILED_TO_RUN_NODE":
                            case 105:
                                message.code = 105;
                                break;
                            case "WALLET_RECOVER_NOT_PERFORMED":
                            case 106:
                                message.code = 106;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Account.Recover.Response.Error
                         * @static
                         * @param {anytype.Rpc.Account.Recover.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Account.Recover.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Account.Recover.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Account.Recover.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         * @property {number} NO_ACCOUNTS_FOUND=101 NO_ACCOUNTS_FOUND value
                         * @property {number} NEED_TO_RECOVER_WALLET_FIRST=102 NEED_TO_RECOVER_WALLET_FIRST value
                         * @property {number} FAILED_TO_CREATE_LOCAL_REPO=103 FAILED_TO_CREATE_LOCAL_REPO value
                         * @property {number} LOCAL_REPO_EXISTS_BUT_CORRUPTED=104 LOCAL_REPO_EXISTS_BUT_CORRUPTED value
                         * @property {number} FAILED_TO_RUN_NODE=105 FAILED_TO_RUN_NODE value
                         * @property {number} WALLET_RECOVER_NOT_PERFORMED=106 WALLET_RECOVER_NOT_PERFORMED value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            values[valuesById[101] = "NO_ACCOUNTS_FOUND"] = 101;
                            values[valuesById[102] = "NEED_TO_RECOVER_WALLET_FIRST"] = 102;
                            values[valuesById[103] = "FAILED_TO_CREATE_LOCAL_REPO"] = 103;
                            values[valuesById[104] = "LOCAL_REPO_EXISTS_BUT_CORRUPTED"] = 104;
                            values[valuesById[105] = "FAILED_TO_RUN_NODE"] = 105;
                            values[valuesById[106] = "WALLET_RECOVER_NOT_PERFORMED"] = 106;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Recover;
            })();

            Account.Select = (function() {

                /**
                 * Properties of a Select.
                 * @memberof anytype.Rpc.Account
                 * @interface ISelect
                 */

                /**
                 * Constructs a new Select.
                 * @memberof anytype.Rpc.Account
                 * @classdesc Represents a Select.
                 * @implements ISelect
                 * @constructor
                 * @param {anytype.Rpc.Account.ISelect=} [properties] Properties to set
                 */
                function Select(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Select instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Account.Select
                 * @static
                 * @param {anytype.Rpc.Account.ISelect=} [properties] Properties to set
                 * @returns {anytype.Rpc.Account.Select} Select instance
                 */
                Select.create = function create(properties) {
                    return new Select(properties);
                };

                /**
                 * Encodes the specified Select message. Does not implicitly {@link anytype.Rpc.Account.Select.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Account.Select
                 * @static
                 * @param {anytype.Rpc.Account.ISelect} message Select message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Select.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Select message, length delimited. Does not implicitly {@link anytype.Rpc.Account.Select.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Account.Select
                 * @static
                 * @param {anytype.Rpc.Account.ISelect} message Select message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Select.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Select message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Account.Select
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Account.Select} Select
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Select.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account.Select();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Select message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Account.Select
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Account.Select} Select
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Select.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Select message.
                 * @function verify
                 * @memberof anytype.Rpc.Account.Select
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Select.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Select message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Account.Select
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Account.Select} Select
                 */
                Select.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Account.Select)
                        return object;
                    return new $root.anytype.Rpc.Account.Select();
                };

                /**
                 * Creates a plain object from a Select message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Account.Select
                 * @static
                 * @param {anytype.Rpc.Account.Select} message Select
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Select.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Select to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Account.Select
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Select.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Select.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Account.Select
                     * @interface IRequest
                     * @property {string|null} [id] Request id
                     * @property {string|null} [rootPath] Request rootPath
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Account.Select
                     * @classdesc Front end to middleware request-to-launch-a specific account using account id and a root path
                     * User can select an account from those, that came with an AccountAdd events
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Account.Select.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request id.
                     * @member {string} id
                     * @memberof anytype.Rpc.Account.Select.Request
                     * @instance
                     */
                    Request.prototype.id = "";

                    /**
                     * Request rootPath.
                     * @member {string} rootPath
                     * @memberof anytype.Rpc.Account.Select.Request
                     * @instance
                     */
                    Request.prototype.rootPath = "";

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Account.Select.Request
                     * @static
                     * @param {anytype.Rpc.Account.Select.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Account.Select.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Account.Select.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Account.Select.Request
                     * @static
                     * @param {anytype.Rpc.Account.Select.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.rootPath != null && message.hasOwnProperty("rootPath"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.rootPath);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Account.Select.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Account.Select.Request
                     * @static
                     * @param {anytype.Rpc.Account.Select.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Account.Select.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Account.Select.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account.Select.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                message.rootPath = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Account.Select.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Account.Select.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Account.Select.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.rootPath != null && message.hasOwnProperty("rootPath"))
                            if (!$util.isString(message.rootPath))
                                return "rootPath: string expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Account.Select.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Account.Select.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Account.Select.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Account.Select.Request();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.rootPath != null)
                            message.rootPath = String(object.rootPath);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Account.Select.Request
                     * @static
                     * @param {anytype.Rpc.Account.Select.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.rootPath = "";
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.rootPath != null && message.hasOwnProperty("rootPath"))
                            object.rootPath = message.rootPath;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Account.Select.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Select.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Account.Select
                     * @interface IResponse
                     * @property {anytype.Rpc.Account.Select.Response.IError|null} [error] Response error
                     * @property {anytype.model.IAccount|null} [account] Response account
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Account.Select
                     * @classdesc Middleware-to-front-end response for an account select request, that can contain a NULL error and selected account or a non-NULL error and an empty account
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Account.Select.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Account.Select.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Account.Select.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Response account.
                     * @member {anytype.model.IAccount|null|undefined} account
                     * @memberof anytype.Rpc.Account.Select.Response
                     * @instance
                     */
                    Response.prototype.account = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Account.Select.Response
                     * @static
                     * @param {anytype.Rpc.Account.Select.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Account.Select.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Account.Select.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Account.Select.Response
                     * @static
                     * @param {anytype.Rpc.Account.Select.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Account.Select.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.account != null && message.hasOwnProperty("account"))
                            $root.anytype.model.Account.encode(message.account, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Account.Select.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Account.Select.Response
                     * @static
                     * @param {anytype.Rpc.Account.Select.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Account.Select.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Account.Select.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account.Select.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Account.Select.Response.Error.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.account = $root.anytype.model.Account.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Account.Select.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Account.Select.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Account.Select.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Account.Select.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        if (message.account != null && message.hasOwnProperty("account")) {
                            var error = $root.anytype.model.Account.verify(message.account);
                            if (error)
                                return "account." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Account.Select.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Account.Select.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Account.Select.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Account.Select.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Account.Select.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Account.Select.Response.Error.fromObject(object.error);
                        }
                        if (object.account != null) {
                            if (typeof object.account !== "object")
                                throw TypeError(".anytype.Rpc.Account.Select.Response.account: object expected");
                            message.account = $root.anytype.model.Account.fromObject(object.account);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Account.Select.Response
                     * @static
                     * @param {anytype.Rpc.Account.Select.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.error = null;
                            object.account = null;
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Account.Select.Response.Error.toObject(message.error, options);
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = $root.anytype.model.Account.toObject(message.account, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Account.Select.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Account.Select.Response
                         * @interface IError
                         * @property {anytype.Rpc.Account.Select.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Account.Select.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Account.Select.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Account.Select.Response.Error.Code} code
                         * @memberof anytype.Rpc.Account.Select.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Account.Select.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Account.Select.Response.Error
                         * @static
                         * @param {anytype.Rpc.Account.Select.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Account.Select.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Account.Select.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Account.Select.Response.Error
                         * @static
                         * @param {anytype.Rpc.Account.Select.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Account.Select.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Account.Select.Response.Error
                         * @static
                         * @param {anytype.Rpc.Account.Select.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Account.Select.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Account.Select.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Account.Select.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Account.Select.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Account.Select.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Account.Select.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 101:
                                case 102:
                                case 103:
                                case 104:
                                case 105:
                                case 106:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Account.Select.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Account.Select.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Account.Select.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Account.Select.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            case "FAILED_TO_CREATE_LOCAL_REPO":
                            case 101:
                                message.code = 101;
                                break;
                            case "LOCAL_REPO_EXISTS_BUT_CORRUPTED":
                            case 102:
                                message.code = 102;
                                break;
                            case "FAILED_TO_RUN_NODE":
                            case 103:
                                message.code = 103;
                                break;
                            case "FAILED_TO_FIND_ACCOUNT_INFO":
                            case 104:
                                message.code = 104;
                                break;
                            case "LOCAL_REPO_NOT_EXISTS_AND_MNEMONIC_NOT_SET":
                            case 105:
                                message.code = 105;
                                break;
                            case "FAILED_TO_STOP_SEARCHER_NODE":
                            case 106:
                                message.code = 106;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Account.Select.Response.Error
                         * @static
                         * @param {anytype.Rpc.Account.Select.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Account.Select.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Account.Select.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Account.Select.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         * @property {number} FAILED_TO_CREATE_LOCAL_REPO=101 FAILED_TO_CREATE_LOCAL_REPO value
                         * @property {number} LOCAL_REPO_EXISTS_BUT_CORRUPTED=102 LOCAL_REPO_EXISTS_BUT_CORRUPTED value
                         * @property {number} FAILED_TO_RUN_NODE=103 FAILED_TO_RUN_NODE value
                         * @property {number} FAILED_TO_FIND_ACCOUNT_INFO=104 FAILED_TO_FIND_ACCOUNT_INFO value
                         * @property {number} LOCAL_REPO_NOT_EXISTS_AND_MNEMONIC_NOT_SET=105 LOCAL_REPO_NOT_EXISTS_AND_MNEMONIC_NOT_SET value
                         * @property {number} FAILED_TO_STOP_SEARCHER_NODE=106 FAILED_TO_STOP_SEARCHER_NODE value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            values[valuesById[101] = "FAILED_TO_CREATE_LOCAL_REPO"] = 101;
                            values[valuesById[102] = "LOCAL_REPO_EXISTS_BUT_CORRUPTED"] = 102;
                            values[valuesById[103] = "FAILED_TO_RUN_NODE"] = 103;
                            values[valuesById[104] = "FAILED_TO_FIND_ACCOUNT_INFO"] = 104;
                            values[valuesById[105] = "LOCAL_REPO_NOT_EXISTS_AND_MNEMONIC_NOT_SET"] = 105;
                            values[valuesById[106] = "FAILED_TO_STOP_SEARCHER_NODE"] = 106;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Select;
            })();

            return Account;
        })();

        Rpc.Log = (function() {

            /**
             * Properties of a Log.
             * @memberof anytype.Rpc
             * @interface ILog
             */

            /**
             * Constructs a new Log.
             * @memberof anytype.Rpc
             * @classdesc Represents a Log.
             * @implements ILog
             * @constructor
             * @param {anytype.Rpc.ILog=} [properties] Properties to set
             */
            function Log(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Log instance using the specified properties.
             * @function create
             * @memberof anytype.Rpc.Log
             * @static
             * @param {anytype.Rpc.ILog=} [properties] Properties to set
             * @returns {anytype.Rpc.Log} Log instance
             */
            Log.create = function create(properties) {
                return new Log(properties);
            };

            /**
             * Encodes the specified Log message. Does not implicitly {@link anytype.Rpc.Log.verify|verify} messages.
             * @function encode
             * @memberof anytype.Rpc.Log
             * @static
             * @param {anytype.Rpc.ILog} message Log message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Log.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Log message, length delimited. Does not implicitly {@link anytype.Rpc.Log.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Rpc.Log
             * @static
             * @param {anytype.Rpc.ILog} message Log message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Log.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Log message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Rpc.Log
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Rpc.Log} Log
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Log.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Log();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Log message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Rpc.Log
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Rpc.Log} Log
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Log.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Log message.
             * @function verify
             * @memberof anytype.Rpc.Log
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Log.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Log message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Rpc.Log
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Rpc.Log} Log
             */
            Log.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Rpc.Log)
                    return object;
                return new $root.anytype.Rpc.Log();
            };

            /**
             * Creates a plain object from a Log message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Rpc.Log
             * @static
             * @param {anytype.Rpc.Log} message Log
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Log.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Log to JSON.
             * @function toJSON
             * @memberof anytype.Rpc.Log
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Log.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Log.Send = (function() {

                /**
                 * Properties of a Send.
                 * @memberof anytype.Rpc.Log
                 * @interface ISend
                 */

                /**
                 * Constructs a new Send.
                 * @memberof anytype.Rpc.Log
                 * @classdesc Represents a Send.
                 * @implements ISend
                 * @constructor
                 * @param {anytype.Rpc.Log.ISend=} [properties] Properties to set
                 */
                function Send(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Send instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Log.Send
                 * @static
                 * @param {anytype.Rpc.Log.ISend=} [properties] Properties to set
                 * @returns {anytype.Rpc.Log.Send} Send instance
                 */
                Send.create = function create(properties) {
                    return new Send(properties);
                };

                /**
                 * Encodes the specified Send message. Does not implicitly {@link anytype.Rpc.Log.Send.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Log.Send
                 * @static
                 * @param {anytype.Rpc.Log.ISend} message Send message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Send.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Send message, length delimited. Does not implicitly {@link anytype.Rpc.Log.Send.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Log.Send
                 * @static
                 * @param {anytype.Rpc.Log.ISend} message Send message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Send.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Send message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Log.Send
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Log.Send} Send
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Send.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Log.Send();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Send message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Log.Send
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Log.Send} Send
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Send.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Send message.
                 * @function verify
                 * @memberof anytype.Rpc.Log.Send
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Send.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Send message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Log.Send
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Log.Send} Send
                 */
                Send.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Log.Send)
                        return object;
                    return new $root.anytype.Rpc.Log.Send();
                };

                /**
                 * Creates a plain object from a Send message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Log.Send
                 * @static
                 * @param {anytype.Rpc.Log.Send} message Send
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Send.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Send to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Log.Send
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Send.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Send.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Log.Send
                     * @interface IRequest
                     * @property {string|null} [message] Request message
                     * @property {anytype.Rpc.Log.Send.Request.Level|null} [level] Request level
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Log.Send
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Log.Send.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Request message.
                     * @member {string} message
                     * @memberof anytype.Rpc.Log.Send.Request
                     * @instance
                     */
                    Request.prototype.message = "";

                    /**
                     * Request level.
                     * @member {anytype.Rpc.Log.Send.Request.Level} level
                     * @memberof anytype.Rpc.Log.Send.Request
                     * @instance
                     */
                    Request.prototype.level = 0;

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Log.Send.Request
                     * @static
                     * @param {anytype.Rpc.Log.Send.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Log.Send.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Log.Send.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Log.Send.Request
                     * @static
                     * @param {anytype.Rpc.Log.Send.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.message != null && message.hasOwnProperty("message"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
                        if (message.level != null && message.hasOwnProperty("level"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Log.Send.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Log.Send.Request
                     * @static
                     * @param {anytype.Rpc.Log.Send.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Log.Send.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Log.Send.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Log.Send.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.message = reader.string();
                                break;
                            case 2:
                                message.level = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Log.Send.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Log.Send.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Log.Send.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.message != null && message.hasOwnProperty("message"))
                            if (!$util.isString(message.message))
                                return "message: string expected";
                        if (message.level != null && message.hasOwnProperty("level"))
                            switch (message.level) {
                            default:
                                return "level: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Log.Send.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Log.Send.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Log.Send.Request)
                            return object;
                        var message = new $root.anytype.Rpc.Log.Send.Request();
                        if (object.message != null)
                            message.message = String(object.message);
                        switch (object.level) {
                        case "DEBUG":
                        case 0:
                            message.level = 0;
                            break;
                        case "ERROR":
                        case 1:
                            message.level = 1;
                            break;
                        case "FATAL":
                        case 2:
                            message.level = 2;
                            break;
                        case "INFO":
                        case 3:
                            message.level = 3;
                            break;
                        case "PANIC":
                        case 4:
                            message.level = 4;
                            break;
                        case "WARNING":
                        case 5:
                            message.level = 5;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Log.Send.Request
                     * @static
                     * @param {anytype.Rpc.Log.Send.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.message = "";
                            object.level = options.enums === String ? "DEBUG" : 0;
                        }
                        if (message.message != null && message.hasOwnProperty("message"))
                            object.message = message.message;
                        if (message.level != null && message.hasOwnProperty("level"))
                            object.level = options.enums === String ? $root.anytype.Rpc.Log.Send.Request.Level[message.level] : message.level;
                        return object;
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Log.Send.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Level enum.
                     * @name anytype.Rpc.Log.Send.Request.Level
                     * @enum {string}
                     * @property {number} DEBUG=0 DEBUG value
                     * @property {number} ERROR=1 ERROR value
                     * @property {number} FATAL=2 FATAL value
                     * @property {number} INFO=3 INFO value
                     * @property {number} PANIC=4 PANIC value
                     * @property {number} WARNING=5 WARNING value
                     */
                    Request.Level = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "DEBUG"] = 0;
                        values[valuesById[1] = "ERROR"] = 1;
                        values[valuesById[2] = "FATAL"] = 2;
                        values[valuesById[3] = "INFO"] = 3;
                        values[valuesById[4] = "PANIC"] = 4;
                        values[valuesById[5] = "WARNING"] = 5;
                        return values;
                    })();

                    return Request;
                })();

                Send.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Log.Send
                     * @interface IResponse
                     * @property {anytype.Rpc.Log.Send.Response.IError|null} [error] Response error
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Log.Send
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Log.Send.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Log.Send.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Log.Send.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Log.Send.Response
                     * @static
                     * @param {anytype.Rpc.Log.Send.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Log.Send.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Log.Send.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Log.Send.Response
                     * @static
                     * @param {anytype.Rpc.Log.Send.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Log.Send.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Log.Send.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Log.Send.Response
                     * @static
                     * @param {anytype.Rpc.Log.Send.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Log.Send.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Log.Send.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Log.Send.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Log.Send.Response.Error.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Log.Send.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Log.Send.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Log.Send.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Log.Send.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Log.Send.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Log.Send.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Log.Send.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Log.Send.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Log.Send.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Log.Send.Response.Error.fromObject(object.error);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Log.Send.Response
                     * @static
                     * @param {anytype.Rpc.Log.Send.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.error = null;
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Log.Send.Response.Error.toObject(message.error, options);
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Log.Send.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Log.Send.Response
                         * @interface IError
                         * @property {anytype.Rpc.Log.Send.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Log.Send.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Log.Send.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Log.Send.Response.Error.Code} code
                         * @memberof anytype.Rpc.Log.Send.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Log.Send.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Log.Send.Response.Error
                         * @static
                         * @param {anytype.Rpc.Log.Send.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Log.Send.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Log.Send.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Log.Send.Response.Error
                         * @static
                         * @param {anytype.Rpc.Log.Send.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Log.Send.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Log.Send.Response.Error
                         * @static
                         * @param {anytype.Rpc.Log.Send.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Log.Send.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Log.Send.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Log.Send.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Log.Send.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Log.Send.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Log.Send.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 101:
                                case 102:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Log.Send.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Log.Send.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Log.Send.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Log.Send.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            case "NOT_FOUND":
                            case 101:
                                message.code = 101;
                                break;
                            case "TIMEOUT":
                            case 102:
                                message.code = 102;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Log.Send.Response.Error
                         * @static
                         * @param {anytype.Rpc.Log.Send.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Log.Send.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Log.Send.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Log.Send.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         * @property {number} NOT_FOUND=101 NOT_FOUND value
                         * @property {number} TIMEOUT=102 TIMEOUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            values[valuesById[101] = "NOT_FOUND"] = 101;
                            values[valuesById[102] = "TIMEOUT"] = 102;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Send;
            })();

            return Log;
        })();

        Rpc.Version = (function() {

            /**
             * Properties of a Version.
             * @memberof anytype.Rpc
             * @interface IVersion
             */

            /**
             * Constructs a new Version.
             * @memberof anytype.Rpc
             * @classdesc Represents a Version.
             * @implements IVersion
             * @constructor
             * @param {anytype.Rpc.IVersion=} [properties] Properties to set
             */
            function Version(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Version instance using the specified properties.
             * @function create
             * @memberof anytype.Rpc.Version
             * @static
             * @param {anytype.Rpc.IVersion=} [properties] Properties to set
             * @returns {anytype.Rpc.Version} Version instance
             */
            Version.create = function create(properties) {
                return new Version(properties);
            };

            /**
             * Encodes the specified Version message. Does not implicitly {@link anytype.Rpc.Version.verify|verify} messages.
             * @function encode
             * @memberof anytype.Rpc.Version
             * @static
             * @param {anytype.Rpc.IVersion} message Version message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Version.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Version message, length delimited. Does not implicitly {@link anytype.Rpc.Version.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Rpc.Version
             * @static
             * @param {anytype.Rpc.IVersion} message Version message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Version.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Version message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Rpc.Version
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Rpc.Version} Version
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Version.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Version();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Version message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Rpc.Version
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Rpc.Version} Version
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Version.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Version message.
             * @function verify
             * @memberof anytype.Rpc.Version
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Version.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Version message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Rpc.Version
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Rpc.Version} Version
             */
            Version.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Rpc.Version)
                    return object;
                return new $root.anytype.Rpc.Version();
            };

            /**
             * Creates a plain object from a Version message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Rpc.Version
             * @static
             * @param {anytype.Rpc.Version} message Version
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Version.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Version to JSON.
             * @function toJSON
             * @memberof anytype.Rpc.Version
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Version.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Version.Get = (function() {

                /**
                 * Properties of a Get.
                 * @memberof anytype.Rpc.Version
                 * @interface IGet
                 */

                /**
                 * Constructs a new Get.
                 * @memberof anytype.Rpc.Version
                 * @classdesc Represents a Get.
                 * @implements IGet
                 * @constructor
                 * @param {anytype.Rpc.Version.IGet=} [properties] Properties to set
                 */
                function Get(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Get instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Version.Get
                 * @static
                 * @param {anytype.Rpc.Version.IGet=} [properties] Properties to set
                 * @returns {anytype.Rpc.Version.Get} Get instance
                 */
                Get.create = function create(properties) {
                    return new Get(properties);
                };

                /**
                 * Encodes the specified Get message. Does not implicitly {@link anytype.Rpc.Version.Get.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Version.Get
                 * @static
                 * @param {anytype.Rpc.Version.IGet} message Get message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Get.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Get message, length delimited. Does not implicitly {@link anytype.Rpc.Version.Get.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Version.Get
                 * @static
                 * @param {anytype.Rpc.Version.IGet} message Get message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Get.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Get message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Version.Get
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Version.Get} Get
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Get.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Version.Get();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Get message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Version.Get
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Version.Get} Get
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Get.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Get message.
                 * @function verify
                 * @memberof anytype.Rpc.Version.Get
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Get.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Get message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Version.Get
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Version.Get} Get
                 */
                Get.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Version.Get)
                        return object;
                    return new $root.anytype.Rpc.Version.Get();
                };

                /**
                 * Creates a plain object from a Get message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Version.Get
                 * @static
                 * @param {anytype.Rpc.Version.Get} message Get
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Get.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Get to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Version.Get
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Get.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Get.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Version.Get
                     * @interface IRequest
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Version.Get
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Version.Get.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Version.Get.Request
                     * @static
                     * @param {anytype.Rpc.Version.Get.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Version.Get.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Version.Get.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Version.Get.Request
                     * @static
                     * @param {anytype.Rpc.Version.Get.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Version.Get.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Version.Get.Request
                     * @static
                     * @param {anytype.Rpc.Version.Get.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Version.Get.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Version.Get.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Version.Get.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Version.Get.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Version.Get.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Version.Get.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Version.Get.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Version.Get.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Version.Get.Request)
                            return object;
                        return new $root.anytype.Rpc.Version.Get.Request();
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Version.Get.Request
                     * @static
                     * @param {anytype.Rpc.Version.Get.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Version.Get.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Get.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Version.Get
                     * @interface IResponse
                     * @property {anytype.Rpc.Version.Get.Response.IError|null} [error] Response error
                     * @property {string|null} [version] Response version
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Version.Get
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Version.Get.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Version.Get.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Version.Get.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Response version.
                     * @member {string} version
                     * @memberof anytype.Rpc.Version.Get.Response
                     * @instance
                     */
                    Response.prototype.version = "";

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Version.Get.Response
                     * @static
                     * @param {anytype.Rpc.Version.Get.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Version.Get.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Version.Get.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Version.Get.Response
                     * @static
                     * @param {anytype.Rpc.Version.Get.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Version.Get.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.version != null && message.hasOwnProperty("version"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.version);
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Version.Get.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Version.Get.Response
                     * @static
                     * @param {anytype.Rpc.Version.Get.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Version.Get.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Version.Get.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Version.Get.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Version.Get.Response.Error.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.version = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Version.Get.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Version.Get.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Version.Get.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Version.Get.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        if (message.version != null && message.hasOwnProperty("version"))
                            if (!$util.isString(message.version))
                                return "version: string expected";
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Version.Get.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Version.Get.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Version.Get.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Version.Get.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Version.Get.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Version.Get.Response.Error.fromObject(object.error);
                        }
                        if (object.version != null)
                            message.version = String(object.version);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Version.Get.Response
                     * @static
                     * @param {anytype.Rpc.Version.Get.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.error = null;
                            object.version = "";
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Version.Get.Response.Error.toObject(message.error, options);
                        if (message.version != null && message.hasOwnProperty("version"))
                            object.version = message.version;
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Version.Get.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Version.Get.Response
                         * @interface IError
                         * @property {anytype.Rpc.Version.Get.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Version.Get.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Version.Get.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Version.Get.Response.Error.Code} code
                         * @memberof anytype.Rpc.Version.Get.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Version.Get.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Version.Get.Response.Error
                         * @static
                         * @param {anytype.Rpc.Version.Get.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Version.Get.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Version.Get.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Version.Get.Response.Error
                         * @static
                         * @param {anytype.Rpc.Version.Get.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Version.Get.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Version.Get.Response.Error
                         * @static
                         * @param {anytype.Rpc.Version.Get.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Version.Get.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Version.Get.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Version.Get.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Version.Get.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Version.Get.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Version.Get.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 101:
                                case 102:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Version.Get.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Version.Get.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Version.Get.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Version.Get.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            case "VERSION_IS_EMPTY":
                            case 3:
                                message.code = 3;
                                break;
                            case "NOT_FOUND":
                            case 101:
                                message.code = 101;
                                break;
                            case "TIMEOUT":
                            case 102:
                                message.code = 102;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Version.Get.Response.Error
                         * @static
                         * @param {anytype.Rpc.Version.Get.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Version.Get.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Version.Get.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Version.Get.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         * @property {number} VERSION_IS_EMPTY=3 VERSION_IS_EMPTY value
                         * @property {number} NOT_FOUND=101 NOT_FOUND value
                         * @property {number} TIMEOUT=102 TIMEOUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            values[valuesById[3] = "VERSION_IS_EMPTY"] = 3;
                            values[valuesById[101] = "NOT_FOUND"] = 101;
                            values[valuesById[102] = "TIMEOUT"] = 102;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Get;
            })();

            return Version;
        })();

        Rpc.Ipfs = (function() {

            /**
             * Properties of an Ipfs.
             * @memberof anytype.Rpc
             * @interface IIpfs
             */

            /**
             * Constructs a new Ipfs.
             * @memberof anytype.Rpc
             * @classdesc Represents an Ipfs.
             * @implements IIpfs
             * @constructor
             * @param {anytype.Rpc.IIpfs=} [properties] Properties to set
             */
            function Ipfs(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Ipfs instance using the specified properties.
             * @function create
             * @memberof anytype.Rpc.Ipfs
             * @static
             * @param {anytype.Rpc.IIpfs=} [properties] Properties to set
             * @returns {anytype.Rpc.Ipfs} Ipfs instance
             */
            Ipfs.create = function create(properties) {
                return new Ipfs(properties);
            };

            /**
             * Encodes the specified Ipfs message. Does not implicitly {@link anytype.Rpc.Ipfs.verify|verify} messages.
             * @function encode
             * @memberof anytype.Rpc.Ipfs
             * @static
             * @param {anytype.Rpc.IIpfs} message Ipfs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ipfs.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Ipfs message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Rpc.Ipfs
             * @static
             * @param {anytype.Rpc.IIpfs} message Ipfs message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ipfs.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Ipfs message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Rpc.Ipfs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Rpc.Ipfs} Ipfs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ipfs.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Ipfs message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Rpc.Ipfs
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Rpc.Ipfs} Ipfs
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ipfs.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Ipfs message.
             * @function verify
             * @memberof anytype.Rpc.Ipfs
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Ipfs.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Ipfs message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Rpc.Ipfs
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Rpc.Ipfs} Ipfs
             */
            Ipfs.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Rpc.Ipfs)
                    return object;
                return new $root.anytype.Rpc.Ipfs();
            };

            /**
             * Creates a plain object from an Ipfs message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Rpc.Ipfs
             * @static
             * @param {anytype.Rpc.Ipfs} message Ipfs
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Ipfs.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Ipfs to JSON.
             * @function toJSON
             * @memberof anytype.Rpc.Ipfs
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Ipfs.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Ipfs.File = (function() {

                /**
                 * Properties of a File.
                 * @memberof anytype.Rpc.Ipfs
                 * @interface IFile
                 */

                /**
                 * Constructs a new File.
                 * @memberof anytype.Rpc.Ipfs
                 * @classdesc Represents a File.
                 * @implements IFile
                 * @constructor
                 * @param {anytype.Rpc.Ipfs.IFile=} [properties] Properties to set
                 */
                function File(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new File instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Ipfs.File
                 * @static
                 * @param {anytype.Rpc.Ipfs.IFile=} [properties] Properties to set
                 * @returns {anytype.Rpc.Ipfs.File} File instance
                 */
                File.create = function create(properties) {
                    return new File(properties);
                };

                /**
                 * Encodes the specified File message. Does not implicitly {@link anytype.Rpc.Ipfs.File.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Ipfs.File
                 * @static
                 * @param {anytype.Rpc.Ipfs.IFile} message File message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                File.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified File message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.File.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Ipfs.File
                 * @static
                 * @param {anytype.Rpc.Ipfs.IFile} message File message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                File.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a File message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Ipfs.File
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Ipfs.File} File
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                File.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.File();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a File message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Ipfs.File
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Ipfs.File} File
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                File.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a File message.
                 * @function verify
                 * @memberof anytype.Rpc.Ipfs.File
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                File.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a File message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Ipfs.File
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Ipfs.File} File
                 */
                File.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Ipfs.File)
                        return object;
                    return new $root.anytype.Rpc.Ipfs.File();
                };

                /**
                 * Creates a plain object from a File message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Ipfs.File
                 * @static
                 * @param {anytype.Rpc.Ipfs.File} message File
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                File.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this File to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Ipfs.File
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                File.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                File.Get = (function() {

                    /**
                     * Properties of a Get.
                     * @memberof anytype.Rpc.Ipfs.File
                     * @interface IGet
                     */

                    /**
                     * Constructs a new Get.
                     * @memberof anytype.Rpc.Ipfs.File
                     * @classdesc Represents a Get.
                     * @implements IGet
                     * @constructor
                     * @param {anytype.Rpc.Ipfs.File.IGet=} [properties] Properties to set
                     */
                    function Get(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Get instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Ipfs.File.Get
                     * @static
                     * @param {anytype.Rpc.Ipfs.File.IGet=} [properties] Properties to set
                     * @returns {anytype.Rpc.Ipfs.File.Get} Get instance
                     */
                    Get.create = function create(properties) {
                        return new Get(properties);
                    };

                    /**
                     * Encodes the specified Get message. Does not implicitly {@link anytype.Rpc.Ipfs.File.Get.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Ipfs.File.Get
                     * @static
                     * @param {anytype.Rpc.Ipfs.File.IGet} message Get message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Get.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Get message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.File.Get.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Ipfs.File.Get
                     * @static
                     * @param {anytype.Rpc.Ipfs.File.IGet} message Get message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Get.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Get message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Ipfs.File.Get
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Ipfs.File.Get} Get
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Get.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.File.Get();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Get message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Ipfs.File.Get
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Ipfs.File.Get} Get
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Get.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Get message.
                     * @function verify
                     * @memberof anytype.Rpc.Ipfs.File.Get
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Get.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Get message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Ipfs.File.Get
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Ipfs.File.Get} Get
                     */
                    Get.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Ipfs.File.Get)
                            return object;
                        return new $root.anytype.Rpc.Ipfs.File.Get();
                    };

                    /**
                     * Creates a plain object from a Get message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Ipfs.File.Get
                     * @static
                     * @param {anytype.Rpc.Ipfs.File.Get} message Get
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Get.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Get to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Ipfs.File.Get
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Get.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Get.Request = (function() {

                        /**
                         * Properties of a Request.
                         * @memberof anytype.Rpc.Ipfs.File.Get
                         * @interface IRequest
                         * @property {string|null} [id] Request id
                         */

                        /**
                         * Constructs a new Request.
                         * @memberof anytype.Rpc.Ipfs.File.Get
                         * @classdesc Represents a Request.
                         * @implements IRequest
                         * @constructor
                         * @param {anytype.Rpc.Ipfs.File.Get.IRequest=} [properties] Properties to set
                         */
                        function Request(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Request id.
                         * @member {string} id
                         * @memberof anytype.Rpc.Ipfs.File.Get.Request
                         * @instance
                         */
                        Request.prototype.id = "";

                        /**
                         * Creates a new Request instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Ipfs.File.Get.Request
                         * @static
                         * @param {anytype.Rpc.Ipfs.File.Get.IRequest=} [properties] Properties to set
                         * @returns {anytype.Rpc.Ipfs.File.Get.Request} Request instance
                         */
                        Request.create = function create(properties) {
                            return new Request(properties);
                        };

                        /**
                         * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Ipfs.File.Get.Request.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Ipfs.File.Get.Request
                         * @static
                         * @param {anytype.Rpc.Ipfs.File.Get.IRequest} message Request message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Request.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.id != null && message.hasOwnProperty("id"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                            return writer;
                        };

                        /**
                         * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.File.Get.Request.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Ipfs.File.Get.Request
                         * @static
                         * @param {anytype.Rpc.Ipfs.File.Get.IRequest} message Request message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Request.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Request message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Ipfs.File.Get.Request
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Ipfs.File.Get.Request} Request
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Request.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.File.Get.Request();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.id = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Request message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Ipfs.File.Get.Request
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Ipfs.File.Get.Request} Request
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Request.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Request message.
                         * @function verify
                         * @memberof anytype.Rpc.Ipfs.File.Get.Request
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Request.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.id != null && message.hasOwnProperty("id"))
                                if (!$util.isString(message.id))
                                    return "id: string expected";
                            return null;
                        };

                        /**
                         * Creates a Request message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Ipfs.File.Get.Request
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Ipfs.File.Get.Request} Request
                         */
                        Request.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Ipfs.File.Get.Request)
                                return object;
                            var message = new $root.anytype.Rpc.Ipfs.File.Get.Request();
                            if (object.id != null)
                                message.id = String(object.id);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Request message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Ipfs.File.Get.Request
                         * @static
                         * @param {anytype.Rpc.Ipfs.File.Get.Request} message Request
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Request.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.id = "";
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = message.id;
                            return object;
                        };

                        /**
                         * Converts this Request to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Ipfs.File.Get.Request
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Request.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Request;
                    })();

                    Get.Response = (function() {

                        /**
                         * Properties of a Response.
                         * @memberof anytype.Rpc.Ipfs.File.Get
                         * @interface IResponse
                         * @property {anytype.Rpc.Ipfs.File.Get.Response.IError|null} [error] Response error
                         * @property {Uint8Array|null} [data] Response data
                         * @property {string|null} [media] Response media
                         * @property {string|null} [name] Response name
                         */

                        /**
                         * Constructs a new Response.
                         * @memberof anytype.Rpc.Ipfs.File.Get
                         * @classdesc Represents a Response.
                         * @implements IResponse
                         * @constructor
                         * @param {anytype.Rpc.Ipfs.File.Get.IResponse=} [properties] Properties to set
                         */
                        function Response(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Response error.
                         * @member {anytype.Rpc.Ipfs.File.Get.Response.IError|null|undefined} error
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @instance
                         */
                        Response.prototype.error = null;

                        /**
                         * Response data.
                         * @member {Uint8Array} data
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @instance
                         */
                        Response.prototype.data = $util.newBuffer([]);

                        /**
                         * Response media.
                         * @member {string} media
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @instance
                         */
                        Response.prototype.media = "";

                        /**
                         * Response name.
                         * @member {string} name
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @instance
                         */
                        Response.prototype.name = "";

                        /**
                         * Creates a new Response instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @static
                         * @param {anytype.Rpc.Ipfs.File.Get.IResponse=} [properties] Properties to set
                         * @returns {anytype.Rpc.Ipfs.File.Get.Response} Response instance
                         */
                        Response.create = function create(properties) {
                            return new Response(properties);
                        };

                        /**
                         * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Ipfs.File.Get.Response.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @static
                         * @param {anytype.Rpc.Ipfs.File.Get.IResponse} message Response message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Response.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.error != null && message.hasOwnProperty("error"))
                                $root.anytype.Rpc.Ipfs.File.Get.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.data != null && message.hasOwnProperty("data"))
                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
                            if (message.media != null && message.hasOwnProperty("media"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.media);
                            if (message.name != null && message.hasOwnProperty("name"))
                                writer.uint32(/* id 4, wireType 2 =*/34).string(message.name);
                            return writer;
                        };

                        /**
                         * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.File.Get.Response.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @static
                         * @param {anytype.Rpc.Ipfs.File.Get.IResponse} message Response message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Response.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Response message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Ipfs.File.Get.Response} Response
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Response.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.File.Get.Response();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.error = $root.anytype.Rpc.Ipfs.File.Get.Response.Error.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.data = reader.bytes();
                                    break;
                                case 3:
                                    message.media = reader.string();
                                    break;
                                case 4:
                                    message.name = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Response message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Ipfs.File.Get.Response} Response
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Response.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Response message.
                         * @function verify
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Response.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.error != null && message.hasOwnProperty("error")) {
                                var error = $root.anytype.Rpc.Ipfs.File.Get.Response.Error.verify(message.error);
                                if (error)
                                    return "error." + error;
                            }
                            if (message.data != null && message.hasOwnProperty("data"))
                                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                                    return "data: buffer expected";
                            if (message.media != null && message.hasOwnProperty("media"))
                                if (!$util.isString(message.media))
                                    return "media: string expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            return null;
                        };

                        /**
                         * Creates a Response message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Ipfs.File.Get.Response} Response
                         */
                        Response.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Ipfs.File.Get.Response)
                                return object;
                            var message = new $root.anytype.Rpc.Ipfs.File.Get.Response();
                            if (object.error != null) {
                                if (typeof object.error !== "object")
                                    throw TypeError(".anytype.Rpc.Ipfs.File.Get.Response.error: object expected");
                                message.error = $root.anytype.Rpc.Ipfs.File.Get.Response.Error.fromObject(object.error);
                            }
                            if (object.data != null)
                                if (typeof object.data === "string")
                                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                                else if (object.data.length)
                                    message.data = object.data;
                            if (object.media != null)
                                message.media = String(object.media);
                            if (object.name != null)
                                message.name = String(object.name);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Response message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @static
                         * @param {anytype.Rpc.Ipfs.File.Get.Response} message Response
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Response.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.error = null;
                                if (options.bytes === String)
                                    object.data = "";
                                else {
                                    object.data = [];
                                    if (options.bytes !== Array)
                                        object.data = $util.newBuffer(object.data);
                                }
                                object.media = "";
                                object.name = "";
                            }
                            if (message.error != null && message.hasOwnProperty("error"))
                                object.error = $root.anytype.Rpc.Ipfs.File.Get.Response.Error.toObject(message.error, options);
                            if (message.data != null && message.hasOwnProperty("data"))
                                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                            if (message.media != null && message.hasOwnProperty("media"))
                                object.media = message.media;
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            return object;
                        };

                        /**
                         * Converts this Response to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Ipfs.File.Get.Response
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Response.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Response.Error = (function() {

                            /**
                             * Properties of an Error.
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response
                             * @interface IError
                             * @property {anytype.Rpc.Ipfs.File.Get.Response.Error.Code|null} [code] Error code
                             * @property {string|null} [description] Error description
                             */

                            /**
                             * Constructs a new Error.
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response
                             * @classdesc Represents an Error.
                             * @implements IError
                             * @constructor
                             * @param {anytype.Rpc.Ipfs.File.Get.Response.IError=} [properties] Properties to set
                             */
                            function Error(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Error code.
                             * @member {anytype.Rpc.Ipfs.File.Get.Response.Error.Code} code
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response.Error
                             * @instance
                             */
                            Error.prototype.code = 0;

                            /**
                             * Error description.
                             * @member {string} description
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response.Error
                             * @instance
                             */
                            Error.prototype.description = "";

                            /**
                             * Creates a new Error instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response.Error
                             * @static
                             * @param {anytype.Rpc.Ipfs.File.Get.Response.IError=} [properties] Properties to set
                             * @returns {anytype.Rpc.Ipfs.File.Get.Response.Error} Error instance
                             */
                            Error.create = function create(properties) {
                                return new Error(properties);
                            };

                            /**
                             * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Ipfs.File.Get.Response.Error.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response.Error
                             * @static
                             * @param {anytype.Rpc.Ipfs.File.Get.Response.IError} message Error message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Error.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.code != null && message.hasOwnProperty("code"))
                                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                if (message.description != null && message.hasOwnProperty("description"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                return writer;
                            };

                            /**
                             * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.File.Get.Response.Error.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response.Error
                             * @static
                             * @param {anytype.Rpc.Ipfs.File.Get.Response.IError} message Error message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Error.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes an Error message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response.Error
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Ipfs.File.Get.Response.Error} Error
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Error.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.File.Get.Response.Error();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.code = reader.int32();
                                        break;
                                    case 2:
                                        message.description = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes an Error message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response.Error
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Ipfs.File.Get.Response.Error} Error
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Error.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies an Error message.
                             * @function verify
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response.Error
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Error.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.code != null && message.hasOwnProperty("code"))
                                    switch (message.code) {
                                    default:
                                        return "code: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 101:
                                    case 102:
                                        break;
                                    }
                                if (message.description != null && message.hasOwnProperty("description"))
                                    if (!$util.isString(message.description))
                                        return "description: string expected";
                                return null;
                            };

                            /**
                             * Creates an Error message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response.Error
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Ipfs.File.Get.Response.Error} Error
                             */
                            Error.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Ipfs.File.Get.Response.Error)
                                    return object;
                                var message = new $root.anytype.Rpc.Ipfs.File.Get.Response.Error();
                                switch (object.code) {
                                case "NULL":
                                case 0:
                                    message.code = 0;
                                    break;
                                case "UNKNOWN_ERROR":
                                case 1:
                                    message.code = 1;
                                    break;
                                case "BAD_INPUT":
                                case 2:
                                    message.code = 2;
                                    break;
                                case "NOT_FOUND":
                                case 101:
                                    message.code = 101;
                                    break;
                                case "TIMEOUT":
                                case 102:
                                    message.code = 102;
                                    break;
                                }
                                if (object.description != null)
                                    message.description = String(object.description);
                                return message;
                            };

                            /**
                             * Creates a plain object from an Error message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response.Error
                             * @static
                             * @param {anytype.Rpc.Ipfs.File.Get.Response.Error} message Error
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Error.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.code = options.enums === String ? "NULL" : 0;
                                    object.description = "";
                                }
                                if (message.code != null && message.hasOwnProperty("code"))
                                    object.code = options.enums === String ? $root.anytype.Rpc.Ipfs.File.Get.Response.Error.Code[message.code] : message.code;
                                if (message.description != null && message.hasOwnProperty("description"))
                                    object.description = message.description;
                                return object;
                            };

                            /**
                             * Converts this Error to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Ipfs.File.Get.Response.Error
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Error.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * Code enum.
                             * @name anytype.Rpc.Ipfs.File.Get.Response.Error.Code
                             * @enum {string}
                             * @property {number} NULL=0 NULL value
                             * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                             * @property {number} BAD_INPUT=2 BAD_INPUT value
                             * @property {number} NOT_FOUND=101 NOT_FOUND value
                             * @property {number} TIMEOUT=102 TIMEOUT value
                             */
                            Error.Code = (function() {
                                var valuesById = {}, values = Object.create(valuesById);
                                values[valuesById[0] = "NULL"] = 0;
                                values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                values[valuesById[2] = "BAD_INPUT"] = 2;
                                values[valuesById[101] = "NOT_FOUND"] = 101;
                                values[valuesById[102] = "TIMEOUT"] = 102;
                                return values;
                            })();

                            return Error;
                        })();

                        return Response;
                    })();

                    return Get;
                })();

                return File;
            })();

            Ipfs.Image = (function() {

                /**
                 * Properties of an Image.
                 * @memberof anytype.Rpc.Ipfs
                 * @interface IImage
                 */

                /**
                 * Constructs a new Image.
                 * @memberof anytype.Rpc.Ipfs
                 * @classdesc Represents an Image.
                 * @implements IImage
                 * @constructor
                 * @param {anytype.Rpc.Ipfs.IImage=} [properties] Properties to set
                 */
                function Image(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Image instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Ipfs.Image
                 * @static
                 * @param {anytype.Rpc.Ipfs.IImage=} [properties] Properties to set
                 * @returns {anytype.Rpc.Ipfs.Image} Image instance
                 */
                Image.create = function create(properties) {
                    return new Image(properties);
                };

                /**
                 * Encodes the specified Image message. Does not implicitly {@link anytype.Rpc.Ipfs.Image.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Ipfs.Image
                 * @static
                 * @param {anytype.Rpc.Ipfs.IImage} message Image message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Image.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Image message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.Image.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Ipfs.Image
                 * @static
                 * @param {anytype.Rpc.Ipfs.IImage} message Image message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Image.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Image message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Ipfs.Image
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Ipfs.Image} Image
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Image.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.Image();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Image message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Ipfs.Image
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Ipfs.Image} Image
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Image.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Image message.
                 * @function verify
                 * @memberof anytype.Rpc.Ipfs.Image
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Image.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an Image message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Ipfs.Image
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Ipfs.Image} Image
                 */
                Image.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Ipfs.Image)
                        return object;
                    return new $root.anytype.Rpc.Ipfs.Image();
                };

                /**
                 * Creates a plain object from an Image message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Ipfs.Image
                 * @static
                 * @param {anytype.Rpc.Ipfs.Image} message Image
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Image.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Image to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Ipfs.Image
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Image.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Image.Get = (function() {

                    /**
                     * Properties of a Get.
                     * @memberof anytype.Rpc.Ipfs.Image
                     * @interface IGet
                     */

                    /**
                     * Constructs a new Get.
                     * @memberof anytype.Rpc.Ipfs.Image
                     * @classdesc Represents a Get.
                     * @implements IGet
                     * @constructor
                     * @param {anytype.Rpc.Ipfs.Image.IGet=} [properties] Properties to set
                     */
                    function Get(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Get instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Ipfs.Image.Get
                     * @static
                     * @param {anytype.Rpc.Ipfs.Image.IGet=} [properties] Properties to set
                     * @returns {anytype.Rpc.Ipfs.Image.Get} Get instance
                     */
                    Get.create = function create(properties) {
                        return new Get(properties);
                    };

                    /**
                     * Encodes the specified Get message. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Ipfs.Image.Get
                     * @static
                     * @param {anytype.Rpc.Ipfs.Image.IGet} message Get message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Get.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Get message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Ipfs.Image.Get
                     * @static
                     * @param {anytype.Rpc.Ipfs.Image.IGet} message Get message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Get.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Get message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Ipfs.Image.Get
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Ipfs.Image.Get} Get
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Get.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.Image.Get();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Get message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Ipfs.Image.Get
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Ipfs.Image.Get} Get
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Get.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Get message.
                     * @function verify
                     * @memberof anytype.Rpc.Ipfs.Image.Get
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Get.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Get message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Ipfs.Image.Get
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Ipfs.Image.Get} Get
                     */
                    Get.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Ipfs.Image.Get)
                            return object;
                        return new $root.anytype.Rpc.Ipfs.Image.Get();
                    };

                    /**
                     * Creates a plain object from a Get message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Ipfs.Image.Get
                     * @static
                     * @param {anytype.Rpc.Ipfs.Image.Get} message Get
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Get.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Get to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Ipfs.Image.Get
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Get.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Get.Blob = (function() {

                        /**
                         * Properties of a Blob.
                         * @memberof anytype.Rpc.Ipfs.Image.Get
                         * @interface IBlob
                         */

                        /**
                         * Constructs a new Blob.
                         * @memberof anytype.Rpc.Ipfs.Image.Get
                         * @classdesc Represents a Blob.
                         * @implements IBlob
                         * @constructor
                         * @param {anytype.Rpc.Ipfs.Image.Get.IBlob=} [properties] Properties to set
                         */
                        function Blob(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new Blob instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                         * @static
                         * @param {anytype.Rpc.Ipfs.Image.Get.IBlob=} [properties] Properties to set
                         * @returns {anytype.Rpc.Ipfs.Image.Get.Blob} Blob instance
                         */
                        Blob.create = function create(properties) {
                            return new Blob(properties);
                        };

                        /**
                         * Encodes the specified Blob message. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.Blob.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                         * @static
                         * @param {anytype.Rpc.Ipfs.Image.Get.IBlob} message Blob message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Blob.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified Blob message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.Blob.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                         * @static
                         * @param {anytype.Rpc.Ipfs.Image.Get.IBlob} message Blob message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Blob.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Blob message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Ipfs.Image.Get.Blob} Blob
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Blob.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.Image.Get.Blob();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Blob message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Ipfs.Image.Get.Blob} Blob
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Blob.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Blob message.
                         * @function verify
                         * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Blob.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a Blob message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Ipfs.Image.Get.Blob} Blob
                         */
                        Blob.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Ipfs.Image.Get.Blob)
                                return object;
                            return new $root.anytype.Rpc.Ipfs.Image.Get.Blob();
                        };

                        /**
                         * Creates a plain object from a Blob message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                         * @static
                         * @param {anytype.Rpc.Ipfs.Image.Get.Blob} message Blob
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Blob.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this Blob to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Blob.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Blob.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                             * @interface IRequest
                             * @property {string|null} [id] Request id
                             * @property {anytype.model.Image.Size|null} [size] Request size
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Ipfs.Image.Get.Blob.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request id.
                             * @member {string} id
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Request
                             * @instance
                             */
                            Request.prototype.id = "";

                            /**
                             * Request size.
                             * @member {anytype.model.Image.Size} size
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Request
                             * @instance
                             */
                            Request.prototype.size = 0;

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Request
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.Blob.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Ipfs.Image.Get.Blob.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.Blob.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Request
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.Blob.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.id != null && message.hasOwnProperty("id"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                                if (message.size != null && message.hasOwnProperty("size"))
                                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.size);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.Blob.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Request
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.Blob.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Ipfs.Image.Get.Blob.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.Image.Get.Blob.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.id = reader.string();
                                        break;
                                    case 2:
                                        message.size = reader.int32();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Ipfs.Image.Get.Blob.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.id != null && message.hasOwnProperty("id"))
                                    if (!$util.isString(message.id))
                                        return "id: string expected";
                                if (message.size != null && message.hasOwnProperty("size"))
                                    switch (message.size) {
                                    default:
                                        return "size: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                        break;
                                    }
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Ipfs.Image.Get.Blob.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Ipfs.Image.Get.Blob.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Ipfs.Image.Get.Blob.Request();
                                if (object.id != null)
                                    message.id = String(object.id);
                                switch (object.size) {
                                case "Large":
                                case 0:
                                    message.size = 0;
                                    break;
                                case "Small":
                                case 1:
                                    message.size = 1;
                                    break;
                                case "Thumb":
                                case 2:
                                    message.size = 2;
                                    break;
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Request
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.Blob.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.id = "";
                                    object.size = options.enums === String ? "Large" : 0;
                                }
                                if (message.id != null && message.hasOwnProperty("id"))
                                    object.id = message.id;
                                if (message.size != null && message.hasOwnProperty("size"))
                                    object.size = options.enums === String ? $root.anytype.model.Image.Size[message.size] : message.size;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        Blob.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                             * @interface IResponse
                             * @property {anytype.Rpc.Ipfs.Image.Get.Blob.Response.IError|null} [error] Response error
                             * @property {Uint8Array|null} [blob] Response blob
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Ipfs.Image.Get.Blob.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Ipfs.Image.Get.Blob.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Response blob.
                             * @member {Uint8Array} blob
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                             * @instance
                             */
                            Response.prototype.blob = $util.newBuffer([]);

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.Blob.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Ipfs.Image.Get.Blob.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.Blob.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.Blob.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.blob != null && message.hasOwnProperty("blob"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.blob);
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.Blob.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.Blob.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Ipfs.Image.Get.Blob.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        message.blob = reader.bytes();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Ipfs.Image.Get.Blob.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                if (message.blob != null && message.hasOwnProperty("blob"))
                                    if (!(message.blob && typeof message.blob.length === "number" || $util.isString(message.blob)))
                                        return "blob: buffer expected";
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Ipfs.Image.Get.Blob.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Ipfs.Image.Get.Blob.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error.fromObject(object.error);
                                }
                                if (object.blob != null)
                                    if (typeof object.blob === "string")
                                        $util.base64.decode(object.blob, message.blob = $util.newBuffer($util.base64.length(object.blob)), 0);
                                    else if (object.blob.length)
                                        message.blob = object.blob;
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.Blob.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.error = null;
                                    if (options.bytes === String)
                                        object.blob = "";
                                    else {
                                        object.blob = [];
                                        if (options.bytes !== Array)
                                            object.blob = $util.newBuffer(object.blob);
                                    }
                                }
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error.toObject(message.error, options);
                                if (message.blob != null && message.hasOwnProperty("blob"))
                                    object.blob = options.bytes === String ? $util.base64.encode(message.blob, 0, message.blob.length) : options.bytes === Array ? Array.prototype.slice.call(message.blob) : message.blob;
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Ipfs.Image.Get.Blob.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Ipfs.Image.Get.Blob.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Ipfs.Image.Get.Blob.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Ipfs.Image.Get.Blob.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                        case 101:
                                        case 102:
                                        case 103:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    case "NOT_FOUND":
                                    case 101:
                                        message.code = 101;
                                        break;
                                    case "TIMEOUT":
                                    case 102:
                                        message.code = 102;
                                        break;
                                    case "NODE_NOT_STARTED":
                                    case 103:
                                        message.code = 103;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Ipfs.Image.Get.Blob.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 * @property {number} NOT_FOUND=101 NOT_FOUND value
                                 * @property {number} TIMEOUT=102 TIMEOUT value
                                 * @property {number} NODE_NOT_STARTED=103 NODE_NOT_STARTED value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    values[valuesById[101] = "NOT_FOUND"] = 101;
                                    values[valuesById[102] = "TIMEOUT"] = 102;
                                    values[valuesById[103] = "NODE_NOT_STARTED"] = 103;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return Blob;
                    })();

                    Get.File = (function() {

                        /**
                         * Properties of a File.
                         * @memberof anytype.Rpc.Ipfs.Image.Get
                         * @interface IFile
                         */

                        /**
                         * Constructs a new File.
                         * @memberof anytype.Rpc.Ipfs.Image.Get
                         * @classdesc Represents a File.
                         * @implements IFile
                         * @constructor
                         * @param {anytype.Rpc.Ipfs.Image.Get.IFile=} [properties] Properties to set
                         */
                        function File(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Creates a new File instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Ipfs.Image.Get.File
                         * @static
                         * @param {anytype.Rpc.Ipfs.Image.Get.IFile=} [properties] Properties to set
                         * @returns {anytype.Rpc.Ipfs.Image.Get.File} File instance
                         */
                        File.create = function create(properties) {
                            return new File(properties);
                        };

                        /**
                         * Encodes the specified File message. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.File.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Ipfs.Image.Get.File
                         * @static
                         * @param {anytype.Rpc.Ipfs.Image.Get.IFile} message File message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        File.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            return writer;
                        };

                        /**
                         * Encodes the specified File message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.File.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Ipfs.Image.Get.File
                         * @static
                         * @param {anytype.Rpc.Ipfs.Image.Get.IFile} message File message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        File.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a File message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Ipfs.Image.Get.File
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Ipfs.Image.Get.File} File
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        File.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.Image.Get.File();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a File message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Ipfs.Image.Get.File
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Ipfs.Image.Get.File} File
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        File.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a File message.
                         * @function verify
                         * @memberof anytype.Rpc.Ipfs.Image.Get.File
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        File.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a File message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Ipfs.Image.Get.File
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Ipfs.Image.Get.File} File
                         */
                        File.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Ipfs.Image.Get.File)
                                return object;
                            return new $root.anytype.Rpc.Ipfs.Image.Get.File();
                        };

                        /**
                         * Creates a plain object from a File message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Ipfs.Image.Get.File
                         * @static
                         * @param {anytype.Rpc.Ipfs.Image.Get.File} message File
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        File.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this File to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Ipfs.Image.Get.File
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        File.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        File.Request = (function() {

                            /**
                             * Properties of a Request.
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File
                             * @interface IRequest
                             * @property {string|null} [id] Request id
                             * @property {anytype.model.Image.Size|null} [size] Request size
                             */

                            /**
                             * Constructs a new Request.
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File
                             * @classdesc Represents a Request.
                             * @implements IRequest
                             * @constructor
                             * @param {anytype.Rpc.Ipfs.Image.Get.File.IRequest=} [properties] Properties to set
                             */
                            function Request(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Request id.
                             * @member {string} id
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Request
                             * @instance
                             */
                            Request.prototype.id = "";

                            /**
                             * Request size.
                             * @member {anytype.model.Image.Size} size
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Request
                             * @instance
                             */
                            Request.prototype.size = 0;

                            /**
                             * Creates a new Request instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Request
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.File.IRequest=} [properties] Properties to set
                             * @returns {anytype.Rpc.Ipfs.Image.Get.File.Request} Request instance
                             */
                            Request.create = function create(properties) {
                                return new Request(properties);
                            };

                            /**
                             * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.File.Request.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Request
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.File.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.id != null && message.hasOwnProperty("id"))
                                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                                if (message.size != null && message.hasOwnProperty("size"))
                                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.size);
                                return writer;
                            };

                            /**
                             * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.File.Request.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Request
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.File.IRequest} message Request message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Request.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Ipfs.Image.Get.File.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.Image.Get.File.Request();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.id = reader.string();
                                        break;
                                    case 2:
                                        message.size = reader.int32();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Request message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Request
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Ipfs.Image.Get.File.Request} Request
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Request.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Request message.
                             * @function verify
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Request
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Request.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.id != null && message.hasOwnProperty("id"))
                                    if (!$util.isString(message.id))
                                        return "id: string expected";
                                if (message.size != null && message.hasOwnProperty("size"))
                                    switch (message.size) {
                                    default:
                                        return "size: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                        break;
                                    }
                                return null;
                            };

                            /**
                             * Creates a Request message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Request
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Ipfs.Image.Get.File.Request} Request
                             */
                            Request.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Ipfs.Image.Get.File.Request)
                                    return object;
                                var message = new $root.anytype.Rpc.Ipfs.Image.Get.File.Request();
                                if (object.id != null)
                                    message.id = String(object.id);
                                switch (object.size) {
                                case "Large":
                                case 0:
                                    message.size = 0;
                                    break;
                                case "Small":
                                case 1:
                                    message.size = 1;
                                    break;
                                case "Thumb":
                                case 2:
                                    message.size = 2;
                                    break;
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Request message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Request
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.File.Request} message Request
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Request.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.id = "";
                                    object.size = options.enums === String ? "Large" : 0;
                                }
                                if (message.id != null && message.hasOwnProperty("id"))
                                    object.id = message.id;
                                if (message.size != null && message.hasOwnProperty("size"))
                                    object.size = options.enums === String ? $root.anytype.model.Image.Size[message.size] : message.size;
                                return object;
                            };

                            /**
                             * Converts this Request to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Request
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Request.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Request;
                        })();

                        File.Response = (function() {

                            /**
                             * Properties of a Response.
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File
                             * @interface IResponse
                             * @property {anytype.Rpc.Ipfs.Image.Get.File.Response.IError|null} [error] Response error
                             * @property {string|null} [localPath] Response localPath
                             */

                            /**
                             * Constructs a new Response.
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File
                             * @classdesc Represents a Response.
                             * @implements IResponse
                             * @constructor
                             * @param {anytype.Rpc.Ipfs.Image.Get.File.IResponse=} [properties] Properties to set
                             */
                            function Response(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Response error.
                             * @member {anytype.Rpc.Ipfs.Image.Get.File.Response.IError|null|undefined} error
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                             * @instance
                             */
                            Response.prototype.error = null;

                            /**
                             * Response localPath.
                             * @member {string} localPath
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                             * @instance
                             */
                            Response.prototype.localPath = "";

                            /**
                             * Creates a new Response instance using the specified properties.
                             * @function create
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.File.IResponse=} [properties] Properties to set
                             * @returns {anytype.Rpc.Ipfs.Image.Get.File.Response} Response instance
                             */
                            Response.create = function create(properties) {
                                return new Response(properties);
                            };

                            /**
                             * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.File.Response.verify|verify} messages.
                             * @function encode
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.File.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encode = function encode(message, writer) {
                                if (!writer)
                                    writer = $Writer.create();
                                if (message.error != null && message.hasOwnProperty("error"))
                                    $root.anytype.Rpc.Ipfs.Image.Get.File.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                                if (message.localPath != null && message.hasOwnProperty("localPath"))
                                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.localPath);
                                return writer;
                            };

                            /**
                             * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.File.Response.verify|verify} messages.
                             * @function encodeDelimited
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.File.IResponse} message Response message or plain object to encode
                             * @param {$protobuf.Writer} [writer] Writer to encode to
                             * @returns {$protobuf.Writer} Writer
                             */
                            Response.encodeDelimited = function encodeDelimited(message, writer) {
                                return this.encode(message, writer).ldelim();
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer.
                             * @function decode
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {anytype.Rpc.Ipfs.Image.Get.File.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.Image.Get.File.Response();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.error = $root.anytype.Rpc.Ipfs.Image.Get.File.Response.Error.decode(reader, reader.uint32());
                                        break;
                                    case 2:
                                        message.localPath = reader.string();
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * Decodes a Response message from the specified reader or buffer, length delimited.
                             * @function decodeDelimited
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @returns {anytype.Rpc.Ipfs.Image.Get.File.Response} Response
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Response.decodeDelimited = function decodeDelimited(reader) {
                                if (!(reader instanceof $Reader))
                                    reader = new $Reader(reader);
                                return this.decode(reader, reader.uint32());
                            };

                            /**
                             * Verifies a Response message.
                             * @function verify
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Response.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.error != null && message.hasOwnProperty("error")) {
                                    var error = $root.anytype.Rpc.Ipfs.Image.Get.File.Response.Error.verify(message.error);
                                    if (error)
                                        return "error." + error;
                                }
                                if (message.localPath != null && message.hasOwnProperty("localPath"))
                                    if (!$util.isString(message.localPath))
                                        return "localPath: string expected";
                                return null;
                            };

                            /**
                             * Creates a Response message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {anytype.Rpc.Ipfs.Image.Get.File.Response} Response
                             */
                            Response.fromObject = function fromObject(object) {
                                if (object instanceof $root.anytype.Rpc.Ipfs.Image.Get.File.Response)
                                    return object;
                                var message = new $root.anytype.Rpc.Ipfs.Image.Get.File.Response();
                                if (object.error != null) {
                                    if (typeof object.error !== "object")
                                        throw TypeError(".anytype.Rpc.Ipfs.Image.Get.File.Response.error: object expected");
                                    message.error = $root.anytype.Rpc.Ipfs.Image.Get.File.Response.Error.fromObject(object.error);
                                }
                                if (object.localPath != null)
                                    message.localPath = String(object.localPath);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Response message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                             * @static
                             * @param {anytype.Rpc.Ipfs.Image.Get.File.Response} message Response
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Response.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                var object = {};
                                if (options.defaults) {
                                    object.error = null;
                                    object.localPath = "";
                                }
                                if (message.error != null && message.hasOwnProperty("error"))
                                    object.error = $root.anytype.Rpc.Ipfs.Image.Get.File.Response.Error.toObject(message.error, options);
                                if (message.localPath != null && message.hasOwnProperty("localPath"))
                                    object.localPath = message.localPath;
                                return object;
                            };

                            /**
                             * Converts this Response to JSON.
                             * @function toJSON
                             * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Response.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            Response.Error = (function() {

                                /**
                                 * Properties of an Error.
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                                 * @interface IError
                                 * @property {anytype.Rpc.Ipfs.Image.Get.File.Response.Error.Code|null} [code] Error code
                                 * @property {string|null} [description] Error description
                                 */

                                /**
                                 * Constructs a new Error.
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response
                                 * @classdesc Represents an Error.
                                 * @implements IError
                                 * @constructor
                                 * @param {anytype.Rpc.Ipfs.Image.Get.File.Response.IError=} [properties] Properties to set
                                 */
                                function Error(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Error code.
                                 * @member {anytype.Rpc.Ipfs.Image.Get.File.Response.Error.Code} code
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response.Error
                                 * @instance
                                 */
                                Error.prototype.code = 0;

                                /**
                                 * Error description.
                                 * @member {string} description
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response.Error
                                 * @instance
                                 */
                                Error.prototype.description = "";

                                /**
                                 * Creates a new Error instance using the specified properties.
                                 * @function create
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Ipfs.Image.Get.File.Response.IError=} [properties] Properties to set
                                 * @returns {anytype.Rpc.Ipfs.Image.Get.File.Response.Error} Error instance
                                 */
                                Error.create = function create(properties) {
                                    return new Error(properties);
                                };

                                /**
                                 * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.File.Response.Error.verify|verify} messages.
                                 * @function encode
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Ipfs.Image.Get.File.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encode = function encode(message, writer) {
                                    if (!writer)
                                        writer = $Writer.create();
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                                    return writer;
                                };

                                /**
                                 * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Ipfs.Image.Get.File.Response.Error.verify|verify} messages.
                                 * @function encodeDelimited
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Ipfs.Image.Get.File.Response.IError} message Error message or plain object to encode
                                 * @param {$protobuf.Writer} [writer] Writer to encode to
                                 * @returns {$protobuf.Writer} Writer
                                 */
                                Error.encodeDelimited = function encodeDelimited(message, writer) {
                                    return this.encode(message, writer).ldelim();
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {anytype.Rpc.Ipfs.Image.Get.File.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ipfs.Image.Get.File.Response.Error();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.code = reader.int32();
                                            break;
                                        case 2:
                                            message.description = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * Decodes an Error message from the specified reader or buffer, length delimited.
                                 * @function decodeDelimited
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response.Error
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @returns {anytype.Rpc.Ipfs.Image.Get.File.Response.Error} Error
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Error.decodeDelimited = function decodeDelimited(reader) {
                                    if (!(reader instanceof $Reader))
                                        reader = new $Reader(reader);
                                    return this.decode(reader, reader.uint32());
                                };

                                /**
                                 * Verifies an Error message.
                                 * @function verify
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Error.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        switch (message.code) {
                                        default:
                                            return "code: enum value expected";
                                        case 0:
                                        case 1:
                                        case 2:
                                        case 101:
                                        case 102:
                                        case 103:
                                            break;
                                        }
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        if (!$util.isString(message.description))
                                            return "description: string expected";
                                    return null;
                                };

                                /**
                                 * Creates an Error message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response.Error
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {anytype.Rpc.Ipfs.Image.Get.File.Response.Error} Error
                                 */
                                Error.fromObject = function fromObject(object) {
                                    if (object instanceof $root.anytype.Rpc.Ipfs.Image.Get.File.Response.Error)
                                        return object;
                                    var message = new $root.anytype.Rpc.Ipfs.Image.Get.File.Response.Error();
                                    switch (object.code) {
                                    case "NULL":
                                    case 0:
                                        message.code = 0;
                                        break;
                                    case "UNKNOWN_ERROR":
                                    case 1:
                                        message.code = 1;
                                        break;
                                    case "BAD_INPUT":
                                    case 2:
                                        message.code = 2;
                                        break;
                                    case "NOT_FOUND":
                                    case 101:
                                        message.code = 101;
                                        break;
                                    case "TIMEOUT":
                                    case 102:
                                        message.code = 102;
                                        break;
                                    case "NODE_NOT_STARTED":
                                    case 103:
                                        message.code = 103;
                                        break;
                                    }
                                    if (object.description != null)
                                        message.description = String(object.description);
                                    return message;
                                };

                                /**
                                 * Creates a plain object from an Error message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response.Error
                                 * @static
                                 * @param {anytype.Rpc.Ipfs.Image.Get.File.Response.Error} message Error
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Error.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    var object = {};
                                    if (options.defaults) {
                                        object.code = options.enums === String ? "NULL" : 0;
                                        object.description = "";
                                    }
                                    if (message.code != null && message.hasOwnProperty("code"))
                                        object.code = options.enums === String ? $root.anytype.Rpc.Ipfs.Image.Get.File.Response.Error.Code[message.code] : message.code;
                                    if (message.description != null && message.hasOwnProperty("description"))
                                        object.description = message.description;
                                    return object;
                                };

                                /**
                                 * Converts this Error to JSON.
                                 * @function toJSON
                                 * @memberof anytype.Rpc.Ipfs.Image.Get.File.Response.Error
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Error.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                /**
                                 * Code enum.
                                 * @name anytype.Rpc.Ipfs.Image.Get.File.Response.Error.Code
                                 * @enum {string}
                                 * @property {number} NULL=0 NULL value
                                 * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                                 * @property {number} BAD_INPUT=2 BAD_INPUT value
                                 * @property {number} NOT_FOUND=101 NOT_FOUND value
                                 * @property {number} TIMEOUT=102 TIMEOUT value
                                 * @property {number} NODE_NOT_STARTED=103 NODE_NOT_STARTED value
                                 */
                                Error.Code = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "NULL"] = 0;
                                    values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                                    values[valuesById[2] = "BAD_INPUT"] = 2;
                                    values[valuesById[101] = "NOT_FOUND"] = 101;
                                    values[valuesById[102] = "TIMEOUT"] = 102;
                                    values[valuesById[103] = "NODE_NOT_STARTED"] = 103;
                                    return values;
                                })();

                                return Error;
                            })();

                            return Response;
                        })();

                        return File;
                    })();

                    return Get;
                })();

                return Image;
            })();

            return Ipfs;
        })();

        Rpc.Config = (function() {

            /**
             * Properties of a Config.
             * @memberof anytype.Rpc
             * @interface IConfig
             */

            /**
             * Constructs a new Config.
             * @memberof anytype.Rpc
             * @classdesc Represents a Config.
             * @implements IConfig
             * @constructor
             * @param {anytype.Rpc.IConfig=} [properties] Properties to set
             */
            function Config(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Config instance using the specified properties.
             * @function create
             * @memberof anytype.Rpc.Config
             * @static
             * @param {anytype.Rpc.IConfig=} [properties] Properties to set
             * @returns {anytype.Rpc.Config} Config instance
             */
            Config.create = function create(properties) {
                return new Config(properties);
            };

            /**
             * Encodes the specified Config message. Does not implicitly {@link anytype.Rpc.Config.verify|verify} messages.
             * @function encode
             * @memberof anytype.Rpc.Config
             * @static
             * @param {anytype.Rpc.IConfig} message Config message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Config.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Config message, length delimited. Does not implicitly {@link anytype.Rpc.Config.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Rpc.Config
             * @static
             * @param {anytype.Rpc.IConfig} message Config message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Config.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Config message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Rpc.Config
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Rpc.Config} Config
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Config.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Config();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Config message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Rpc.Config
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Rpc.Config} Config
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Config.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Config message.
             * @function verify
             * @memberof anytype.Rpc.Config
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Config.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Config message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Rpc.Config
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Rpc.Config} Config
             */
            Config.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Rpc.Config)
                    return object;
                return new $root.anytype.Rpc.Config();
            };

            /**
             * Creates a plain object from a Config message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Rpc.Config
             * @static
             * @param {anytype.Rpc.Config} message Config
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Config.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Config to JSON.
             * @function toJSON
             * @memberof anytype.Rpc.Config
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Config.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Config.Get = (function() {

                /**
                 * Properties of a Get.
                 * @memberof anytype.Rpc.Config
                 * @interface IGet
                 */

                /**
                 * Constructs a new Get.
                 * @memberof anytype.Rpc.Config
                 * @classdesc Represents a Get.
                 * @implements IGet
                 * @constructor
                 * @param {anytype.Rpc.Config.IGet=} [properties] Properties to set
                 */
                function Get(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Get instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Config.Get
                 * @static
                 * @param {anytype.Rpc.Config.IGet=} [properties] Properties to set
                 * @returns {anytype.Rpc.Config.Get} Get instance
                 */
                Get.create = function create(properties) {
                    return new Get(properties);
                };

                /**
                 * Encodes the specified Get message. Does not implicitly {@link anytype.Rpc.Config.Get.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Config.Get
                 * @static
                 * @param {anytype.Rpc.Config.IGet} message Get message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Get.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Get message, length delimited. Does not implicitly {@link anytype.Rpc.Config.Get.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Config.Get
                 * @static
                 * @param {anytype.Rpc.Config.IGet} message Get message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Get.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Get message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Config.Get
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Config.Get} Get
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Get.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Config.Get();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Get message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Config.Get
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Config.Get} Get
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Get.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Get message.
                 * @function verify
                 * @memberof anytype.Rpc.Config.Get
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Get.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Get message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Config.Get
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Config.Get} Get
                 */
                Get.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Config.Get)
                        return object;
                    return new $root.anytype.Rpc.Config.Get();
                };

                /**
                 * Creates a plain object from a Get message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Config.Get
                 * @static
                 * @param {anytype.Rpc.Config.Get} message Get
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Get.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Get to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Config.Get
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Get.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Get.Request = (function() {

                    /**
                     * Properties of a Request.
                     * @memberof anytype.Rpc.Config.Get
                     * @interface IRequest
                     */

                    /**
                     * Constructs a new Request.
                     * @memberof anytype.Rpc.Config.Get
                     * @classdesc Represents a Request.
                     * @implements IRequest
                     * @constructor
                     * @param {anytype.Rpc.Config.Get.IRequest=} [properties] Properties to set
                     */
                    function Request(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Request instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Config.Get.Request
                     * @static
                     * @param {anytype.Rpc.Config.Get.IRequest=} [properties] Properties to set
                     * @returns {anytype.Rpc.Config.Get.Request} Request instance
                     */
                    Request.create = function create(properties) {
                        return new Request(properties);
                    };

                    /**
                     * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Config.Get.Request.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Config.Get.Request
                     * @static
                     * @param {anytype.Rpc.Config.Get.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Config.Get.Request.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Config.Get.Request
                     * @static
                     * @param {anytype.Rpc.Config.Get.IRequest} message Request message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Request.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Config.Get.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Config.Get.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Config.Get.Request();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Request message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Config.Get.Request
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Config.Get.Request} Request
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Request.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Request message.
                     * @function verify
                     * @memberof anytype.Rpc.Config.Get.Request
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Request.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Request message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Config.Get.Request
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Config.Get.Request} Request
                     */
                    Request.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Config.Get.Request)
                            return object;
                        return new $root.anytype.Rpc.Config.Get.Request();
                    };

                    /**
                     * Creates a plain object from a Request message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Config.Get.Request
                     * @static
                     * @param {anytype.Rpc.Config.Get.Request} message Request
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Request.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Request to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Config.Get.Request
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Request.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Request;
                })();

                Get.Response = (function() {

                    /**
                     * Properties of a Response.
                     * @memberof anytype.Rpc.Config.Get
                     * @interface IResponse
                     * @property {anytype.Rpc.Config.Get.Response.IError|null} [error] Response error
                     * @property {string|null} [homeBlockId] Response homeBlockId
                     */

                    /**
                     * Constructs a new Response.
                     * @memberof anytype.Rpc.Config.Get
                     * @classdesc Represents a Response.
                     * @implements IResponse
                     * @constructor
                     * @param {anytype.Rpc.Config.Get.IResponse=} [properties] Properties to set
                     */
                    function Response(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Response error.
                     * @member {anytype.Rpc.Config.Get.Response.IError|null|undefined} error
                     * @memberof anytype.Rpc.Config.Get.Response
                     * @instance
                     */
                    Response.prototype.error = null;

                    /**
                     * Response homeBlockId.
                     * @member {string} homeBlockId
                     * @memberof anytype.Rpc.Config.Get.Response
                     * @instance
                     */
                    Response.prototype.homeBlockId = "";

                    /**
                     * Creates a new Response instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Config.Get.Response
                     * @static
                     * @param {anytype.Rpc.Config.Get.IResponse=} [properties] Properties to set
                     * @returns {anytype.Rpc.Config.Get.Response} Response instance
                     */
                    Response.create = function create(properties) {
                        return new Response(properties);
                    };

                    /**
                     * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Config.Get.Response.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Config.Get.Response
                     * @static
                     * @param {anytype.Rpc.Config.Get.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.error != null && message.hasOwnProperty("error"))
                            $root.anytype.Rpc.Config.Get.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.homeBlockId != null && message.hasOwnProperty("homeBlockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.homeBlockId);
                        return writer;
                    };

                    /**
                     * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Config.Get.Response.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Config.Get.Response
                     * @static
                     * @param {anytype.Rpc.Config.Get.IResponse} message Response message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Response.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Config.Get.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Config.Get.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Config.Get.Response();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.error = $root.anytype.Rpc.Config.Get.Response.Error.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.homeBlockId = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Response message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Config.Get.Response
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Config.Get.Response} Response
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Response.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Response message.
                     * @function verify
                     * @memberof anytype.Rpc.Config.Get.Response
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Response.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.error != null && message.hasOwnProperty("error")) {
                            var error = $root.anytype.Rpc.Config.Get.Response.Error.verify(message.error);
                            if (error)
                                return "error." + error;
                        }
                        if (message.homeBlockId != null && message.hasOwnProperty("homeBlockId"))
                            if (!$util.isString(message.homeBlockId))
                                return "homeBlockId: string expected";
                        return null;
                    };

                    /**
                     * Creates a Response message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Config.Get.Response
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Config.Get.Response} Response
                     */
                    Response.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Config.Get.Response)
                            return object;
                        var message = new $root.anytype.Rpc.Config.Get.Response();
                        if (object.error != null) {
                            if (typeof object.error !== "object")
                                throw TypeError(".anytype.Rpc.Config.Get.Response.error: object expected");
                            message.error = $root.anytype.Rpc.Config.Get.Response.Error.fromObject(object.error);
                        }
                        if (object.homeBlockId != null)
                            message.homeBlockId = String(object.homeBlockId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Response message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Config.Get.Response
                     * @static
                     * @param {anytype.Rpc.Config.Get.Response} message Response
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Response.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.error = null;
                            object.homeBlockId = "";
                        }
                        if (message.error != null && message.hasOwnProperty("error"))
                            object.error = $root.anytype.Rpc.Config.Get.Response.Error.toObject(message.error, options);
                        if (message.homeBlockId != null && message.hasOwnProperty("homeBlockId"))
                            object.homeBlockId = message.homeBlockId;
                        return object;
                    };

                    /**
                     * Converts this Response to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Config.Get.Response
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Response.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Response.Error = (function() {

                        /**
                         * Properties of an Error.
                         * @memberof anytype.Rpc.Config.Get.Response
                         * @interface IError
                         * @property {anytype.Rpc.Config.Get.Response.Error.Code|null} [code] Error code
                         * @property {string|null} [description] Error description
                         */

                        /**
                         * Constructs a new Error.
                         * @memberof anytype.Rpc.Config.Get.Response
                         * @classdesc Represents an Error.
                         * @implements IError
                         * @constructor
                         * @param {anytype.Rpc.Config.Get.Response.IError=} [properties] Properties to set
                         */
                        function Error(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Error code.
                         * @member {anytype.Rpc.Config.Get.Response.Error.Code} code
                         * @memberof anytype.Rpc.Config.Get.Response.Error
                         * @instance
                         */
                        Error.prototype.code = 0;

                        /**
                         * Error description.
                         * @member {string} description
                         * @memberof anytype.Rpc.Config.Get.Response.Error
                         * @instance
                         */
                        Error.prototype.description = "";

                        /**
                         * Creates a new Error instance using the specified properties.
                         * @function create
                         * @memberof anytype.Rpc.Config.Get.Response.Error
                         * @static
                         * @param {anytype.Rpc.Config.Get.Response.IError=} [properties] Properties to set
                         * @returns {anytype.Rpc.Config.Get.Response.Error} Error instance
                         */
                        Error.create = function create(properties) {
                            return new Error(properties);
                        };

                        /**
                         * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Config.Get.Response.Error.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Rpc.Config.Get.Response.Error
                         * @static
                         * @param {anytype.Rpc.Config.Get.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.code != null && message.hasOwnProperty("code"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                            if (message.description != null && message.hasOwnProperty("description"))
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                            return writer;
                        };

                        /**
                         * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Config.Get.Response.Error.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Rpc.Config.Get.Response.Error
                         * @static
                         * @param {anytype.Rpc.Config.Get.Response.IError} message Error message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Error.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Rpc.Config.Get.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Rpc.Config.Get.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Config.Get.Response.Error();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.code = reader.int32();
                                    break;
                                case 2:
                                    message.description = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes an Error message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Rpc.Config.Get.Response.Error
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Rpc.Config.Get.Response.Error} Error
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Error.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies an Error message.
                         * @function verify
                         * @memberof anytype.Rpc.Config.Get.Response.Error
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Error.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.code != null && message.hasOwnProperty("code"))
                                switch (message.code) {
                                default:
                                    return "code: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.description != null && message.hasOwnProperty("description"))
                                if (!$util.isString(message.description))
                                    return "description: string expected";
                            return null;
                        };

                        /**
                         * Creates an Error message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Rpc.Config.Get.Response.Error
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Rpc.Config.Get.Response.Error} Error
                         */
                        Error.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Rpc.Config.Get.Response.Error)
                                return object;
                            var message = new $root.anytype.Rpc.Config.Get.Response.Error();
                            switch (object.code) {
                            case "NULL":
                            case 0:
                                message.code = 0;
                                break;
                            case "UNKNOWN_ERROR":
                            case 1:
                                message.code = 1;
                                break;
                            case "BAD_INPUT":
                            case 2:
                                message.code = 2;
                                break;
                            }
                            if (object.description != null)
                                message.description = String(object.description);
                            return message;
                        };

                        /**
                         * Creates a plain object from an Error message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Rpc.Config.Get.Response.Error
                         * @static
                         * @param {anytype.Rpc.Config.Get.Response.Error} message Error
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Error.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.code = options.enums === String ? "NULL" : 0;
                                object.description = "";
                            }
                            if (message.code != null && message.hasOwnProperty("code"))
                                object.code = options.enums === String ? $root.anytype.Rpc.Config.Get.Response.Error.Code[message.code] : message.code;
                            if (message.description != null && message.hasOwnProperty("description"))
                                object.description = message.description;
                            return object;
                        };

                        /**
                         * Converts this Error to JSON.
                         * @function toJSON
                         * @memberof anytype.Rpc.Config.Get.Response.Error
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Error.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Code enum.
                         * @name anytype.Rpc.Config.Get.Response.Error.Code
                         * @enum {string}
                         * @property {number} NULL=0 NULL value
                         * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                         * @property {number} BAD_INPUT=2 BAD_INPUT value
                         */
                        Error.Code = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "NULL"] = 0;
                            values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                            values[valuesById[2] = "BAD_INPUT"] = 2;
                            return values;
                        })();

                        return Error;
                    })();

                    return Response;
                })();

                return Get;
            })();

            return Config;
        })();

        Rpc.Ping = (function() {

            /**
             * Properties of a Ping.
             * @memberof anytype.Rpc
             * @interface IPing
             */

            /**
             * Constructs a new Ping.
             * @memberof anytype.Rpc
             * @classdesc Represents a Ping.
             * @implements IPing
             * @constructor
             * @param {anytype.Rpc.IPing=} [properties] Properties to set
             */
            function Ping(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Ping instance using the specified properties.
             * @function create
             * @memberof anytype.Rpc.Ping
             * @static
             * @param {anytype.Rpc.IPing=} [properties] Properties to set
             * @returns {anytype.Rpc.Ping} Ping instance
             */
            Ping.create = function create(properties) {
                return new Ping(properties);
            };

            /**
             * Encodes the specified Ping message. Does not implicitly {@link anytype.Rpc.Ping.verify|verify} messages.
             * @function encode
             * @memberof anytype.Rpc.Ping
             * @static
             * @param {anytype.Rpc.IPing} message Ping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ping.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Ping message, length delimited. Does not implicitly {@link anytype.Rpc.Ping.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Rpc.Ping
             * @static
             * @param {anytype.Rpc.IPing} message Ping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ping.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Ping message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Rpc.Ping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Rpc.Ping} Ping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ping.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ping();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Ping message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Rpc.Ping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Rpc.Ping} Ping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ping.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Ping message.
             * @function verify
             * @memberof anytype.Rpc.Ping
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Ping.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Ping message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Rpc.Ping
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Rpc.Ping} Ping
             */
            Ping.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Rpc.Ping)
                    return object;
                return new $root.anytype.Rpc.Ping();
            };

            /**
             * Creates a plain object from a Ping message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Rpc.Ping
             * @static
             * @param {anytype.Rpc.Ping} message Ping
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Ping.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Ping to JSON.
             * @function toJSON
             * @memberof anytype.Rpc.Ping
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Ping.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Ping.Request = (function() {

                /**
                 * Properties of a Request.
                 * @memberof anytype.Rpc.Ping
                 * @interface IRequest
                 * @property {number|null} [index] Request index
                 * @property {number|null} [numberOfEventsToSend] Request numberOfEventsToSend
                 */

                /**
                 * Constructs a new Request.
                 * @memberof anytype.Rpc.Ping
                 * @classdesc Represents a Request.
                 * @implements IRequest
                 * @constructor
                 * @param {anytype.Rpc.Ping.IRequest=} [properties] Properties to set
                 */
                function Request(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Request index.
                 * @member {number} index
                 * @memberof anytype.Rpc.Ping.Request
                 * @instance
                 */
                Request.prototype.index = 0;

                /**
                 * Request numberOfEventsToSend.
                 * @member {number} numberOfEventsToSend
                 * @memberof anytype.Rpc.Ping.Request
                 * @instance
                 */
                Request.prototype.numberOfEventsToSend = 0;

                /**
                 * Creates a new Request instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Ping.Request
                 * @static
                 * @param {anytype.Rpc.Ping.IRequest=} [properties] Properties to set
                 * @returns {anytype.Rpc.Ping.Request} Request instance
                 */
                Request.create = function create(properties) {
                    return new Request(properties);
                };

                /**
                 * Encodes the specified Request message. Does not implicitly {@link anytype.Rpc.Ping.Request.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Ping.Request
                 * @static
                 * @param {anytype.Rpc.Ping.IRequest} message Request message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Request.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && message.hasOwnProperty("index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                    if (message.numberOfEventsToSend != null && message.hasOwnProperty("numberOfEventsToSend"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.numberOfEventsToSend);
                    return writer;
                };

                /**
                 * Encodes the specified Request message, length delimited. Does not implicitly {@link anytype.Rpc.Ping.Request.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Ping.Request
                 * @static
                 * @param {anytype.Rpc.Ping.IRequest} message Request message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Request.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Request message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Ping.Request
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Ping.Request} Request
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Request.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ping.Request();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.index = reader.int32();
                            break;
                        case 2:
                            message.numberOfEventsToSend = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Request message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Ping.Request
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Ping.Request} Request
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Request.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Request message.
                 * @function verify
                 * @memberof anytype.Rpc.Ping.Request
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Request.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.index != null && message.hasOwnProperty("index"))
                        if (!$util.isInteger(message.index))
                            return "index: integer expected";
                    if (message.numberOfEventsToSend != null && message.hasOwnProperty("numberOfEventsToSend"))
                        if (!$util.isInteger(message.numberOfEventsToSend))
                            return "numberOfEventsToSend: integer expected";
                    return null;
                };

                /**
                 * Creates a Request message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Ping.Request
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Ping.Request} Request
                 */
                Request.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Ping.Request)
                        return object;
                    var message = new $root.anytype.Rpc.Ping.Request();
                    if (object.index != null)
                        message.index = object.index | 0;
                    if (object.numberOfEventsToSend != null)
                        message.numberOfEventsToSend = object.numberOfEventsToSend | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Request message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Ping.Request
                 * @static
                 * @param {anytype.Rpc.Ping.Request} message Request
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Request.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.index = 0;
                        object.numberOfEventsToSend = 0;
                    }
                    if (message.index != null && message.hasOwnProperty("index"))
                        object.index = message.index;
                    if (message.numberOfEventsToSend != null && message.hasOwnProperty("numberOfEventsToSend"))
                        object.numberOfEventsToSend = message.numberOfEventsToSend;
                    return object;
                };

                /**
                 * Converts this Request to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Ping.Request
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Request.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Request;
            })();

            Ping.Response = (function() {

                /**
                 * Properties of a Response.
                 * @memberof anytype.Rpc.Ping
                 * @interface IResponse
                 * @property {anytype.Rpc.Ping.Response.IError|null} [error] Response error
                 * @property {number|null} [index] Response index
                 */

                /**
                 * Constructs a new Response.
                 * @memberof anytype.Rpc.Ping
                 * @classdesc Represents a Response.
                 * @implements IResponse
                 * @constructor
                 * @param {anytype.Rpc.Ping.IResponse=} [properties] Properties to set
                 */
                function Response(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Response error.
                 * @member {anytype.Rpc.Ping.Response.IError|null|undefined} error
                 * @memberof anytype.Rpc.Ping.Response
                 * @instance
                 */
                Response.prototype.error = null;

                /**
                 * Response index.
                 * @member {number} index
                 * @memberof anytype.Rpc.Ping.Response
                 * @instance
                 */
                Response.prototype.index = 0;

                /**
                 * Creates a new Response instance using the specified properties.
                 * @function create
                 * @memberof anytype.Rpc.Ping.Response
                 * @static
                 * @param {anytype.Rpc.Ping.IResponse=} [properties] Properties to set
                 * @returns {anytype.Rpc.Ping.Response} Response instance
                 */
                Response.create = function create(properties) {
                    return new Response(properties);
                };

                /**
                 * Encodes the specified Response message. Does not implicitly {@link anytype.Rpc.Ping.Response.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Rpc.Ping.Response
                 * @static
                 * @param {anytype.Rpc.Ping.IResponse} message Response message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Response.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.error != null && message.hasOwnProperty("error"))
                        $root.anytype.Rpc.Ping.Response.Error.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.index != null && message.hasOwnProperty("index"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
                    return writer;
                };

                /**
                 * Encodes the specified Response message, length delimited. Does not implicitly {@link anytype.Rpc.Ping.Response.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Rpc.Ping.Response
                 * @static
                 * @param {anytype.Rpc.Ping.IResponse} message Response message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Response.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Response message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Rpc.Ping.Response
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Rpc.Ping.Response} Response
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Response.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ping.Response();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.error = $root.anytype.Rpc.Ping.Response.Error.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.index = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Response message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Rpc.Ping.Response
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Rpc.Ping.Response} Response
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Response.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Response message.
                 * @function verify
                 * @memberof anytype.Rpc.Ping.Response
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Response.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.anytype.Rpc.Ping.Response.Error.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    if (message.index != null && message.hasOwnProperty("index"))
                        if (!$util.isInteger(message.index))
                            return "index: integer expected";
                    return null;
                };

                /**
                 * Creates a Response message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Rpc.Ping.Response
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Rpc.Ping.Response} Response
                 */
                Response.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Rpc.Ping.Response)
                        return object;
                    var message = new $root.anytype.Rpc.Ping.Response();
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".anytype.Rpc.Ping.Response.error: object expected");
                        message.error = $root.anytype.Rpc.Ping.Response.Error.fromObject(object.error);
                    }
                    if (object.index != null)
                        message.index = object.index | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Response message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Rpc.Ping.Response
                 * @static
                 * @param {anytype.Rpc.Ping.Response} message Response
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Response.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.error = null;
                        object.index = 0;
                    }
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.anytype.Rpc.Ping.Response.Error.toObject(message.error, options);
                    if (message.index != null && message.hasOwnProperty("index"))
                        object.index = message.index;
                    return object;
                };

                /**
                 * Converts this Response to JSON.
                 * @function toJSON
                 * @memberof anytype.Rpc.Ping.Response
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Response.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Response.Error = (function() {

                    /**
                     * Properties of an Error.
                     * @memberof anytype.Rpc.Ping.Response
                     * @interface IError
                     * @property {anytype.Rpc.Ping.Response.Error.Code|null} [code] Error code
                     * @property {string|null} [description] Error description
                     */

                    /**
                     * Constructs a new Error.
                     * @memberof anytype.Rpc.Ping.Response
                     * @classdesc Represents an Error.
                     * @implements IError
                     * @constructor
                     * @param {anytype.Rpc.Ping.Response.IError=} [properties] Properties to set
                     */
                    function Error(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Error code.
                     * @member {anytype.Rpc.Ping.Response.Error.Code} code
                     * @memberof anytype.Rpc.Ping.Response.Error
                     * @instance
                     */
                    Error.prototype.code = 0;

                    /**
                     * Error description.
                     * @member {string} description
                     * @memberof anytype.Rpc.Ping.Response.Error
                     * @instance
                     */
                    Error.prototype.description = "";

                    /**
                     * Creates a new Error instance using the specified properties.
                     * @function create
                     * @memberof anytype.Rpc.Ping.Response.Error
                     * @static
                     * @param {anytype.Rpc.Ping.Response.IError=} [properties] Properties to set
                     * @returns {anytype.Rpc.Ping.Response.Error} Error instance
                     */
                    Error.create = function create(properties) {
                        return new Error(properties);
                    };

                    /**
                     * Encodes the specified Error message. Does not implicitly {@link anytype.Rpc.Ping.Response.Error.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Rpc.Ping.Response.Error
                     * @static
                     * @param {anytype.Rpc.Ping.Response.IError} message Error message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Error.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.code != null && message.hasOwnProperty("code"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                        if (message.description != null && message.hasOwnProperty("description"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.description);
                        return writer;
                    };

                    /**
                     * Encodes the specified Error message, length delimited. Does not implicitly {@link anytype.Rpc.Ping.Response.Error.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Rpc.Ping.Response.Error
                     * @static
                     * @param {anytype.Rpc.Ping.Response.IError} message Error message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Error.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Error message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Rpc.Ping.Response.Error
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Rpc.Ping.Response.Error} Error
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Error.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Rpc.Ping.Response.Error();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.code = reader.int32();
                                break;
                            case 2:
                                message.description = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Error message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Rpc.Ping.Response.Error
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Rpc.Ping.Response.Error} Error
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Error.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Error message.
                     * @function verify
                     * @memberof anytype.Rpc.Ping.Response.Error
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Error.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.code != null && message.hasOwnProperty("code"))
                            switch (message.code) {
                            default:
                                return "code: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        if (message.description != null && message.hasOwnProperty("description"))
                            if (!$util.isString(message.description))
                                return "description: string expected";
                        return null;
                    };

                    /**
                     * Creates an Error message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Rpc.Ping.Response.Error
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Rpc.Ping.Response.Error} Error
                     */
                    Error.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Rpc.Ping.Response.Error)
                            return object;
                        var message = new $root.anytype.Rpc.Ping.Response.Error();
                        switch (object.code) {
                        case "NULL":
                        case 0:
                            message.code = 0;
                            break;
                        case "UNKNOWN_ERROR":
                        case 1:
                            message.code = 1;
                            break;
                        case "BAD_INPUT":
                        case 2:
                            message.code = 2;
                            break;
                        }
                        if (object.description != null)
                            message.description = String(object.description);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Error message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Rpc.Ping.Response.Error
                     * @static
                     * @param {anytype.Rpc.Ping.Response.Error} message Error
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Error.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.code = options.enums === String ? "NULL" : 0;
                            object.description = "";
                        }
                        if (message.code != null && message.hasOwnProperty("code"))
                            object.code = options.enums === String ? $root.anytype.Rpc.Ping.Response.Error.Code[message.code] : message.code;
                        if (message.description != null && message.hasOwnProperty("description"))
                            object.description = message.description;
                        return object;
                    };

                    /**
                     * Converts this Error to JSON.
                     * @function toJSON
                     * @memberof anytype.Rpc.Ping.Response.Error
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Error.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Code enum.
                     * @name anytype.Rpc.Ping.Response.Error.Code
                     * @enum {string}
                     * @property {number} NULL=0 NULL value
                     * @property {number} UNKNOWN_ERROR=1 UNKNOWN_ERROR value
                     * @property {number} BAD_INPUT=2 BAD_INPUT value
                     */
                    Error.Code = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "NULL"] = 0;
                        values[valuesById[1] = "UNKNOWN_ERROR"] = 1;
                        values[valuesById[2] = "BAD_INPUT"] = 2;
                        return values;
                    })();

                    return Error;
                })();

                return Response;
            })();

            return Ping;
        })();

        return Rpc;
    })();

    anytype.Event = (function() {

        /**
         * Properties of an Event.
         * @memberof anytype
         * @interface IEvent
         * @property {Array.<anytype.Event.IMessage>|null} [messages] Event messages
         * @property {string|null} [contextId] Event contextId
         * @property {anytype.model.IAccount|null} [initiator] Event initiator
         */

        /**
         * Constructs a new Event.
         * @memberof anytype
         * @classdesc Represents an Event.
         * @implements IEvent
         * @constructor
         * @param {anytype.IEvent=} [properties] Properties to set
         */
        function Event(properties) {
            this.messages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Event messages.
         * @member {Array.<anytype.Event.IMessage>} messages
         * @memberof anytype.Event
         * @instance
         */
        Event.prototype.messages = $util.emptyArray;

        /**
         * Event contextId.
         * @member {string} contextId
         * @memberof anytype.Event
         * @instance
         */
        Event.prototype.contextId = "";

        /**
         * Event initiator.
         * @member {anytype.model.IAccount|null|undefined} initiator
         * @memberof anytype.Event
         * @instance
         */
        Event.prototype.initiator = null;

        /**
         * Creates a new Event instance using the specified properties.
         * @function create
         * @memberof anytype.Event
         * @static
         * @param {anytype.IEvent=} [properties] Properties to set
         * @returns {anytype.Event} Event instance
         */
        Event.create = function create(properties) {
            return new Event(properties);
        };

        /**
         * Encodes the specified Event message. Does not implicitly {@link anytype.Event.verify|verify} messages.
         * @function encode
         * @memberof anytype.Event
         * @static
         * @param {anytype.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messages != null && message.messages.length)
                for (var i = 0; i < message.messages.length; ++i)
                    $root.anytype.Event.Message.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.contextId);
            if (message.initiator != null && message.hasOwnProperty("initiator"))
                $root.anytype.model.Account.encode(message.initiator, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Event message, length delimited. Does not implicitly {@link anytype.Event.verify|verify} messages.
         * @function encodeDelimited
         * @memberof anytype.Event
         * @static
         * @param {anytype.IEvent} message Event message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Event.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Event message from the specified reader or buffer.
         * @function decode
         * @memberof anytype.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {anytype.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.messages && message.messages.length))
                        message.messages = [];
                    message.messages.push($root.anytype.Event.Message.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.contextId = reader.string();
                    break;
                case 3:
                    message.initiator = $root.anytype.model.Account.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Event message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof anytype.Event
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {anytype.Event} Event
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Event.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Event message.
         * @function verify
         * @memberof anytype.Event
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Event.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messages != null && message.hasOwnProperty("messages")) {
                if (!Array.isArray(message.messages))
                    return "messages: array expected";
                for (var i = 0; i < message.messages.length; ++i) {
                    var error = $root.anytype.Event.Message.verify(message.messages[i]);
                    if (error)
                        return "messages." + error;
                }
            }
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                if (!$util.isString(message.contextId))
                    return "contextId: string expected";
            if (message.initiator != null && message.hasOwnProperty("initiator")) {
                var error = $root.anytype.model.Account.verify(message.initiator);
                if (error)
                    return "initiator." + error;
            }
            return null;
        };

        /**
         * Creates an Event message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof anytype.Event
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {anytype.Event} Event
         */
        Event.fromObject = function fromObject(object) {
            if (object instanceof $root.anytype.Event)
                return object;
            var message = new $root.anytype.Event();
            if (object.messages) {
                if (!Array.isArray(object.messages))
                    throw TypeError(".anytype.Event.messages: array expected");
                message.messages = [];
                for (var i = 0; i < object.messages.length; ++i) {
                    if (typeof object.messages[i] !== "object")
                        throw TypeError(".anytype.Event.messages: object expected");
                    message.messages[i] = $root.anytype.Event.Message.fromObject(object.messages[i]);
                }
            }
            if (object.contextId != null)
                message.contextId = String(object.contextId);
            if (object.initiator != null) {
                if (typeof object.initiator !== "object")
                    throw TypeError(".anytype.Event.initiator: object expected");
                message.initiator = $root.anytype.model.Account.fromObject(object.initiator);
            }
            return message;
        };

        /**
         * Creates a plain object from an Event message. Also converts values to other types if specified.
         * @function toObject
         * @memberof anytype.Event
         * @static
         * @param {anytype.Event} message Event
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Event.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.messages = [];
            if (options.defaults) {
                object.contextId = "";
                object.initiator = null;
            }
            if (message.messages && message.messages.length) {
                object.messages = [];
                for (var j = 0; j < message.messages.length; ++j)
                    object.messages[j] = $root.anytype.Event.Message.toObject(message.messages[j], options);
            }
            if (message.contextId != null && message.hasOwnProperty("contextId"))
                object.contextId = message.contextId;
            if (message.initiator != null && message.hasOwnProperty("initiator"))
                object.initiator = $root.anytype.model.Account.toObject(message.initiator, options);
            return object;
        };

        /**
         * Converts this Event to JSON.
         * @function toJSON
         * @memberof anytype.Event
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Event.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        Event.Message = (function() {

            /**
             * Properties of a Message.
             * @memberof anytype.Event
             * @interface IMessage
             * @property {anytype.Event.Account.IShow|null} [accountShow] Message accountShow
             * @property {anytype.Event.Block.IAdd|null} [blockAdd] Message blockAdd
             * @property {anytype.Event.Block.IDelete|null} [blockDelete] Message blockDelete
             * @property {anytype.Event.Block.IFilesUpload|null} [filesUpload] Message filesUpload
             * @property {anytype.Event.Block.IMarksInfo|null} [marksInfo] Message marksInfo
             * @property {anytype.Event.Block.Set.IFields|null} [blockSetFields] Message blockSetFields
             * @property {anytype.Event.Block.Set.IChildrenIds|null} [blockSetChildrenIds] Message blockSetChildrenIds
             * @property {anytype.Event.Block.Set.IRestrictions|null} [blockSetRestrictions] Message blockSetRestrictions
             * @property {anytype.Event.Block.Set.IIsArchived|null} [blockSetIsArchived] Message blockSetIsArchived
             * @property {anytype.Event.Block.Set.IText|null} [blockSetText] Message blockSetText
             * @property {anytype.Event.Block.Set.IFile|null} [blockSetFile] Message blockSetFile
             * @property {anytype.Event.Block.Set.IIcon|null} [blockSetIcon] Message blockSetIcon
             * @property {anytype.Event.Block.IShow|null} [blockShow] Message blockShow
             * @property {anytype.Event.User.Block.IJoin|null} [userBlockJoin] Message userBlockJoin
             * @property {anytype.Event.User.Block.ILeft|null} [userBlockLeft] Message userBlockLeft
             * @property {anytype.Event.User.Block.ISelectRange|null} [userBlockSelectRange] Message userBlockSelectRange
             * @property {anytype.Event.User.Block.ITextRange|null} [userBlockTextRange] Message userBlockTextRange
             * @property {anytype.Event.IPing|null} [ping] Message ping
             */

            /**
             * Constructs a new Message.
             * @memberof anytype.Event
             * @classdesc Represents a Message.
             * @implements IMessage
             * @constructor
             * @param {anytype.Event.IMessage=} [properties] Properties to set
             */
            function Message(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Message accountShow.
             * @member {anytype.Event.Account.IShow|null|undefined} accountShow
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.accountShow = null;

            /**
             * Message blockAdd.
             * @member {anytype.Event.Block.IAdd|null|undefined} blockAdd
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.blockAdd = null;

            /**
             * Message blockDelete.
             * @member {anytype.Event.Block.IDelete|null|undefined} blockDelete
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.blockDelete = null;

            /**
             * Message filesUpload.
             * @member {anytype.Event.Block.IFilesUpload|null|undefined} filesUpload
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.filesUpload = null;

            /**
             * Message marksInfo.
             * @member {anytype.Event.Block.IMarksInfo|null|undefined} marksInfo
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.marksInfo = null;

            /**
             * Message blockSetFields.
             * @member {anytype.Event.Block.Set.IFields|null|undefined} blockSetFields
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.blockSetFields = null;

            /**
             * Message blockSetChildrenIds.
             * @member {anytype.Event.Block.Set.IChildrenIds|null|undefined} blockSetChildrenIds
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.blockSetChildrenIds = null;

            /**
             * Message blockSetRestrictions.
             * @member {anytype.Event.Block.Set.IRestrictions|null|undefined} blockSetRestrictions
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.blockSetRestrictions = null;

            /**
             * Message blockSetIsArchived.
             * @member {anytype.Event.Block.Set.IIsArchived|null|undefined} blockSetIsArchived
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.blockSetIsArchived = null;

            /**
             * Message blockSetText.
             * @member {anytype.Event.Block.Set.IText|null|undefined} blockSetText
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.blockSetText = null;

            /**
             * Message blockSetFile.
             * @member {anytype.Event.Block.Set.IFile|null|undefined} blockSetFile
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.blockSetFile = null;

            /**
             * Message blockSetIcon.
             * @member {anytype.Event.Block.Set.IIcon|null|undefined} blockSetIcon
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.blockSetIcon = null;

            /**
             * Message blockShow.
             * @member {anytype.Event.Block.IShow|null|undefined} blockShow
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.blockShow = null;

            /**
             * Message userBlockJoin.
             * @member {anytype.Event.User.Block.IJoin|null|undefined} userBlockJoin
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.userBlockJoin = null;

            /**
             * Message userBlockLeft.
             * @member {anytype.Event.User.Block.ILeft|null|undefined} userBlockLeft
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.userBlockLeft = null;

            /**
             * Message userBlockSelectRange.
             * @member {anytype.Event.User.Block.ISelectRange|null|undefined} userBlockSelectRange
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.userBlockSelectRange = null;

            /**
             * Message userBlockTextRange.
             * @member {anytype.Event.User.Block.ITextRange|null|undefined} userBlockTextRange
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.userBlockTextRange = null;

            /**
             * Message ping.
             * @member {anytype.Event.IPing|null|undefined} ping
             * @memberof anytype.Event.Message
             * @instance
             */
            Message.prototype.ping = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Message value.
             * @member {"accountShow"|"blockAdd"|"blockDelete"|"filesUpload"|"marksInfo"|"blockSetFields"|"blockSetChildrenIds"|"blockSetRestrictions"|"blockSetIsArchived"|"blockSetText"|"blockSetFile"|"blockSetIcon"|"blockShow"|"userBlockJoin"|"userBlockLeft"|"userBlockSelectRange"|"userBlockTextRange"|"ping"|undefined} value
             * @memberof anytype.Event.Message
             * @instance
             */
            Object.defineProperty(Message.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["accountShow", "blockAdd", "blockDelete", "filesUpload", "marksInfo", "blockSetFields", "blockSetChildrenIds", "blockSetRestrictions", "blockSetIsArchived", "blockSetText", "blockSetFile", "blockSetIcon", "blockShow", "userBlockJoin", "userBlockLeft", "userBlockSelectRange", "userBlockTextRange", "ping"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Message instance using the specified properties.
             * @function create
             * @memberof anytype.Event.Message
             * @static
             * @param {anytype.Event.IMessage=} [properties] Properties to set
             * @returns {anytype.Event.Message} Message instance
             */
            Message.create = function create(properties) {
                return new Message(properties);
            };

            /**
             * Encodes the specified Message message. Does not implicitly {@link anytype.Event.Message.verify|verify} messages.
             * @function encode
             * @memberof anytype.Event.Message
             * @static
             * @param {anytype.Event.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accountShow != null && message.hasOwnProperty("accountShow"))
                    $root.anytype.Event.Account.Show.encode(message.accountShow, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.blockAdd != null && message.hasOwnProperty("blockAdd"))
                    $root.anytype.Event.Block.Add.encode(message.blockAdd, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.blockDelete != null && message.hasOwnProperty("blockDelete"))
                    $root.anytype.Event.Block.Delete.encode(message.blockDelete, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.filesUpload != null && message.hasOwnProperty("filesUpload"))
                    $root.anytype.Event.Block.FilesUpload.encode(message.filesUpload, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.marksInfo != null && message.hasOwnProperty("marksInfo"))
                    $root.anytype.Event.Block.MarksInfo.encode(message.marksInfo, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.blockSetFields != null && message.hasOwnProperty("blockSetFields"))
                    $root.anytype.Event.Block.Set.Fields.encode(message.blockSetFields, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.blockSetChildrenIds != null && message.hasOwnProperty("blockSetChildrenIds"))
                    $root.anytype.Event.Block.Set.ChildrenIds.encode(message.blockSetChildrenIds, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.blockSetRestrictions != null && message.hasOwnProperty("blockSetRestrictions"))
                    $root.anytype.Event.Block.Set.Restrictions.encode(message.blockSetRestrictions, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.blockSetIsArchived != null && message.hasOwnProperty("blockSetIsArchived"))
                    $root.anytype.Event.Block.Set.IsArchived.encode(message.blockSetIsArchived, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.blockSetText != null && message.hasOwnProperty("blockSetText"))
                    $root.anytype.Event.Block.Set.Text.encode(message.blockSetText, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.blockSetFile != null && message.hasOwnProperty("blockSetFile"))
                    $root.anytype.Event.Block.Set.File.encode(message.blockSetFile, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.blockSetIcon != null && message.hasOwnProperty("blockSetIcon"))
                    $root.anytype.Event.Block.Set.Icon.encode(message.blockSetIcon, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.blockShow != null && message.hasOwnProperty("blockShow"))
                    $root.anytype.Event.Block.Show.encode(message.blockShow, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.userBlockJoin != null && message.hasOwnProperty("userBlockJoin"))
                    $root.anytype.Event.User.Block.Join.encode(message.userBlockJoin, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.userBlockLeft != null && message.hasOwnProperty("userBlockLeft"))
                    $root.anytype.Event.User.Block.Left.encode(message.userBlockLeft, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.userBlockSelectRange != null && message.hasOwnProperty("userBlockSelectRange"))
                    $root.anytype.Event.User.Block.SelectRange.encode(message.userBlockSelectRange, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.userBlockTextRange != null && message.hasOwnProperty("userBlockTextRange"))
                    $root.anytype.Event.User.Block.TextRange.encode(message.userBlockTextRange, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.ping != null && message.hasOwnProperty("ping"))
                    $root.anytype.Event.Ping.encode(message.ping, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Message message, length delimited. Does not implicitly {@link anytype.Event.Message.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Event.Message
             * @static
             * @param {anytype.Event.IMessage} message Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Message.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Message message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Event.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Event.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Message();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.accountShow = $root.anytype.Event.Account.Show.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.blockAdd = $root.anytype.Event.Block.Add.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.blockDelete = $root.anytype.Event.Block.Delete.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.filesUpload = $root.anytype.Event.Block.FilesUpload.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.marksInfo = $root.anytype.Event.Block.MarksInfo.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.blockSetFields = $root.anytype.Event.Block.Set.Fields.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.blockSetChildrenIds = $root.anytype.Event.Block.Set.ChildrenIds.decode(reader, reader.uint32());
                        break;
                    case 8:
                        message.blockSetRestrictions = $root.anytype.Event.Block.Set.Restrictions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.blockSetIsArchived = $root.anytype.Event.Block.Set.IsArchived.decode(reader, reader.uint32());
                        break;
                    case 10:
                        message.blockSetText = $root.anytype.Event.Block.Set.Text.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.blockSetFile = $root.anytype.Event.Block.Set.File.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.blockSetIcon = $root.anytype.Event.Block.Set.Icon.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.blockShow = $root.anytype.Event.Block.Show.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.userBlockJoin = $root.anytype.Event.User.Block.Join.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.userBlockLeft = $root.anytype.Event.User.Block.Left.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.userBlockSelectRange = $root.anytype.Event.User.Block.SelectRange.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.userBlockTextRange = $root.anytype.Event.User.Block.TextRange.decode(reader, reader.uint32());
                        break;
                    case 100:
                        message.ping = $root.anytype.Event.Ping.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Message message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Event.Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Event.Message} Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Message.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Message message.
             * @function verify
             * @memberof anytype.Event.Message
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Message.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.accountShow != null && message.hasOwnProperty("accountShow")) {
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Account.Show.verify(message.accountShow);
                        if (error)
                            return "accountShow." + error;
                    }
                }
                if (message.blockAdd != null && message.hasOwnProperty("blockAdd")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Block.Add.verify(message.blockAdd);
                        if (error)
                            return "blockAdd." + error;
                    }
                }
                if (message.blockDelete != null && message.hasOwnProperty("blockDelete")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Block.Delete.verify(message.blockDelete);
                        if (error)
                            return "blockDelete." + error;
                    }
                }
                if (message.filesUpload != null && message.hasOwnProperty("filesUpload")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Block.FilesUpload.verify(message.filesUpload);
                        if (error)
                            return "filesUpload." + error;
                    }
                }
                if (message.marksInfo != null && message.hasOwnProperty("marksInfo")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Block.MarksInfo.verify(message.marksInfo);
                        if (error)
                            return "marksInfo." + error;
                    }
                }
                if (message.blockSetFields != null && message.hasOwnProperty("blockSetFields")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Block.Set.Fields.verify(message.blockSetFields);
                        if (error)
                            return "blockSetFields." + error;
                    }
                }
                if (message.blockSetChildrenIds != null && message.hasOwnProperty("blockSetChildrenIds")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Block.Set.ChildrenIds.verify(message.blockSetChildrenIds);
                        if (error)
                            return "blockSetChildrenIds." + error;
                    }
                }
                if (message.blockSetRestrictions != null && message.hasOwnProperty("blockSetRestrictions")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Block.Set.Restrictions.verify(message.blockSetRestrictions);
                        if (error)
                            return "blockSetRestrictions." + error;
                    }
                }
                if (message.blockSetIsArchived != null && message.hasOwnProperty("blockSetIsArchived")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Block.Set.IsArchived.verify(message.blockSetIsArchived);
                        if (error)
                            return "blockSetIsArchived." + error;
                    }
                }
                if (message.blockSetText != null && message.hasOwnProperty("blockSetText")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Block.Set.Text.verify(message.blockSetText);
                        if (error)
                            return "blockSetText." + error;
                    }
                }
                if (message.blockSetFile != null && message.hasOwnProperty("blockSetFile")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Block.Set.File.verify(message.blockSetFile);
                        if (error)
                            return "blockSetFile." + error;
                    }
                }
                if (message.blockSetIcon != null && message.hasOwnProperty("blockSetIcon")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Block.Set.Icon.verify(message.blockSetIcon);
                        if (error)
                            return "blockSetIcon." + error;
                    }
                }
                if (message.blockShow != null && message.hasOwnProperty("blockShow")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Block.Show.verify(message.blockShow);
                        if (error)
                            return "blockShow." + error;
                    }
                }
                if (message.userBlockJoin != null && message.hasOwnProperty("userBlockJoin")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.User.Block.Join.verify(message.userBlockJoin);
                        if (error)
                            return "userBlockJoin." + error;
                    }
                }
                if (message.userBlockLeft != null && message.hasOwnProperty("userBlockLeft")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.User.Block.Left.verify(message.userBlockLeft);
                        if (error)
                            return "userBlockLeft." + error;
                    }
                }
                if (message.userBlockSelectRange != null && message.hasOwnProperty("userBlockSelectRange")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.User.Block.SelectRange.verify(message.userBlockSelectRange);
                        if (error)
                            return "userBlockSelectRange." + error;
                    }
                }
                if (message.userBlockTextRange != null && message.hasOwnProperty("userBlockTextRange")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.User.Block.TextRange.verify(message.userBlockTextRange);
                        if (error)
                            return "userBlockTextRange." + error;
                    }
                }
                if (message.ping != null && message.hasOwnProperty("ping")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    {
                        var error = $root.anytype.Event.Ping.verify(message.ping);
                        if (error)
                            return "ping." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Message message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Event.Message
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Event.Message} Message
             */
            Message.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Event.Message)
                    return object;
                var message = new $root.anytype.Event.Message();
                if (object.accountShow != null) {
                    if (typeof object.accountShow !== "object")
                        throw TypeError(".anytype.Event.Message.accountShow: object expected");
                    message.accountShow = $root.anytype.Event.Account.Show.fromObject(object.accountShow);
                }
                if (object.blockAdd != null) {
                    if (typeof object.blockAdd !== "object")
                        throw TypeError(".anytype.Event.Message.blockAdd: object expected");
                    message.blockAdd = $root.anytype.Event.Block.Add.fromObject(object.blockAdd);
                }
                if (object.blockDelete != null) {
                    if (typeof object.blockDelete !== "object")
                        throw TypeError(".anytype.Event.Message.blockDelete: object expected");
                    message.blockDelete = $root.anytype.Event.Block.Delete.fromObject(object.blockDelete);
                }
                if (object.filesUpload != null) {
                    if (typeof object.filesUpload !== "object")
                        throw TypeError(".anytype.Event.Message.filesUpload: object expected");
                    message.filesUpload = $root.anytype.Event.Block.FilesUpload.fromObject(object.filesUpload);
                }
                if (object.marksInfo != null) {
                    if (typeof object.marksInfo !== "object")
                        throw TypeError(".anytype.Event.Message.marksInfo: object expected");
                    message.marksInfo = $root.anytype.Event.Block.MarksInfo.fromObject(object.marksInfo);
                }
                if (object.blockSetFields != null) {
                    if (typeof object.blockSetFields !== "object")
                        throw TypeError(".anytype.Event.Message.blockSetFields: object expected");
                    message.blockSetFields = $root.anytype.Event.Block.Set.Fields.fromObject(object.blockSetFields);
                }
                if (object.blockSetChildrenIds != null) {
                    if (typeof object.blockSetChildrenIds !== "object")
                        throw TypeError(".anytype.Event.Message.blockSetChildrenIds: object expected");
                    message.blockSetChildrenIds = $root.anytype.Event.Block.Set.ChildrenIds.fromObject(object.blockSetChildrenIds);
                }
                if (object.blockSetRestrictions != null) {
                    if (typeof object.blockSetRestrictions !== "object")
                        throw TypeError(".anytype.Event.Message.blockSetRestrictions: object expected");
                    message.blockSetRestrictions = $root.anytype.Event.Block.Set.Restrictions.fromObject(object.blockSetRestrictions);
                }
                if (object.blockSetIsArchived != null) {
                    if (typeof object.blockSetIsArchived !== "object")
                        throw TypeError(".anytype.Event.Message.blockSetIsArchived: object expected");
                    message.blockSetIsArchived = $root.anytype.Event.Block.Set.IsArchived.fromObject(object.blockSetIsArchived);
                }
                if (object.blockSetText != null) {
                    if (typeof object.blockSetText !== "object")
                        throw TypeError(".anytype.Event.Message.blockSetText: object expected");
                    message.blockSetText = $root.anytype.Event.Block.Set.Text.fromObject(object.blockSetText);
                }
                if (object.blockSetFile != null) {
                    if (typeof object.blockSetFile !== "object")
                        throw TypeError(".anytype.Event.Message.blockSetFile: object expected");
                    message.blockSetFile = $root.anytype.Event.Block.Set.File.fromObject(object.blockSetFile);
                }
                if (object.blockSetIcon != null) {
                    if (typeof object.blockSetIcon !== "object")
                        throw TypeError(".anytype.Event.Message.blockSetIcon: object expected");
                    message.blockSetIcon = $root.anytype.Event.Block.Set.Icon.fromObject(object.blockSetIcon);
                }
                if (object.blockShow != null) {
                    if (typeof object.blockShow !== "object")
                        throw TypeError(".anytype.Event.Message.blockShow: object expected");
                    message.blockShow = $root.anytype.Event.Block.Show.fromObject(object.blockShow);
                }
                if (object.userBlockJoin != null) {
                    if (typeof object.userBlockJoin !== "object")
                        throw TypeError(".anytype.Event.Message.userBlockJoin: object expected");
                    message.userBlockJoin = $root.anytype.Event.User.Block.Join.fromObject(object.userBlockJoin);
                }
                if (object.userBlockLeft != null) {
                    if (typeof object.userBlockLeft !== "object")
                        throw TypeError(".anytype.Event.Message.userBlockLeft: object expected");
                    message.userBlockLeft = $root.anytype.Event.User.Block.Left.fromObject(object.userBlockLeft);
                }
                if (object.userBlockSelectRange != null) {
                    if (typeof object.userBlockSelectRange !== "object")
                        throw TypeError(".anytype.Event.Message.userBlockSelectRange: object expected");
                    message.userBlockSelectRange = $root.anytype.Event.User.Block.SelectRange.fromObject(object.userBlockSelectRange);
                }
                if (object.userBlockTextRange != null) {
                    if (typeof object.userBlockTextRange !== "object")
                        throw TypeError(".anytype.Event.Message.userBlockTextRange: object expected");
                    message.userBlockTextRange = $root.anytype.Event.User.Block.TextRange.fromObject(object.userBlockTextRange);
                }
                if (object.ping != null) {
                    if (typeof object.ping !== "object")
                        throw TypeError(".anytype.Event.Message.ping: object expected");
                    message.ping = $root.anytype.Event.Ping.fromObject(object.ping);
                }
                return message;
            };

            /**
             * Creates a plain object from a Message message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Event.Message
             * @static
             * @param {anytype.Event.Message} message Message
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Message.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.accountShow != null && message.hasOwnProperty("accountShow")) {
                    object.accountShow = $root.anytype.Event.Account.Show.toObject(message.accountShow, options);
                    if (options.oneofs)
                        object.value = "accountShow";
                }
                if (message.blockAdd != null && message.hasOwnProperty("blockAdd")) {
                    object.blockAdd = $root.anytype.Event.Block.Add.toObject(message.blockAdd, options);
                    if (options.oneofs)
                        object.value = "blockAdd";
                }
                if (message.blockDelete != null && message.hasOwnProperty("blockDelete")) {
                    object.blockDelete = $root.anytype.Event.Block.Delete.toObject(message.blockDelete, options);
                    if (options.oneofs)
                        object.value = "blockDelete";
                }
                if (message.filesUpload != null && message.hasOwnProperty("filesUpload")) {
                    object.filesUpload = $root.anytype.Event.Block.FilesUpload.toObject(message.filesUpload, options);
                    if (options.oneofs)
                        object.value = "filesUpload";
                }
                if (message.marksInfo != null && message.hasOwnProperty("marksInfo")) {
                    object.marksInfo = $root.anytype.Event.Block.MarksInfo.toObject(message.marksInfo, options);
                    if (options.oneofs)
                        object.value = "marksInfo";
                }
                if (message.blockSetFields != null && message.hasOwnProperty("blockSetFields")) {
                    object.blockSetFields = $root.anytype.Event.Block.Set.Fields.toObject(message.blockSetFields, options);
                    if (options.oneofs)
                        object.value = "blockSetFields";
                }
                if (message.blockSetChildrenIds != null && message.hasOwnProperty("blockSetChildrenIds")) {
                    object.blockSetChildrenIds = $root.anytype.Event.Block.Set.ChildrenIds.toObject(message.blockSetChildrenIds, options);
                    if (options.oneofs)
                        object.value = "blockSetChildrenIds";
                }
                if (message.blockSetRestrictions != null && message.hasOwnProperty("blockSetRestrictions")) {
                    object.blockSetRestrictions = $root.anytype.Event.Block.Set.Restrictions.toObject(message.blockSetRestrictions, options);
                    if (options.oneofs)
                        object.value = "blockSetRestrictions";
                }
                if (message.blockSetIsArchived != null && message.hasOwnProperty("blockSetIsArchived")) {
                    object.blockSetIsArchived = $root.anytype.Event.Block.Set.IsArchived.toObject(message.blockSetIsArchived, options);
                    if (options.oneofs)
                        object.value = "blockSetIsArchived";
                }
                if (message.blockSetText != null && message.hasOwnProperty("blockSetText")) {
                    object.blockSetText = $root.anytype.Event.Block.Set.Text.toObject(message.blockSetText, options);
                    if (options.oneofs)
                        object.value = "blockSetText";
                }
                if (message.blockSetFile != null && message.hasOwnProperty("blockSetFile")) {
                    object.blockSetFile = $root.anytype.Event.Block.Set.File.toObject(message.blockSetFile, options);
                    if (options.oneofs)
                        object.value = "blockSetFile";
                }
                if (message.blockSetIcon != null && message.hasOwnProperty("blockSetIcon")) {
                    object.blockSetIcon = $root.anytype.Event.Block.Set.Icon.toObject(message.blockSetIcon, options);
                    if (options.oneofs)
                        object.value = "blockSetIcon";
                }
                if (message.blockShow != null && message.hasOwnProperty("blockShow")) {
                    object.blockShow = $root.anytype.Event.Block.Show.toObject(message.blockShow, options);
                    if (options.oneofs)
                        object.value = "blockShow";
                }
                if (message.userBlockJoin != null && message.hasOwnProperty("userBlockJoin")) {
                    object.userBlockJoin = $root.anytype.Event.User.Block.Join.toObject(message.userBlockJoin, options);
                    if (options.oneofs)
                        object.value = "userBlockJoin";
                }
                if (message.userBlockLeft != null && message.hasOwnProperty("userBlockLeft")) {
                    object.userBlockLeft = $root.anytype.Event.User.Block.Left.toObject(message.userBlockLeft, options);
                    if (options.oneofs)
                        object.value = "userBlockLeft";
                }
                if (message.userBlockSelectRange != null && message.hasOwnProperty("userBlockSelectRange")) {
                    object.userBlockSelectRange = $root.anytype.Event.User.Block.SelectRange.toObject(message.userBlockSelectRange, options);
                    if (options.oneofs)
                        object.value = "userBlockSelectRange";
                }
                if (message.userBlockTextRange != null && message.hasOwnProperty("userBlockTextRange")) {
                    object.userBlockTextRange = $root.anytype.Event.User.Block.TextRange.toObject(message.userBlockTextRange, options);
                    if (options.oneofs)
                        object.value = "userBlockTextRange";
                }
                if (message.ping != null && message.hasOwnProperty("ping")) {
                    object.ping = $root.anytype.Event.Ping.toObject(message.ping, options);
                    if (options.oneofs)
                        object.value = "ping";
                }
                return object;
            };

            /**
             * Converts this Message to JSON.
             * @function toJSON
             * @memberof anytype.Event.Message
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Message.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Message;
        })();

        Event.Account = (function() {

            /**
             * Properties of an Account.
             * @memberof anytype.Event
             * @interface IAccount
             */

            /**
             * Constructs a new Account.
             * @memberof anytype.Event
             * @classdesc Represents an Account.
             * @implements IAccount
             * @constructor
             * @param {anytype.Event.IAccount=} [properties] Properties to set
             */
            function Account(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Account instance using the specified properties.
             * @function create
             * @memberof anytype.Event.Account
             * @static
             * @param {anytype.Event.IAccount=} [properties] Properties to set
             * @returns {anytype.Event.Account} Account instance
             */
            Account.create = function create(properties) {
                return new Account(properties);
            };

            /**
             * Encodes the specified Account message. Does not implicitly {@link anytype.Event.Account.verify|verify} messages.
             * @function encode
             * @memberof anytype.Event.Account
             * @static
             * @param {anytype.Event.IAccount} message Account message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Account.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Account message, length delimited. Does not implicitly {@link anytype.Event.Account.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Event.Account
             * @static
             * @param {anytype.Event.IAccount} message Account message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Account.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Account message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Event.Account
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Event.Account} Account
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Account.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Account();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Account message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Event.Account
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Event.Account} Account
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Account.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Account message.
             * @function verify
             * @memberof anytype.Event.Account
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Account.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Account message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Event.Account
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Event.Account} Account
             */
            Account.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Event.Account)
                    return object;
                return new $root.anytype.Event.Account();
            };

            /**
             * Creates a plain object from an Account message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Event.Account
             * @static
             * @param {anytype.Event.Account} message Account
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Account.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Account to JSON.
             * @function toJSON
             * @memberof anytype.Event.Account
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Account.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Account.Show = (function() {

                /**
                 * Properties of a Show.
                 * @memberof anytype.Event.Account
                 * @interface IShow
                 * @property {number|null} [index] Show index
                 * @property {anytype.model.IAccount|null} [account] Show account
                 */

                /**
                 * Constructs a new Show.
                 * @memberof anytype.Event.Account
                 * @classdesc Message, that will be sent to the front on each account found after an AccountRecoverRequest
                 * @implements IShow
                 * @constructor
                 * @param {anytype.Event.Account.IShow=} [properties] Properties to set
                 */
                function Show(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Show index.
                 * @member {number} index
                 * @memberof anytype.Event.Account.Show
                 * @instance
                 */
                Show.prototype.index = 0;

                /**
                 * Show account.
                 * @member {anytype.model.IAccount|null|undefined} account
                 * @memberof anytype.Event.Account.Show
                 * @instance
                 */
                Show.prototype.account = null;

                /**
                 * Creates a new Show instance using the specified properties.
                 * @function create
                 * @memberof anytype.Event.Account.Show
                 * @static
                 * @param {anytype.Event.Account.IShow=} [properties] Properties to set
                 * @returns {anytype.Event.Account.Show} Show instance
                 */
                Show.create = function create(properties) {
                    return new Show(properties);
                };

                /**
                 * Encodes the specified Show message. Does not implicitly {@link anytype.Event.Account.Show.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Event.Account.Show
                 * @static
                 * @param {anytype.Event.Account.IShow} message Show message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Show.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && message.hasOwnProperty("index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                    if (message.account != null && message.hasOwnProperty("account"))
                        $root.anytype.model.Account.encode(message.account, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Show message, length delimited. Does not implicitly {@link anytype.Event.Account.Show.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Event.Account.Show
                 * @static
                 * @param {anytype.Event.Account.IShow} message Show message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Show.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Show message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Event.Account.Show
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Event.Account.Show} Show
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Show.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Account.Show();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.index = reader.int32();
                            break;
                        case 2:
                            message.account = $root.anytype.model.Account.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Show message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Event.Account.Show
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Event.Account.Show} Show
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Show.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Show message.
                 * @function verify
                 * @memberof anytype.Event.Account.Show
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Show.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.index != null && message.hasOwnProperty("index"))
                        if (!$util.isInteger(message.index))
                            return "index: integer expected";
                    if (message.account != null && message.hasOwnProperty("account")) {
                        var error = $root.anytype.model.Account.verify(message.account);
                        if (error)
                            return "account." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Show message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Event.Account.Show
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Event.Account.Show} Show
                 */
                Show.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Event.Account.Show)
                        return object;
                    var message = new $root.anytype.Event.Account.Show();
                    if (object.index != null)
                        message.index = object.index | 0;
                    if (object.account != null) {
                        if (typeof object.account !== "object")
                            throw TypeError(".anytype.Event.Account.Show.account: object expected");
                        message.account = $root.anytype.model.Account.fromObject(object.account);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Show message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Event.Account.Show
                 * @static
                 * @param {anytype.Event.Account.Show} message Show
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Show.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.index = 0;
                        object.account = null;
                    }
                    if (message.index != null && message.hasOwnProperty("index"))
                        object.index = message.index;
                    if (message.account != null && message.hasOwnProperty("account"))
                        object.account = $root.anytype.model.Account.toObject(message.account, options);
                    return object;
                };

                /**
                 * Converts this Show to JSON.
                 * @function toJSON
                 * @memberof anytype.Event.Account.Show
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Show.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Show;
            })();

            return Account;
        })();

        Event.Block = (function() {

            /**
             * Properties of a Block.
             * @memberof anytype.Event
             * @interface IBlock
             */

            /**
             * Constructs a new Block.
             * @memberof anytype.Event
             * @classdesc Represents a Block.
             * @implements IBlock
             * @constructor
             * @param {anytype.Event.IBlock=} [properties] Properties to set
             */
            function Block(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Block instance using the specified properties.
             * @function create
             * @memberof anytype.Event.Block
             * @static
             * @param {anytype.Event.IBlock=} [properties] Properties to set
             * @returns {anytype.Event.Block} Block instance
             */
            Block.create = function create(properties) {
                return new Block(properties);
            };

            /**
             * Encodes the specified Block message. Does not implicitly {@link anytype.Event.Block.verify|verify} messages.
             * @function encode
             * @memberof anytype.Event.Block
             * @static
             * @param {anytype.Event.IBlock} message Block message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Block.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Block message, length delimited. Does not implicitly {@link anytype.Event.Block.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Event.Block
             * @static
             * @param {anytype.Event.IBlock} message Block message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Block.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Block message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Event.Block
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Event.Block} Block
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Block.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Block message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Event.Block
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Event.Block} Block
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Block.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Block message.
             * @function verify
             * @memberof anytype.Event.Block
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Block.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a Block message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Event.Block
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Event.Block} Block
             */
            Block.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Event.Block)
                    return object;
                return new $root.anytype.Event.Block();
            };

            /**
             * Creates a plain object from a Block message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Event.Block
             * @static
             * @param {anytype.Event.Block} message Block
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Block.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Block to JSON.
             * @function toJSON
             * @memberof anytype.Event.Block
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Block.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Block.Add = (function() {

                /**
                 * Properties of an Add.
                 * @memberof anytype.Event.Block
                 * @interface IAdd
                 * @property {Array.<anytype.model.IBlock>|null} [blocks] Add blocks
                 */

                /**
                 * Constructs a new Add.
                 * @memberof anytype.Event.Block
                 * @classdesc Represents an Add.
                 * @implements IAdd
                 * @constructor
                 * @param {anytype.Event.Block.IAdd=} [properties] Properties to set
                 */
                function Add(properties) {
                    this.blocks = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Add blocks.
                 * @member {Array.<anytype.model.IBlock>} blocks
                 * @memberof anytype.Event.Block.Add
                 * @instance
                 */
                Add.prototype.blocks = $util.emptyArray;

                /**
                 * Creates a new Add instance using the specified properties.
                 * @function create
                 * @memberof anytype.Event.Block.Add
                 * @static
                 * @param {anytype.Event.Block.IAdd=} [properties] Properties to set
                 * @returns {anytype.Event.Block.Add} Add instance
                 */
                Add.create = function create(properties) {
                    return new Add(properties);
                };

                /**
                 * Encodes the specified Add message. Does not implicitly {@link anytype.Event.Block.Add.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Event.Block.Add
                 * @static
                 * @param {anytype.Event.Block.IAdd} message Add message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Add.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.blocks != null && message.blocks.length)
                        for (var i = 0; i < message.blocks.length; ++i)
                            $root.anytype.model.Block.encode(message.blocks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Add message, length delimited. Does not implicitly {@link anytype.Event.Block.Add.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Event.Block.Add
                 * @static
                 * @param {anytype.Event.Block.IAdd} message Add message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Add.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Add message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Event.Block.Add
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Event.Block.Add} Add
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Add.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Add();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.blocks && message.blocks.length))
                                message.blocks = [];
                            message.blocks.push($root.anytype.model.Block.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Add message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Event.Block.Add
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Event.Block.Add} Add
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Add.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Add message.
                 * @function verify
                 * @memberof anytype.Event.Block.Add
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Add.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.blocks != null && message.hasOwnProperty("blocks")) {
                        if (!Array.isArray(message.blocks))
                            return "blocks: array expected";
                        for (var i = 0; i < message.blocks.length; ++i) {
                            var error = $root.anytype.model.Block.verify(message.blocks[i]);
                            if (error)
                                return "blocks." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Add message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Event.Block.Add
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Event.Block.Add} Add
                 */
                Add.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Event.Block.Add)
                        return object;
                    var message = new $root.anytype.Event.Block.Add();
                    if (object.blocks) {
                        if (!Array.isArray(object.blocks))
                            throw TypeError(".anytype.Event.Block.Add.blocks: array expected");
                        message.blocks = [];
                        for (var i = 0; i < object.blocks.length; ++i) {
                            if (typeof object.blocks[i] !== "object")
                                throw TypeError(".anytype.Event.Block.Add.blocks: object expected");
                            message.blocks[i] = $root.anytype.model.Block.fromObject(object.blocks[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Add message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Event.Block.Add
                 * @static
                 * @param {anytype.Event.Block.Add} message Add
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Add.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.blocks = [];
                    if (message.blocks && message.blocks.length) {
                        object.blocks = [];
                        for (var j = 0; j < message.blocks.length; ++j)
                            object.blocks[j] = $root.anytype.model.Block.toObject(message.blocks[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Add to JSON.
                 * @function toJSON
                 * @memberof anytype.Event.Block.Add
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Add.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Add;
            })();

            Block.Show = (function() {

                /**
                 * Properties of a Show.
                 * @memberof anytype.Event.Block
                 * @interface IShow
                 * @property {string|null} [rootId] Show rootId
                 * @property {Array.<anytype.model.IBlock>|null} [blocks] Show blocks
                 */

                /**
                 * Constructs a new Show.
                 * @memberof anytype.Event.Block
                 * @classdesc Represents a Show.
                 * @implements IShow
                 * @constructor
                 * @param {anytype.Event.Block.IShow=} [properties] Properties to set
                 */
                function Show(properties) {
                    this.blocks = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Show rootId.
                 * @member {string} rootId
                 * @memberof anytype.Event.Block.Show
                 * @instance
                 */
                Show.prototype.rootId = "";

                /**
                 * Show blocks.
                 * @member {Array.<anytype.model.IBlock>} blocks
                 * @memberof anytype.Event.Block.Show
                 * @instance
                 */
                Show.prototype.blocks = $util.emptyArray;

                /**
                 * Creates a new Show instance using the specified properties.
                 * @function create
                 * @memberof anytype.Event.Block.Show
                 * @static
                 * @param {anytype.Event.Block.IShow=} [properties] Properties to set
                 * @returns {anytype.Event.Block.Show} Show instance
                 */
                Show.create = function create(properties) {
                    return new Show(properties);
                };

                /**
                 * Encodes the specified Show message. Does not implicitly {@link anytype.Event.Block.Show.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Event.Block.Show
                 * @static
                 * @param {anytype.Event.Block.IShow} message Show message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Show.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.rootId != null && message.hasOwnProperty("rootId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.rootId);
                    if (message.blocks != null && message.blocks.length)
                        for (var i = 0; i < message.blocks.length; ++i)
                            $root.anytype.model.Block.encode(message.blocks[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Show message, length delimited. Does not implicitly {@link anytype.Event.Block.Show.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Event.Block.Show
                 * @static
                 * @param {anytype.Event.Block.IShow} message Show message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Show.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Show message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Event.Block.Show
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Event.Block.Show} Show
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Show.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Show();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.rootId = reader.string();
                            break;
                        case 2:
                            if (!(message.blocks && message.blocks.length))
                                message.blocks = [];
                            message.blocks.push($root.anytype.model.Block.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Show message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Event.Block.Show
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Event.Block.Show} Show
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Show.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Show message.
                 * @function verify
                 * @memberof anytype.Event.Block.Show
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Show.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.rootId != null && message.hasOwnProperty("rootId"))
                        if (!$util.isString(message.rootId))
                            return "rootId: string expected";
                    if (message.blocks != null && message.hasOwnProperty("blocks")) {
                        if (!Array.isArray(message.blocks))
                            return "blocks: array expected";
                        for (var i = 0; i < message.blocks.length; ++i) {
                            var error = $root.anytype.model.Block.verify(message.blocks[i]);
                            if (error)
                                return "blocks." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Show message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Event.Block.Show
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Event.Block.Show} Show
                 */
                Show.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Event.Block.Show)
                        return object;
                    var message = new $root.anytype.Event.Block.Show();
                    if (object.rootId != null)
                        message.rootId = String(object.rootId);
                    if (object.blocks) {
                        if (!Array.isArray(object.blocks))
                            throw TypeError(".anytype.Event.Block.Show.blocks: array expected");
                        message.blocks = [];
                        for (var i = 0; i < object.blocks.length; ++i) {
                            if (typeof object.blocks[i] !== "object")
                                throw TypeError(".anytype.Event.Block.Show.blocks: object expected");
                            message.blocks[i] = $root.anytype.model.Block.fromObject(object.blocks[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Show message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Event.Block.Show
                 * @static
                 * @param {anytype.Event.Block.Show} message Show
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Show.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.blocks = [];
                    if (options.defaults)
                        object.rootId = "";
                    if (message.rootId != null && message.hasOwnProperty("rootId"))
                        object.rootId = message.rootId;
                    if (message.blocks && message.blocks.length) {
                        object.blocks = [];
                        for (var j = 0; j < message.blocks.length; ++j)
                            object.blocks[j] = $root.anytype.model.Block.toObject(message.blocks[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Show to JSON.
                 * @function toJSON
                 * @memberof anytype.Event.Block.Show
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Show.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Show;
            })();

            Block.FilesUpload = (function() {

                /**
                 * Properties of a FilesUpload.
                 * @memberof anytype.Event.Block
                 * @interface IFilesUpload
                 * @property {string|null} [blockId] FilesUpload blockId
                 * @property {Array.<string>|null} [filePath] FilesUpload filePath
                 */

                /**
                 * Constructs a new FilesUpload.
                 * @memberof anytype.Event.Block
                 * @classdesc Middleware to front end event message, that will be sent on one of this scenarios:
                 * Precondition: user A opened a block
                 * 1. User A drops a set of files/pictures/videos
                 * 2. User A creates a MediaBlock and drops a single media, that corresponds to its type.
                 * @implements IFilesUpload
                 * @constructor
                 * @param {anytype.Event.Block.IFilesUpload=} [properties] Properties to set
                 */
                function FilesUpload(properties) {
                    this.filePath = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FilesUpload blockId.
                 * @member {string} blockId
                 * @memberof anytype.Event.Block.FilesUpload
                 * @instance
                 */
                FilesUpload.prototype.blockId = "";

                /**
                 * FilesUpload filePath.
                 * @member {Array.<string>} filePath
                 * @memberof anytype.Event.Block.FilesUpload
                 * @instance
                 */
                FilesUpload.prototype.filePath = $util.emptyArray;

                /**
                 * Creates a new FilesUpload instance using the specified properties.
                 * @function create
                 * @memberof anytype.Event.Block.FilesUpload
                 * @static
                 * @param {anytype.Event.Block.IFilesUpload=} [properties] Properties to set
                 * @returns {anytype.Event.Block.FilesUpload} FilesUpload instance
                 */
                FilesUpload.create = function create(properties) {
                    return new FilesUpload(properties);
                };

                /**
                 * Encodes the specified FilesUpload message. Does not implicitly {@link anytype.Event.Block.FilesUpload.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Event.Block.FilesUpload
                 * @static
                 * @param {anytype.Event.Block.IFilesUpload} message FilesUpload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FilesUpload.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.blockId != null && message.hasOwnProperty("blockId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.blockId);
                    if (message.filePath != null && message.filePath.length)
                        for (var i = 0; i < message.filePath.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.filePath[i]);
                    return writer;
                };

                /**
                 * Encodes the specified FilesUpload message, length delimited. Does not implicitly {@link anytype.Event.Block.FilesUpload.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Event.Block.FilesUpload
                 * @static
                 * @param {anytype.Event.Block.IFilesUpload} message FilesUpload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FilesUpload.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FilesUpload message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Event.Block.FilesUpload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Event.Block.FilesUpload} FilesUpload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FilesUpload.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.FilesUpload();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.blockId = reader.string();
                            break;
                        case 2:
                            if (!(message.filePath && message.filePath.length))
                                message.filePath = [];
                            message.filePath.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FilesUpload message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Event.Block.FilesUpload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Event.Block.FilesUpload} FilesUpload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FilesUpload.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FilesUpload message.
                 * @function verify
                 * @memberof anytype.Event.Block.FilesUpload
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FilesUpload.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.blockId != null && message.hasOwnProperty("blockId"))
                        if (!$util.isString(message.blockId))
                            return "blockId: string expected";
                    if (message.filePath != null && message.hasOwnProperty("filePath")) {
                        if (!Array.isArray(message.filePath))
                            return "filePath: array expected";
                        for (var i = 0; i < message.filePath.length; ++i)
                            if (!$util.isString(message.filePath[i]))
                                return "filePath: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a FilesUpload message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Event.Block.FilesUpload
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Event.Block.FilesUpload} FilesUpload
                 */
                FilesUpload.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Event.Block.FilesUpload)
                        return object;
                    var message = new $root.anytype.Event.Block.FilesUpload();
                    if (object.blockId != null)
                        message.blockId = String(object.blockId);
                    if (object.filePath) {
                        if (!Array.isArray(object.filePath))
                            throw TypeError(".anytype.Event.Block.FilesUpload.filePath: array expected");
                        message.filePath = [];
                        for (var i = 0; i < object.filePath.length; ++i)
                            message.filePath[i] = String(object.filePath[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FilesUpload message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Event.Block.FilesUpload
                 * @static
                 * @param {anytype.Event.Block.FilesUpload} message FilesUpload
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FilesUpload.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.filePath = [];
                    if (options.defaults)
                        object.blockId = "";
                    if (message.blockId != null && message.hasOwnProperty("blockId"))
                        object.blockId = message.blockId;
                    if (message.filePath && message.filePath.length) {
                        object.filePath = [];
                        for (var j = 0; j < message.filePath.length; ++j)
                            object.filePath[j] = message.filePath[j];
                    }
                    return object;
                };

                /**
                 * Converts this FilesUpload to JSON.
                 * @function toJSON
                 * @memberof anytype.Event.Block.FilesUpload
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FilesUpload.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FilesUpload;
            })();

            Block.Delete = (function() {

                /**
                 * Properties of a Delete.
                 * @memberof anytype.Event.Block
                 * @interface IDelete
                 * @property {string|null} [blockId] Delete blockId
                 */

                /**
                 * Constructs a new Delete.
                 * @memberof anytype.Event.Block
                 * @classdesc Represents a Delete.
                 * @implements IDelete
                 * @constructor
                 * @param {anytype.Event.Block.IDelete=} [properties] Properties to set
                 */
                function Delete(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Delete blockId.
                 * @member {string} blockId
                 * @memberof anytype.Event.Block.Delete
                 * @instance
                 */
                Delete.prototype.blockId = "";

                /**
                 * Creates a new Delete instance using the specified properties.
                 * @function create
                 * @memberof anytype.Event.Block.Delete
                 * @static
                 * @param {anytype.Event.Block.IDelete=} [properties] Properties to set
                 * @returns {anytype.Event.Block.Delete} Delete instance
                 */
                Delete.create = function create(properties) {
                    return new Delete(properties);
                };

                /**
                 * Encodes the specified Delete message. Does not implicitly {@link anytype.Event.Block.Delete.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Event.Block.Delete
                 * @static
                 * @param {anytype.Event.Block.IDelete} message Delete message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Delete.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.blockId != null && message.hasOwnProperty("blockId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.blockId);
                    return writer;
                };

                /**
                 * Encodes the specified Delete message, length delimited. Does not implicitly {@link anytype.Event.Block.Delete.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Event.Block.Delete
                 * @static
                 * @param {anytype.Event.Block.IDelete} message Delete message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Delete.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Delete message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Event.Block.Delete
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Event.Block.Delete} Delete
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Delete.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Delete();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.blockId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Delete message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Event.Block.Delete
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Event.Block.Delete} Delete
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Delete.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Delete message.
                 * @function verify
                 * @memberof anytype.Event.Block.Delete
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Delete.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.blockId != null && message.hasOwnProperty("blockId"))
                        if (!$util.isString(message.blockId))
                            return "blockId: string expected";
                    return null;
                };

                /**
                 * Creates a Delete message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Event.Block.Delete
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Event.Block.Delete} Delete
                 */
                Delete.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Event.Block.Delete)
                        return object;
                    var message = new $root.anytype.Event.Block.Delete();
                    if (object.blockId != null)
                        message.blockId = String(object.blockId);
                    return message;
                };

                /**
                 * Creates a plain object from a Delete message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Event.Block.Delete
                 * @static
                 * @param {anytype.Event.Block.Delete} message Delete
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Delete.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.blockId = "";
                    if (message.blockId != null && message.hasOwnProperty("blockId"))
                        object.blockId = message.blockId;
                    return object;
                };

                /**
                 * Converts this Delete to JSON.
                 * @function toJSON
                 * @memberof anytype.Event.Block.Delete
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Delete.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Delete;
            })();

            Block.MarksInfo = (function() {

                /**
                 * Properties of a MarksInfo.
                 * @memberof anytype.Event.Block
                 * @interface IMarksInfo
                 * @property {Array.<anytype.model.Block.Content.Text.Mark.Type>|null} [marksInRange] MarksInfo marksInRange
                 */

                /**
                 * Constructs a new MarksInfo.
                 * @memberof anytype.Event.Block
                 * @classdesc Represents a MarksInfo.
                 * @implements IMarksInfo
                 * @constructor
                 * @param {anytype.Event.Block.IMarksInfo=} [properties] Properties to set
                 */
                function MarksInfo(properties) {
                    this.marksInRange = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MarksInfo marksInRange.
                 * @member {Array.<anytype.model.Block.Content.Text.Mark.Type>} marksInRange
                 * @memberof anytype.Event.Block.MarksInfo
                 * @instance
                 */
                MarksInfo.prototype.marksInRange = $util.emptyArray;

                /**
                 * Creates a new MarksInfo instance using the specified properties.
                 * @function create
                 * @memberof anytype.Event.Block.MarksInfo
                 * @static
                 * @param {anytype.Event.Block.IMarksInfo=} [properties] Properties to set
                 * @returns {anytype.Event.Block.MarksInfo} MarksInfo instance
                 */
                MarksInfo.create = function create(properties) {
                    return new MarksInfo(properties);
                };

                /**
                 * Encodes the specified MarksInfo message. Does not implicitly {@link anytype.Event.Block.MarksInfo.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Event.Block.MarksInfo
                 * @static
                 * @param {anytype.Event.Block.IMarksInfo} message MarksInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MarksInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.marksInRange != null && message.marksInRange.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.marksInRange.length; ++i)
                            writer.int32(message.marksInRange[i]);
                        writer.ldelim();
                    }
                    return writer;
                };

                /**
                 * Encodes the specified MarksInfo message, length delimited. Does not implicitly {@link anytype.Event.Block.MarksInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Event.Block.MarksInfo
                 * @static
                 * @param {anytype.Event.Block.IMarksInfo} message MarksInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MarksInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a MarksInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Event.Block.MarksInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Event.Block.MarksInfo} MarksInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MarksInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.MarksInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.marksInRange && message.marksInRange.length))
                                message.marksInRange = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.marksInRange.push(reader.int32());
                            } else
                                message.marksInRange.push(reader.int32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a MarksInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Event.Block.MarksInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Event.Block.MarksInfo} MarksInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MarksInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a MarksInfo message.
                 * @function verify
                 * @memberof anytype.Event.Block.MarksInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MarksInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.marksInRange != null && message.hasOwnProperty("marksInRange")) {
                        if (!Array.isArray(message.marksInRange))
                            return "marksInRange: array expected";
                        for (var i = 0; i < message.marksInRange.length; ++i)
                            switch (message.marksInRange[i]) {
                            default:
                                return "marksInRange: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                                break;
                            }
                    }
                    return null;
                };

                /**
                 * Creates a MarksInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Event.Block.MarksInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Event.Block.MarksInfo} MarksInfo
                 */
                MarksInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Event.Block.MarksInfo)
                        return object;
                    var message = new $root.anytype.Event.Block.MarksInfo();
                    if (object.marksInRange) {
                        if (!Array.isArray(object.marksInRange))
                            throw TypeError(".anytype.Event.Block.MarksInfo.marksInRange: array expected");
                        message.marksInRange = [];
                        for (var i = 0; i < object.marksInRange.length; ++i)
                            switch (object.marksInRange[i]) {
                            default:
                            case "Strikethrough":
                            case 0:
                                message.marksInRange[i] = 0;
                                break;
                            case "Keyboard":
                            case 1:
                                message.marksInRange[i] = 1;
                                break;
                            case "Italic":
                            case 2:
                                message.marksInRange[i] = 2;
                                break;
                            case "Bold":
                            case 3:
                                message.marksInRange[i] = 3;
                                break;
                            case "Underscored":
                            case 4:
                                message.marksInRange[i] = 4;
                                break;
                            case "Link":
                            case 5:
                                message.marksInRange[i] = 5;
                                break;
                            case "TextColor":
                            case 6:
                                message.marksInRange[i] = 6;
                                break;
                            case "BackgroundColor":
                            case 7:
                                message.marksInRange[i] = 7;
                                break;
                            }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MarksInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Event.Block.MarksInfo
                 * @static
                 * @param {anytype.Event.Block.MarksInfo} message MarksInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MarksInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.marksInRange = [];
                    if (message.marksInRange && message.marksInRange.length) {
                        object.marksInRange = [];
                        for (var j = 0; j < message.marksInRange.length; ++j)
                            object.marksInRange[j] = options.enums === String ? $root.anytype.model.Block.Content.Text.Mark.Type[message.marksInRange[j]] : message.marksInRange[j];
                    }
                    return object;
                };

                /**
                 * Converts this MarksInfo to JSON.
                 * @function toJSON
                 * @memberof anytype.Event.Block.MarksInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MarksInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return MarksInfo;
            })();

            Block.Set = (function() {

                /**
                 * Properties of a Set.
                 * @memberof anytype.Event.Block
                 * @interface ISet
                 */

                /**
                 * Constructs a new Set.
                 * @memberof anytype.Event.Block
                 * @classdesc Represents a Set.
                 * @implements ISet
                 * @constructor
                 * @param {anytype.Event.Block.ISet=} [properties] Properties to set
                 */
                function Set(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Set instance using the specified properties.
                 * @function create
                 * @memberof anytype.Event.Block.Set
                 * @static
                 * @param {anytype.Event.Block.ISet=} [properties] Properties to set
                 * @returns {anytype.Event.Block.Set} Set instance
                 */
                Set.create = function create(properties) {
                    return new Set(properties);
                };

                /**
                 * Encodes the specified Set message. Does not implicitly {@link anytype.Event.Block.Set.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Event.Block.Set
                 * @static
                 * @param {anytype.Event.Block.ISet} message Set message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Set.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Set message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Event.Block.Set
                 * @static
                 * @param {anytype.Event.Block.ISet} message Set message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Set.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Set message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Event.Block.Set
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Event.Block.Set} Set
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Set.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Set message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Event.Block.Set
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Event.Block.Set} Set
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Set.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Set message.
                 * @function verify
                 * @memberof anytype.Event.Block.Set
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Set.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Set message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Event.Block.Set
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Event.Block.Set} Set
                 */
                Set.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Event.Block.Set)
                        return object;
                    return new $root.anytype.Event.Block.Set();
                };

                /**
                 * Creates a plain object from a Set message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Event.Block.Set
                 * @static
                 * @param {anytype.Event.Block.Set} message Set
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Set.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Set to JSON.
                 * @function toJSON
                 * @memberof anytype.Event.Block.Set
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Set.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Set.Fields = (function() {

                    /**
                     * Properties of a Fields.
                     * @memberof anytype.Event.Block.Set
                     * @interface IFields
                     * @property {string|null} [id] Fields id
                     * @property {google.protobuf.IStruct|null} [fields] Fields fields
                     */

                    /**
                     * Constructs a new Fields.
                     * @memberof anytype.Event.Block.Set
                     * @classdesc Represents a Fields.
                     * @implements IFields
                     * @constructor
                     * @param {anytype.Event.Block.Set.IFields=} [properties] Properties to set
                     */
                    function Fields(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Fields id.
                     * @member {string} id
                     * @memberof anytype.Event.Block.Set.Fields
                     * @instance
                     */
                    Fields.prototype.id = "";

                    /**
                     * Fields fields.
                     * @member {google.protobuf.IStruct|null|undefined} fields
                     * @memberof anytype.Event.Block.Set.Fields
                     * @instance
                     */
                    Fields.prototype.fields = null;

                    /**
                     * Creates a new Fields instance using the specified properties.
                     * @function create
                     * @memberof anytype.Event.Block.Set.Fields
                     * @static
                     * @param {anytype.Event.Block.Set.IFields=} [properties] Properties to set
                     * @returns {anytype.Event.Block.Set.Fields} Fields instance
                     */
                    Fields.create = function create(properties) {
                        return new Fields(properties);
                    };

                    /**
                     * Encodes the specified Fields message. Does not implicitly {@link anytype.Event.Block.Set.Fields.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Event.Block.Set.Fields
                     * @static
                     * @param {anytype.Event.Block.Set.IFields} message Fields message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Fields.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.fields != null && message.hasOwnProperty("fields"))
                            $root.google.protobuf.Struct.encode(message.fields, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Fields message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.Fields.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Event.Block.Set.Fields
                     * @static
                     * @param {anytype.Event.Block.Set.IFields} message Fields message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Fields.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Fields message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Event.Block.Set.Fields
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Event.Block.Set.Fields} Fields
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Fields.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.Fields();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                message.fields = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Fields message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Event.Block.Set.Fields
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Event.Block.Set.Fields} Fields
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Fields.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Fields message.
                     * @function verify
                     * @memberof anytype.Event.Block.Set.Fields
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Fields.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.fields != null && message.hasOwnProperty("fields")) {
                            var error = $root.google.protobuf.Struct.verify(message.fields);
                            if (error)
                                return "fields." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Fields message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Event.Block.Set.Fields
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Event.Block.Set.Fields} Fields
                     */
                    Fields.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Event.Block.Set.Fields)
                            return object;
                        var message = new $root.anytype.Event.Block.Set.Fields();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.fields != null) {
                            if (typeof object.fields !== "object")
                                throw TypeError(".anytype.Event.Block.Set.Fields.fields: object expected");
                            message.fields = $root.google.protobuf.Struct.fromObject(object.fields);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Fields message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Event.Block.Set.Fields
                     * @static
                     * @param {anytype.Event.Block.Set.Fields} message Fields
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Fields.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.fields = null;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.fields != null && message.hasOwnProperty("fields"))
                            object.fields = $root.google.protobuf.Struct.toObject(message.fields, options);
                        return object;
                    };

                    /**
                     * Converts this Fields to JSON.
                     * @function toJSON
                     * @memberof anytype.Event.Block.Set.Fields
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Fields.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Fields;
                })();

                Set.ChildrenIds = (function() {

                    /**
                     * Properties of a ChildrenIds.
                     * @memberof anytype.Event.Block.Set
                     * @interface IChildrenIds
                     * @property {string|null} [id] ChildrenIds id
                     * @property {Array.<string>|null} [childrenIds] ChildrenIds childrenIds
                     */

                    /**
                     * Constructs a new ChildrenIds.
                     * @memberof anytype.Event.Block.Set
                     * @classdesc Represents a ChildrenIds.
                     * @implements IChildrenIds
                     * @constructor
                     * @param {anytype.Event.Block.Set.IChildrenIds=} [properties] Properties to set
                     */
                    function ChildrenIds(properties) {
                        this.childrenIds = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ChildrenIds id.
                     * @member {string} id
                     * @memberof anytype.Event.Block.Set.ChildrenIds
                     * @instance
                     */
                    ChildrenIds.prototype.id = "";

                    /**
                     * ChildrenIds childrenIds.
                     * @member {Array.<string>} childrenIds
                     * @memberof anytype.Event.Block.Set.ChildrenIds
                     * @instance
                     */
                    ChildrenIds.prototype.childrenIds = $util.emptyArray;

                    /**
                     * Creates a new ChildrenIds instance using the specified properties.
                     * @function create
                     * @memberof anytype.Event.Block.Set.ChildrenIds
                     * @static
                     * @param {anytype.Event.Block.Set.IChildrenIds=} [properties] Properties to set
                     * @returns {anytype.Event.Block.Set.ChildrenIds} ChildrenIds instance
                     */
                    ChildrenIds.create = function create(properties) {
                        return new ChildrenIds(properties);
                    };

                    /**
                     * Encodes the specified ChildrenIds message. Does not implicitly {@link anytype.Event.Block.Set.ChildrenIds.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Event.Block.Set.ChildrenIds
                     * @static
                     * @param {anytype.Event.Block.Set.IChildrenIds} message ChildrenIds message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChildrenIds.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.childrenIds != null && message.childrenIds.length)
                            for (var i = 0; i < message.childrenIds.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.childrenIds[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified ChildrenIds message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.ChildrenIds.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Event.Block.Set.ChildrenIds
                     * @static
                     * @param {anytype.Event.Block.Set.IChildrenIds} message ChildrenIds message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ChildrenIds.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a ChildrenIds message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Event.Block.Set.ChildrenIds
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Event.Block.Set.ChildrenIds} ChildrenIds
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChildrenIds.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.ChildrenIds();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                if (!(message.childrenIds && message.childrenIds.length))
                                    message.childrenIds = [];
                                message.childrenIds.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a ChildrenIds message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Event.Block.Set.ChildrenIds
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Event.Block.Set.ChildrenIds} ChildrenIds
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ChildrenIds.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a ChildrenIds message.
                     * @function verify
                     * @memberof anytype.Event.Block.Set.ChildrenIds
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ChildrenIds.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.childrenIds != null && message.hasOwnProperty("childrenIds")) {
                            if (!Array.isArray(message.childrenIds))
                                return "childrenIds: array expected";
                            for (var i = 0; i < message.childrenIds.length; ++i)
                                if (!$util.isString(message.childrenIds[i]))
                                    return "childrenIds: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a ChildrenIds message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Event.Block.Set.ChildrenIds
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Event.Block.Set.ChildrenIds} ChildrenIds
                     */
                    ChildrenIds.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Event.Block.Set.ChildrenIds)
                            return object;
                        var message = new $root.anytype.Event.Block.Set.ChildrenIds();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.childrenIds) {
                            if (!Array.isArray(object.childrenIds))
                                throw TypeError(".anytype.Event.Block.Set.ChildrenIds.childrenIds: array expected");
                            message.childrenIds = [];
                            for (var i = 0; i < object.childrenIds.length; ++i)
                                message.childrenIds[i] = String(object.childrenIds[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ChildrenIds message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Event.Block.Set.ChildrenIds
                     * @static
                     * @param {anytype.Event.Block.Set.ChildrenIds} message ChildrenIds
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ChildrenIds.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.childrenIds = [];
                        if (options.defaults)
                            object.id = "";
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.childrenIds && message.childrenIds.length) {
                            object.childrenIds = [];
                            for (var j = 0; j < message.childrenIds.length; ++j)
                                object.childrenIds[j] = message.childrenIds[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this ChildrenIds to JSON.
                     * @function toJSON
                     * @memberof anytype.Event.Block.Set.ChildrenIds
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ChildrenIds.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ChildrenIds;
                })();

                Set.Restrictions = (function() {

                    /**
                     * Properties of a Restrictions.
                     * @memberof anytype.Event.Block.Set
                     * @interface IRestrictions
                     * @property {string|null} [id] Restrictions id
                     * @property {anytype.model.Block.IRestrictions|null} [restrictions] Restrictions restrictions
                     */

                    /**
                     * Constructs a new Restrictions.
                     * @memberof anytype.Event.Block.Set
                     * @classdesc Represents a Restrictions.
                     * @implements IRestrictions
                     * @constructor
                     * @param {anytype.Event.Block.Set.IRestrictions=} [properties] Properties to set
                     */
                    function Restrictions(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Restrictions id.
                     * @member {string} id
                     * @memberof anytype.Event.Block.Set.Restrictions
                     * @instance
                     */
                    Restrictions.prototype.id = "";

                    /**
                     * Restrictions restrictions.
                     * @member {anytype.model.Block.IRestrictions|null|undefined} restrictions
                     * @memberof anytype.Event.Block.Set.Restrictions
                     * @instance
                     */
                    Restrictions.prototype.restrictions = null;

                    /**
                     * Creates a new Restrictions instance using the specified properties.
                     * @function create
                     * @memberof anytype.Event.Block.Set.Restrictions
                     * @static
                     * @param {anytype.Event.Block.Set.IRestrictions=} [properties] Properties to set
                     * @returns {anytype.Event.Block.Set.Restrictions} Restrictions instance
                     */
                    Restrictions.create = function create(properties) {
                        return new Restrictions(properties);
                    };

                    /**
                     * Encodes the specified Restrictions message. Does not implicitly {@link anytype.Event.Block.Set.Restrictions.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Event.Block.Set.Restrictions
                     * @static
                     * @param {anytype.Event.Block.Set.IRestrictions} message Restrictions message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Restrictions.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.restrictions != null && message.hasOwnProperty("restrictions"))
                            $root.anytype.model.Block.Restrictions.encode(message.restrictions, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Restrictions message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.Restrictions.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Event.Block.Set.Restrictions
                     * @static
                     * @param {anytype.Event.Block.Set.IRestrictions} message Restrictions message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Restrictions.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Restrictions message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Event.Block.Set.Restrictions
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Event.Block.Set.Restrictions} Restrictions
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Restrictions.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.Restrictions();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                message.restrictions = $root.anytype.model.Block.Restrictions.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Restrictions message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Event.Block.Set.Restrictions
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Event.Block.Set.Restrictions} Restrictions
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Restrictions.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Restrictions message.
                     * @function verify
                     * @memberof anytype.Event.Block.Set.Restrictions
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Restrictions.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.restrictions != null && message.hasOwnProperty("restrictions")) {
                            var error = $root.anytype.model.Block.Restrictions.verify(message.restrictions);
                            if (error)
                                return "restrictions." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Restrictions message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Event.Block.Set.Restrictions
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Event.Block.Set.Restrictions} Restrictions
                     */
                    Restrictions.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Event.Block.Set.Restrictions)
                            return object;
                        var message = new $root.anytype.Event.Block.Set.Restrictions();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.restrictions != null) {
                            if (typeof object.restrictions !== "object")
                                throw TypeError(".anytype.Event.Block.Set.Restrictions.restrictions: object expected");
                            message.restrictions = $root.anytype.model.Block.Restrictions.fromObject(object.restrictions);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Restrictions message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Event.Block.Set.Restrictions
                     * @static
                     * @param {anytype.Event.Block.Set.Restrictions} message Restrictions
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Restrictions.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.restrictions = null;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.restrictions != null && message.hasOwnProperty("restrictions"))
                            object.restrictions = $root.anytype.model.Block.Restrictions.toObject(message.restrictions, options);
                        return object;
                    };

                    /**
                     * Converts this Restrictions to JSON.
                     * @function toJSON
                     * @memberof anytype.Event.Block.Set.Restrictions
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Restrictions.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Restrictions;
                })();

                Set.IsArchived = (function() {

                    /**
                     * Properties of an IsArchived.
                     * @memberof anytype.Event.Block.Set
                     * @interface IIsArchived
                     * @property {string|null} [id] IsArchived id
                     * @property {boolean|null} [IsArchived] IsArchived IsArchived
                     */

                    /**
                     * Constructs a new IsArchived.
                     * @memberof anytype.Event.Block.Set
                     * @classdesc Represents an IsArchived.
                     * @implements IIsArchived
                     * @constructor
                     * @param {anytype.Event.Block.Set.IIsArchived=} [properties] Properties to set
                     */
                    function IsArchived(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * IsArchived id.
                     * @member {string} id
                     * @memberof anytype.Event.Block.Set.IsArchived
                     * @instance
                     */
                    IsArchived.prototype.id = "";

                    /**
                     * IsArchived IsArchived.
                     * @member {boolean} IsArchived
                     * @memberof anytype.Event.Block.Set.IsArchived
                     * @instance
                     */
                    IsArchived.prototype.IsArchived = false;

                    /**
                     * Creates a new IsArchived instance using the specified properties.
                     * @function create
                     * @memberof anytype.Event.Block.Set.IsArchived
                     * @static
                     * @param {anytype.Event.Block.Set.IIsArchived=} [properties] Properties to set
                     * @returns {anytype.Event.Block.Set.IsArchived} IsArchived instance
                     */
                    IsArchived.create = function create(properties) {
                        return new IsArchived(properties);
                    };

                    /**
                     * Encodes the specified IsArchived message. Does not implicitly {@link anytype.Event.Block.Set.IsArchived.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Event.Block.Set.IsArchived
                     * @static
                     * @param {anytype.Event.Block.Set.IIsArchived} message IsArchived message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    IsArchived.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.IsArchived != null && message.hasOwnProperty("IsArchived"))
                            writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsArchived);
                        return writer;
                    };

                    /**
                     * Encodes the specified IsArchived message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.IsArchived.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Event.Block.Set.IsArchived
                     * @static
                     * @param {anytype.Event.Block.Set.IIsArchived} message IsArchived message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    IsArchived.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an IsArchived message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Event.Block.Set.IsArchived
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Event.Block.Set.IsArchived} IsArchived
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    IsArchived.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.IsArchived();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                message.IsArchived = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an IsArchived message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Event.Block.Set.IsArchived
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Event.Block.Set.IsArchived} IsArchived
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    IsArchived.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an IsArchived message.
                     * @function verify
                     * @memberof anytype.Event.Block.Set.IsArchived
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    IsArchived.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.IsArchived != null && message.hasOwnProperty("IsArchived"))
                            if (typeof message.IsArchived !== "boolean")
                                return "IsArchived: boolean expected";
                        return null;
                    };

                    /**
                     * Creates an IsArchived message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Event.Block.Set.IsArchived
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Event.Block.Set.IsArchived} IsArchived
                     */
                    IsArchived.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Event.Block.Set.IsArchived)
                            return object;
                        var message = new $root.anytype.Event.Block.Set.IsArchived();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.IsArchived != null)
                            message.IsArchived = Boolean(object.IsArchived);
                        return message;
                    };

                    /**
                     * Creates a plain object from an IsArchived message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Event.Block.Set.IsArchived
                     * @static
                     * @param {anytype.Event.Block.Set.IsArchived} message IsArchived
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    IsArchived.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.IsArchived = false;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.IsArchived != null && message.hasOwnProperty("IsArchived"))
                            object.IsArchived = message.IsArchived;
                        return object;
                    };

                    /**
                     * Converts this IsArchived to JSON.
                     * @function toJSON
                     * @memberof anytype.Event.Block.Set.IsArchived
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    IsArchived.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return IsArchived;
                })();

                Set.Text = (function() {

                    /**
                     * Properties of a Text.
                     * @memberof anytype.Event.Block.Set
                     * @interface IText
                     * @property {string|null} [id] Text id
                     * @property {anytype.Event.Block.Set.Text.IText|null} [text] Text text
                     * @property {anytype.Event.Block.Set.Text.IStyle|null} [style] Text style
                     * @property {anytype.Event.Block.Set.Text.IMarks|null} [marks] Text marks
                     * @property {anytype.Event.Block.Set.Text.IChecked|null} [checked] Text checked
                     * @property {anytype.Event.Block.Set.Text.IColor|null} [color] Text color
                     * @property {anytype.Event.Block.Set.Text.IBackgroundColor|null} [backgroundColor] Text backgroundColor
                     */

                    /**
                     * Constructs a new Text.
                     * @memberof anytype.Event.Block.Set
                     * @classdesc Represents a Text.
                     * @implements IText
                     * @constructor
                     * @param {anytype.Event.Block.Set.IText=} [properties] Properties to set
                     */
                    function Text(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Text id.
                     * @member {string} id
                     * @memberof anytype.Event.Block.Set.Text
                     * @instance
                     */
                    Text.prototype.id = "";

                    /**
                     * Text text.
                     * @member {anytype.Event.Block.Set.Text.IText|null|undefined} text
                     * @memberof anytype.Event.Block.Set.Text
                     * @instance
                     */
                    Text.prototype.text = null;

                    /**
                     * Text style.
                     * @member {anytype.Event.Block.Set.Text.IStyle|null|undefined} style
                     * @memberof anytype.Event.Block.Set.Text
                     * @instance
                     */
                    Text.prototype.style = null;

                    /**
                     * Text marks.
                     * @member {anytype.Event.Block.Set.Text.IMarks|null|undefined} marks
                     * @memberof anytype.Event.Block.Set.Text
                     * @instance
                     */
                    Text.prototype.marks = null;

                    /**
                     * Text checked.
                     * @member {anytype.Event.Block.Set.Text.IChecked|null|undefined} checked
                     * @memberof anytype.Event.Block.Set.Text
                     * @instance
                     */
                    Text.prototype.checked = null;

                    /**
                     * Text color.
                     * @member {anytype.Event.Block.Set.Text.IColor|null|undefined} color
                     * @memberof anytype.Event.Block.Set.Text
                     * @instance
                     */
                    Text.prototype.color = null;

                    /**
                     * Text backgroundColor.
                     * @member {anytype.Event.Block.Set.Text.IBackgroundColor|null|undefined} backgroundColor
                     * @memberof anytype.Event.Block.Set.Text
                     * @instance
                     */
                    Text.prototype.backgroundColor = null;

                    /**
                     * Creates a new Text instance using the specified properties.
                     * @function create
                     * @memberof anytype.Event.Block.Set.Text
                     * @static
                     * @param {anytype.Event.Block.Set.IText=} [properties] Properties to set
                     * @returns {anytype.Event.Block.Set.Text} Text instance
                     */
                    Text.create = function create(properties) {
                        return new Text(properties);
                    };

                    /**
                     * Encodes the specified Text message. Does not implicitly {@link anytype.Event.Block.Set.Text.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Event.Block.Set.Text
                     * @static
                     * @param {anytype.Event.Block.Set.IText} message Text message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Text.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.text != null && message.hasOwnProperty("text"))
                            $root.anytype.Event.Block.Set.Text.Text.encode(message.text, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.style != null && message.hasOwnProperty("style"))
                            $root.anytype.Event.Block.Set.Text.Style.encode(message.style, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.marks != null && message.hasOwnProperty("marks"))
                            $root.anytype.Event.Block.Set.Text.Marks.encode(message.marks, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.checked != null && message.hasOwnProperty("checked"))
                            $root.anytype.Event.Block.Set.Text.Checked.encode(message.checked, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        if (message.color != null && message.hasOwnProperty("color"))
                            $root.anytype.Event.Block.Set.Text.Color.encode(message.color, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                        if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor"))
                            $root.anytype.Event.Block.Set.Text.BackgroundColor.encode(message.backgroundColor, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Text message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.Text.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Event.Block.Set.Text
                     * @static
                     * @param {anytype.Event.Block.Set.IText} message Text message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Text.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Text message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Event.Block.Set.Text
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Event.Block.Set.Text} Text
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Text.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.Text();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                message.text = $root.anytype.Event.Block.Set.Text.Text.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.style = $root.anytype.Event.Block.Set.Text.Style.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.marks = $root.anytype.Event.Block.Set.Text.Marks.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.checked = $root.anytype.Event.Block.Set.Text.Checked.decode(reader, reader.uint32());
                                break;
                            case 6:
                                message.color = $root.anytype.Event.Block.Set.Text.Color.decode(reader, reader.uint32());
                                break;
                            case 7:
                                message.backgroundColor = $root.anytype.Event.Block.Set.Text.BackgroundColor.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Text message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Event.Block.Set.Text
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Event.Block.Set.Text} Text
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Text.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Text message.
                     * @function verify
                     * @memberof anytype.Event.Block.Set.Text
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Text.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.text != null && message.hasOwnProperty("text")) {
                            var error = $root.anytype.Event.Block.Set.Text.Text.verify(message.text);
                            if (error)
                                return "text." + error;
                        }
                        if (message.style != null && message.hasOwnProperty("style")) {
                            var error = $root.anytype.Event.Block.Set.Text.Style.verify(message.style);
                            if (error)
                                return "style." + error;
                        }
                        if (message.marks != null && message.hasOwnProperty("marks")) {
                            var error = $root.anytype.Event.Block.Set.Text.Marks.verify(message.marks);
                            if (error)
                                return "marks." + error;
                        }
                        if (message.checked != null && message.hasOwnProperty("checked")) {
                            var error = $root.anytype.Event.Block.Set.Text.Checked.verify(message.checked);
                            if (error)
                                return "checked." + error;
                        }
                        if (message.color != null && message.hasOwnProperty("color")) {
                            var error = $root.anytype.Event.Block.Set.Text.Color.verify(message.color);
                            if (error)
                                return "color." + error;
                        }
                        if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor")) {
                            var error = $root.anytype.Event.Block.Set.Text.BackgroundColor.verify(message.backgroundColor);
                            if (error)
                                return "backgroundColor." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Text message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Event.Block.Set.Text
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Event.Block.Set.Text} Text
                     */
                    Text.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Event.Block.Set.Text)
                            return object;
                        var message = new $root.anytype.Event.Block.Set.Text();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.text != null) {
                            if (typeof object.text !== "object")
                                throw TypeError(".anytype.Event.Block.Set.Text.text: object expected");
                            message.text = $root.anytype.Event.Block.Set.Text.Text.fromObject(object.text);
                        }
                        if (object.style != null) {
                            if (typeof object.style !== "object")
                                throw TypeError(".anytype.Event.Block.Set.Text.style: object expected");
                            message.style = $root.anytype.Event.Block.Set.Text.Style.fromObject(object.style);
                        }
                        if (object.marks != null) {
                            if (typeof object.marks !== "object")
                                throw TypeError(".anytype.Event.Block.Set.Text.marks: object expected");
                            message.marks = $root.anytype.Event.Block.Set.Text.Marks.fromObject(object.marks);
                        }
                        if (object.checked != null) {
                            if (typeof object.checked !== "object")
                                throw TypeError(".anytype.Event.Block.Set.Text.checked: object expected");
                            message.checked = $root.anytype.Event.Block.Set.Text.Checked.fromObject(object.checked);
                        }
                        if (object.color != null) {
                            if (typeof object.color !== "object")
                                throw TypeError(".anytype.Event.Block.Set.Text.color: object expected");
                            message.color = $root.anytype.Event.Block.Set.Text.Color.fromObject(object.color);
                        }
                        if (object.backgroundColor != null) {
                            if (typeof object.backgroundColor !== "object")
                                throw TypeError(".anytype.Event.Block.Set.Text.backgroundColor: object expected");
                            message.backgroundColor = $root.anytype.Event.Block.Set.Text.BackgroundColor.fromObject(object.backgroundColor);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Text message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Event.Block.Set.Text
                     * @static
                     * @param {anytype.Event.Block.Set.Text} message Text
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Text.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.text = null;
                            object.style = null;
                            object.marks = null;
                            object.checked = null;
                            object.color = null;
                            object.backgroundColor = null;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.text != null && message.hasOwnProperty("text"))
                            object.text = $root.anytype.Event.Block.Set.Text.Text.toObject(message.text, options);
                        if (message.style != null && message.hasOwnProperty("style"))
                            object.style = $root.anytype.Event.Block.Set.Text.Style.toObject(message.style, options);
                        if (message.marks != null && message.hasOwnProperty("marks"))
                            object.marks = $root.anytype.Event.Block.Set.Text.Marks.toObject(message.marks, options);
                        if (message.checked != null && message.hasOwnProperty("checked"))
                            object.checked = $root.anytype.Event.Block.Set.Text.Checked.toObject(message.checked, options);
                        if (message.color != null && message.hasOwnProperty("color"))
                            object.color = $root.anytype.Event.Block.Set.Text.Color.toObject(message.color, options);
                        if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor"))
                            object.backgroundColor = $root.anytype.Event.Block.Set.Text.BackgroundColor.toObject(message.backgroundColor, options);
                        return object;
                    };

                    /**
                     * Converts this Text to JSON.
                     * @function toJSON
                     * @memberof anytype.Event.Block.Set.Text
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Text.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Text.Text = (function() {

                        /**
                         * Properties of a Text.
                         * @memberof anytype.Event.Block.Set.Text
                         * @interface IText
                         * @property {string|null} [value] Text value
                         */

                        /**
                         * Constructs a new Text.
                         * @memberof anytype.Event.Block.Set.Text
                         * @classdesc Represents a Text.
                         * @implements IText
                         * @constructor
                         * @param {anytype.Event.Block.Set.Text.IText=} [properties] Properties to set
                         */
                        function Text(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Text value.
                         * @member {string} value
                         * @memberof anytype.Event.Block.Set.Text.Text
                         * @instance
                         */
                        Text.prototype.value = "";

                        /**
                         * Creates a new Text instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.Text.Text
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IText=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.Text.Text} Text instance
                         */
                        Text.create = function create(properties) {
                            return new Text(properties);
                        };

                        /**
                         * Encodes the specified Text message. Does not implicitly {@link anytype.Event.Block.Set.Text.Text.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.Text.Text
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IText} message Text message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Text.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified Text message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.Text.Text.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.Text.Text
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IText} message Text message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Text.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Text message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.Text.Text
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.Text.Text} Text
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Text.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.Text.Text();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Text message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.Text.Text
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.Text.Text} Text
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Text.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Text message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.Text.Text
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Text.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!$util.isString(message.value))
                                    return "value: string expected";
                            return null;
                        };

                        /**
                         * Creates a Text message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.Text.Text
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.Text.Text} Text
                         */
                        Text.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.Text.Text)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.Text.Text();
                            if (object.value != null)
                                message.value = String(object.value);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Text message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.Text.Text
                         * @static
                         * @param {anytype.Event.Block.Set.Text.Text} message Text
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Text.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = "";
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = message.value;
                            return object;
                        };

                        /**
                         * Converts this Text to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.Text.Text
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Text.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Text;
                    })();

                    Text.Style = (function() {

                        /**
                         * Properties of a Style.
                         * @memberof anytype.Event.Block.Set.Text
                         * @interface IStyle
                         * @property {anytype.model.Block.Content.Text.Style|null} [value] Style value
                         */

                        /**
                         * Constructs a new Style.
                         * @memberof anytype.Event.Block.Set.Text
                         * @classdesc Represents a Style.
                         * @implements IStyle
                         * @constructor
                         * @param {anytype.Event.Block.Set.Text.IStyle=} [properties] Properties to set
                         */
                        function Style(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Style value.
                         * @member {anytype.model.Block.Content.Text.Style} value
                         * @memberof anytype.Event.Block.Set.Text.Style
                         * @instance
                         */
                        Style.prototype.value = 0;

                        /**
                         * Creates a new Style instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.Text.Style
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IStyle=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.Text.Style} Style instance
                         */
                        Style.create = function create(properties) {
                            return new Style(properties);
                        };

                        /**
                         * Encodes the specified Style message. Does not implicitly {@link anytype.Event.Block.Set.Text.Style.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.Text.Style
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IStyle} message Style message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Style.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified Style message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.Text.Style.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.Text.Style
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IStyle} message Style message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Style.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Style message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.Text.Style
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.Text.Style} Style
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Style.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.Text.Style();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.int32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Style message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.Text.Style
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.Text.Style} Style
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Style.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Style message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.Text.Style
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Style.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                switch (message.value) {
                                default:
                                    return "value: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                case 10:
                                case 11:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a Style message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.Text.Style
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.Text.Style} Style
                         */
                        Style.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.Text.Style)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.Text.Style();
                            switch (object.value) {
                            case "Paragraph":
                            case 0:
                                message.value = 0;
                                break;
                            case "Header1":
                            case 1:
                                message.value = 1;
                                break;
                            case "Header2":
                            case 2:
                                message.value = 2;
                                break;
                            case "Header3":
                            case 3:
                                message.value = 3;
                                break;
                            case "Header4":
                            case 4:
                                message.value = 4;
                                break;
                            case "Quote":
                            case 5:
                                message.value = 5;
                                break;
                            case "Code":
                            case 6:
                                message.value = 6;
                                break;
                            case "Title":
                            case 7:
                                message.value = 7;
                                break;
                            case "Checkbox":
                            case 8:
                                message.value = 8;
                                break;
                            case "Marked":
                            case 9:
                                message.value = 9;
                                break;
                            case "Numbered":
                            case 10:
                                message.value = 10;
                                break;
                            case "Toggle":
                            case 11:
                                message.value = 11;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Style message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.Text.Style
                         * @static
                         * @param {anytype.Event.Block.Set.Text.Style} message Style
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Style.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = options.enums === String ? "Paragraph" : 0;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = options.enums === String ? $root.anytype.model.Block.Content.Text.Style[message.value] : message.value;
                            return object;
                        };

                        /**
                         * Converts this Style to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.Text.Style
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Style.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Style;
                    })();

                    Text.Marks = (function() {

                        /**
                         * Properties of a Marks.
                         * @memberof anytype.Event.Block.Set.Text
                         * @interface IMarks
                         * @property {anytype.model.Block.Content.Text.IMarks|null} [value] Marks value
                         */

                        /**
                         * Constructs a new Marks.
                         * @memberof anytype.Event.Block.Set.Text
                         * @classdesc Represents a Marks.
                         * @implements IMarks
                         * @constructor
                         * @param {anytype.Event.Block.Set.Text.IMarks=} [properties] Properties to set
                         */
                        function Marks(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Marks value.
                         * @member {anytype.model.Block.Content.Text.IMarks|null|undefined} value
                         * @memberof anytype.Event.Block.Set.Text.Marks
                         * @instance
                         */
                        Marks.prototype.value = null;

                        /**
                         * Creates a new Marks instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.Text.Marks
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IMarks=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.Text.Marks} Marks instance
                         */
                        Marks.create = function create(properties) {
                            return new Marks(properties);
                        };

                        /**
                         * Encodes the specified Marks message. Does not implicitly {@link anytype.Event.Block.Set.Text.Marks.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.Text.Marks
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IMarks} message Marks message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Marks.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                $root.anytype.model.Block.Content.Text.Marks.encode(message.value, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Marks message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.Text.Marks.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.Text.Marks
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IMarks} message Marks message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Marks.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Marks message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.Text.Marks
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.Text.Marks} Marks
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Marks.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.Text.Marks();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = $root.anytype.model.Block.Content.Text.Marks.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Marks message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.Text.Marks
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.Text.Marks} Marks
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Marks.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Marks message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.Text.Marks
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Marks.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value")) {
                                var error = $root.anytype.model.Block.Content.Text.Marks.verify(message.value);
                                if (error)
                                    return "value." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Marks message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.Text.Marks
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.Text.Marks} Marks
                         */
                        Marks.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.Text.Marks)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.Text.Marks();
                            if (object.value != null) {
                                if (typeof object.value !== "object")
                                    throw TypeError(".anytype.Event.Block.Set.Text.Marks.value: object expected");
                                message.value = $root.anytype.model.Block.Content.Text.Marks.fromObject(object.value);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Marks message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.Text.Marks
                         * @static
                         * @param {anytype.Event.Block.Set.Text.Marks} message Marks
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Marks.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = null;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = $root.anytype.model.Block.Content.Text.Marks.toObject(message.value, options);
                            return object;
                        };

                        /**
                         * Converts this Marks to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.Text.Marks
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Marks.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Marks;
                    })();

                    Text.Checked = (function() {

                        /**
                         * Properties of a Checked.
                         * @memberof anytype.Event.Block.Set.Text
                         * @interface IChecked
                         * @property {boolean|null} [value] Checked value
                         */

                        /**
                         * Constructs a new Checked.
                         * @memberof anytype.Event.Block.Set.Text
                         * @classdesc Represents a Checked.
                         * @implements IChecked
                         * @constructor
                         * @param {anytype.Event.Block.Set.Text.IChecked=} [properties] Properties to set
                         */
                        function Checked(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Checked value.
                         * @member {boolean} value
                         * @memberof anytype.Event.Block.Set.Text.Checked
                         * @instance
                         */
                        Checked.prototype.value = false;

                        /**
                         * Creates a new Checked instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.Text.Checked
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IChecked=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.Text.Checked} Checked instance
                         */
                        Checked.create = function create(properties) {
                            return new Checked(properties);
                        };

                        /**
                         * Encodes the specified Checked message. Does not implicitly {@link anytype.Event.Block.Set.Text.Checked.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.Text.Checked
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IChecked} message Checked message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Checked.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified Checked message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.Text.Checked.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.Text.Checked
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IChecked} message Checked message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Checked.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Checked message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.Text.Checked
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.Text.Checked} Checked
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Checked.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.Text.Checked();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.bool();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Checked message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.Text.Checked
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.Text.Checked} Checked
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Checked.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Checked message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.Text.Checked
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Checked.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (typeof message.value !== "boolean")
                                    return "value: boolean expected";
                            return null;
                        };

                        /**
                         * Creates a Checked message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.Text.Checked
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.Text.Checked} Checked
                         */
                        Checked.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.Text.Checked)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.Text.Checked();
                            if (object.value != null)
                                message.value = Boolean(object.value);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Checked message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.Text.Checked
                         * @static
                         * @param {anytype.Event.Block.Set.Text.Checked} message Checked
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Checked.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = false;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = message.value;
                            return object;
                        };

                        /**
                         * Converts this Checked to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.Text.Checked
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Checked.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Checked;
                    })();

                    Text.Color = (function() {

                        /**
                         * Properties of a Color.
                         * @memberof anytype.Event.Block.Set.Text
                         * @interface IColor
                         * @property {string|null} [value] Color value
                         */

                        /**
                         * Constructs a new Color.
                         * @memberof anytype.Event.Block.Set.Text
                         * @classdesc Represents a Color.
                         * @implements IColor
                         * @constructor
                         * @param {anytype.Event.Block.Set.Text.IColor=} [properties] Properties to set
                         */
                        function Color(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Color value.
                         * @member {string} value
                         * @memberof anytype.Event.Block.Set.Text.Color
                         * @instance
                         */
                        Color.prototype.value = "";

                        /**
                         * Creates a new Color instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.Text.Color
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IColor=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.Text.Color} Color instance
                         */
                        Color.create = function create(properties) {
                            return new Color(properties);
                        };

                        /**
                         * Encodes the specified Color message. Does not implicitly {@link anytype.Event.Block.Set.Text.Color.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.Text.Color
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IColor} message Color message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Color.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified Color message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.Text.Color.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.Text.Color
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IColor} message Color message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Color.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Color message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.Text.Color
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.Text.Color} Color
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Color.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.Text.Color();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Color message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.Text.Color
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.Text.Color} Color
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Color.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Color message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.Text.Color
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Color.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!$util.isString(message.value))
                                    return "value: string expected";
                            return null;
                        };

                        /**
                         * Creates a Color message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.Text.Color
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.Text.Color} Color
                         */
                        Color.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.Text.Color)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.Text.Color();
                            if (object.value != null)
                                message.value = String(object.value);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Color message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.Text.Color
                         * @static
                         * @param {anytype.Event.Block.Set.Text.Color} message Color
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Color.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = "";
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = message.value;
                            return object;
                        };

                        /**
                         * Converts this Color to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.Text.Color
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Color.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Color;
                    })();

                    Text.BackgroundColor = (function() {

                        /**
                         * Properties of a BackgroundColor.
                         * @memberof anytype.Event.Block.Set.Text
                         * @interface IBackgroundColor
                         * @property {string|null} [value] BackgroundColor value
                         */

                        /**
                         * Constructs a new BackgroundColor.
                         * @memberof anytype.Event.Block.Set.Text
                         * @classdesc Represents a BackgroundColor.
                         * @implements IBackgroundColor
                         * @constructor
                         * @param {anytype.Event.Block.Set.Text.IBackgroundColor=} [properties] Properties to set
                         */
                        function BackgroundColor(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * BackgroundColor value.
                         * @member {string} value
                         * @memberof anytype.Event.Block.Set.Text.BackgroundColor
                         * @instance
                         */
                        BackgroundColor.prototype.value = "";

                        /**
                         * Creates a new BackgroundColor instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IBackgroundColor=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.Text.BackgroundColor} BackgroundColor instance
                         */
                        BackgroundColor.create = function create(properties) {
                            return new BackgroundColor(properties);
                        };

                        /**
                         * Encodes the specified BackgroundColor message. Does not implicitly {@link anytype.Event.Block.Set.Text.BackgroundColor.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IBackgroundColor} message BackgroundColor message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BackgroundColor.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified BackgroundColor message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.Text.BackgroundColor.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {anytype.Event.Block.Set.Text.IBackgroundColor} message BackgroundColor message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        BackgroundColor.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a BackgroundColor message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.Text.BackgroundColor} BackgroundColor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BackgroundColor.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.Text.BackgroundColor();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a BackgroundColor message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.Text.BackgroundColor} BackgroundColor
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        BackgroundColor.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a BackgroundColor message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        BackgroundColor.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!$util.isString(message.value))
                                    return "value: string expected";
                            return null;
                        };

                        /**
                         * Creates a BackgroundColor message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.Text.BackgroundColor} BackgroundColor
                         */
                        BackgroundColor.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.Text.BackgroundColor)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.Text.BackgroundColor();
                            if (object.value != null)
                                message.value = String(object.value);
                            return message;
                        };

                        /**
                         * Creates a plain object from a BackgroundColor message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.Text.BackgroundColor
                         * @static
                         * @param {anytype.Event.Block.Set.Text.BackgroundColor} message BackgroundColor
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        BackgroundColor.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = "";
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = message.value;
                            return object;
                        };

                        /**
                         * Converts this BackgroundColor to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.Text.BackgroundColor
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        BackgroundColor.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return BackgroundColor;
                    })();

                    return Text;
                })();

                Set.File = (function() {

                    /**
                     * Properties of a File.
                     * @memberof anytype.Event.Block.Set
                     * @interface IFile
                     * @property {string|null} [id] File id
                     * @property {anytype.Event.Block.Set.File.IType|null} [type] File type
                     * @property {anytype.Event.Block.Set.File.IState|null} [state] File state
                     * @property {anytype.Event.Block.Set.File.ILocalFilePath|null} [localFilePath] File localFilePath
                     * @property {anytype.Event.Block.Set.File.IPreviewLocalFilePath|null} [previewLocalFilePath] File previewLocalFilePath
                     */

                    /**
                     * Constructs a new File.
                     * @memberof anytype.Event.Block.Set
                     * @classdesc Represents a File.
                     * @implements IFile
                     * @constructor
                     * @param {anytype.Event.Block.Set.IFile=} [properties] Properties to set
                     */
                    function File(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * File id.
                     * @member {string} id
                     * @memberof anytype.Event.Block.Set.File
                     * @instance
                     */
                    File.prototype.id = "";

                    /**
                     * File type.
                     * @member {anytype.Event.Block.Set.File.IType|null|undefined} type
                     * @memberof anytype.Event.Block.Set.File
                     * @instance
                     */
                    File.prototype.type = null;

                    /**
                     * File state.
                     * @member {anytype.Event.Block.Set.File.IState|null|undefined} state
                     * @memberof anytype.Event.Block.Set.File
                     * @instance
                     */
                    File.prototype.state = null;

                    /**
                     * File localFilePath.
                     * @member {anytype.Event.Block.Set.File.ILocalFilePath|null|undefined} localFilePath
                     * @memberof anytype.Event.Block.Set.File
                     * @instance
                     */
                    File.prototype.localFilePath = null;

                    /**
                     * File previewLocalFilePath.
                     * @member {anytype.Event.Block.Set.File.IPreviewLocalFilePath|null|undefined} previewLocalFilePath
                     * @memberof anytype.Event.Block.Set.File
                     * @instance
                     */
                    File.prototype.previewLocalFilePath = null;

                    /**
                     * Creates a new File instance using the specified properties.
                     * @function create
                     * @memberof anytype.Event.Block.Set.File
                     * @static
                     * @param {anytype.Event.Block.Set.IFile=} [properties] Properties to set
                     * @returns {anytype.Event.Block.Set.File} File instance
                     */
                    File.create = function create(properties) {
                        return new File(properties);
                    };

                    /**
                     * Encodes the specified File message. Does not implicitly {@link anytype.Event.Block.Set.File.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Event.Block.Set.File
                     * @static
                     * @param {anytype.Event.Block.Set.IFile} message File message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    File.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.type != null && message.hasOwnProperty("type"))
                            $root.anytype.Event.Block.Set.File.Type.encode(message.type, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        if (message.state != null && message.hasOwnProperty("state"))
                            $root.anytype.Event.Block.Set.File.State.encode(message.state, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.localFilePath != null && message.hasOwnProperty("localFilePath"))
                            $root.anytype.Event.Block.Set.File.LocalFilePath.encode(message.localFilePath, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                        if (message.previewLocalFilePath != null && message.hasOwnProperty("previewLocalFilePath"))
                            $root.anytype.Event.Block.Set.File.PreviewLocalFilePath.encode(message.previewLocalFilePath, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified File message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.File.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Event.Block.Set.File
                     * @static
                     * @param {anytype.Event.Block.Set.IFile} message File message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    File.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a File message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Event.Block.Set.File
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Event.Block.Set.File} File
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    File.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.File();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                message.type = $root.anytype.Event.Block.Set.File.Type.decode(reader, reader.uint32());
                                break;
                            case 3:
                                message.state = $root.anytype.Event.Block.Set.File.State.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.localFilePath = $root.anytype.Event.Block.Set.File.LocalFilePath.decode(reader, reader.uint32());
                                break;
                            case 5:
                                message.previewLocalFilePath = $root.anytype.Event.Block.Set.File.PreviewLocalFilePath.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a File message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Event.Block.Set.File
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Event.Block.Set.File} File
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    File.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a File message.
                     * @function verify
                     * @memberof anytype.Event.Block.Set.File
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    File.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.type != null && message.hasOwnProperty("type")) {
                            var error = $root.anytype.Event.Block.Set.File.Type.verify(message.type);
                            if (error)
                                return "type." + error;
                        }
                        if (message.state != null && message.hasOwnProperty("state")) {
                            var error = $root.anytype.Event.Block.Set.File.State.verify(message.state);
                            if (error)
                                return "state." + error;
                        }
                        if (message.localFilePath != null && message.hasOwnProperty("localFilePath")) {
                            var error = $root.anytype.Event.Block.Set.File.LocalFilePath.verify(message.localFilePath);
                            if (error)
                                return "localFilePath." + error;
                        }
                        if (message.previewLocalFilePath != null && message.hasOwnProperty("previewLocalFilePath")) {
                            var error = $root.anytype.Event.Block.Set.File.PreviewLocalFilePath.verify(message.previewLocalFilePath);
                            if (error)
                                return "previewLocalFilePath." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a File message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Event.Block.Set.File
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Event.Block.Set.File} File
                     */
                    File.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Event.Block.Set.File)
                            return object;
                        var message = new $root.anytype.Event.Block.Set.File();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.type != null) {
                            if (typeof object.type !== "object")
                                throw TypeError(".anytype.Event.Block.Set.File.type: object expected");
                            message.type = $root.anytype.Event.Block.Set.File.Type.fromObject(object.type);
                        }
                        if (object.state != null) {
                            if (typeof object.state !== "object")
                                throw TypeError(".anytype.Event.Block.Set.File.state: object expected");
                            message.state = $root.anytype.Event.Block.Set.File.State.fromObject(object.state);
                        }
                        if (object.localFilePath != null) {
                            if (typeof object.localFilePath !== "object")
                                throw TypeError(".anytype.Event.Block.Set.File.localFilePath: object expected");
                            message.localFilePath = $root.anytype.Event.Block.Set.File.LocalFilePath.fromObject(object.localFilePath);
                        }
                        if (object.previewLocalFilePath != null) {
                            if (typeof object.previewLocalFilePath !== "object")
                                throw TypeError(".anytype.Event.Block.Set.File.previewLocalFilePath: object expected");
                            message.previewLocalFilePath = $root.anytype.Event.Block.Set.File.PreviewLocalFilePath.fromObject(object.previewLocalFilePath);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a File message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Event.Block.Set.File
                     * @static
                     * @param {anytype.Event.Block.Set.File} message File
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    File.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.type = null;
                            object.state = null;
                            object.localFilePath = null;
                            object.previewLocalFilePath = null;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = $root.anytype.Event.Block.Set.File.Type.toObject(message.type, options);
                        if (message.state != null && message.hasOwnProperty("state"))
                            object.state = $root.anytype.Event.Block.Set.File.State.toObject(message.state, options);
                        if (message.localFilePath != null && message.hasOwnProperty("localFilePath"))
                            object.localFilePath = $root.anytype.Event.Block.Set.File.LocalFilePath.toObject(message.localFilePath, options);
                        if (message.previewLocalFilePath != null && message.hasOwnProperty("previewLocalFilePath"))
                            object.previewLocalFilePath = $root.anytype.Event.Block.Set.File.PreviewLocalFilePath.toObject(message.previewLocalFilePath, options);
                        return object;
                    };

                    /**
                     * Converts this File to JSON.
                     * @function toJSON
                     * @memberof anytype.Event.Block.Set.File
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    File.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    File.Name = (function() {

                        /**
                         * Properties of a Name.
                         * @memberof anytype.Event.Block.Set.File
                         * @interface IName
                         * @property {string|null} [value] Name value
                         */

                        /**
                         * Constructs a new Name.
                         * @memberof anytype.Event.Block.Set.File
                         * @classdesc Represents a Name.
                         * @implements IName
                         * @constructor
                         * @param {anytype.Event.Block.Set.File.IName=} [properties] Properties to set
                         */
                        function Name(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Name value.
                         * @member {string} value
                         * @memberof anytype.Event.Block.Set.File.Name
                         * @instance
                         */
                        Name.prototype.value = "";

                        /**
                         * Creates a new Name instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.File.Name
                         * @static
                         * @param {anytype.Event.Block.Set.File.IName=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.File.Name} Name instance
                         */
                        Name.create = function create(properties) {
                            return new Name(properties);
                        };

                        /**
                         * Encodes the specified Name message. Does not implicitly {@link anytype.Event.Block.Set.File.Name.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.File.Name
                         * @static
                         * @param {anytype.Event.Block.Set.File.IName} message Name message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Name.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified Name message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.File.Name.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.File.Name
                         * @static
                         * @param {anytype.Event.Block.Set.File.IName} message Name message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Name.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Name message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.File.Name
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.File.Name} Name
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Name.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.File.Name();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Name message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.File.Name
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.File.Name} Name
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Name.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Name message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.File.Name
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Name.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!$util.isString(message.value))
                                    return "value: string expected";
                            return null;
                        };

                        /**
                         * Creates a Name message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.File.Name
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.File.Name} Name
                         */
                        Name.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.File.Name)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.File.Name();
                            if (object.value != null)
                                message.value = String(object.value);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Name message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.File.Name
                         * @static
                         * @param {anytype.Event.Block.Set.File.Name} message Name
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Name.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = "";
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = message.value;
                            return object;
                        };

                        /**
                         * Converts this Name to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.File.Name
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Name.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Name;
                    })();

                    File.Width = (function() {

                        /**
                         * Properties of a Width.
                         * @memberof anytype.Event.Block.Set.File
                         * @interface IWidth
                         * @property {number|null} [value] Width value
                         */

                        /**
                         * Constructs a new Width.
                         * @memberof anytype.Event.Block.Set.File
                         * @classdesc Represents a Width.
                         * @implements IWidth
                         * @constructor
                         * @param {anytype.Event.Block.Set.File.IWidth=} [properties] Properties to set
                         */
                        function Width(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Width value.
                         * @member {number} value
                         * @memberof anytype.Event.Block.Set.File.Width
                         * @instance
                         */
                        Width.prototype.value = 0;

                        /**
                         * Creates a new Width instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.File.Width
                         * @static
                         * @param {anytype.Event.Block.Set.File.IWidth=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.File.Width} Width instance
                         */
                        Width.create = function create(properties) {
                            return new Width(properties);
                        };

                        /**
                         * Encodes the specified Width message. Does not implicitly {@link anytype.Event.Block.Set.File.Width.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.File.Width
                         * @static
                         * @param {anytype.Event.Block.Set.File.IWidth} message Width message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Width.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified Width message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.File.Width.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.File.Width
                         * @static
                         * @param {anytype.Event.Block.Set.File.IWidth} message Width message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Width.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Width message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.File.Width
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.File.Width} Width
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Width.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.File.Width();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.int32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Width message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.File.Width
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.File.Width} Width
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Width.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Width message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.File.Width
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Width.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!$util.isInteger(message.value))
                                    return "value: integer expected";
                            return null;
                        };

                        /**
                         * Creates a Width message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.File.Width
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.File.Width} Width
                         */
                        Width.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.File.Width)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.File.Width();
                            if (object.value != null)
                                message.value = object.value | 0;
                            return message;
                        };

                        /**
                         * Creates a plain object from a Width message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.File.Width
                         * @static
                         * @param {anytype.Event.Block.Set.File.Width} message Width
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Width.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = 0;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = message.value;
                            return object;
                        };

                        /**
                         * Converts this Width to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.File.Width
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Width.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Width;
                    })();

                    File.State = (function() {

                        /**
                         * Properties of a State.
                         * @memberof anytype.Event.Block.Set.File
                         * @interface IState
                         * @property {anytype.model.Block.Content.File.State|null} [value] State value
                         */

                        /**
                         * Constructs a new State.
                         * @memberof anytype.Event.Block.Set.File
                         * @classdesc Represents a State.
                         * @implements IState
                         * @constructor
                         * @param {anytype.Event.Block.Set.File.IState=} [properties] Properties to set
                         */
                        function State(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * State value.
                         * @member {anytype.model.Block.Content.File.State} value
                         * @memberof anytype.Event.Block.Set.File.State
                         * @instance
                         */
                        State.prototype.value = 0;

                        /**
                         * Creates a new State instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.File.State
                         * @static
                         * @param {anytype.Event.Block.Set.File.IState=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.File.State} State instance
                         */
                        State.create = function create(properties) {
                            return new State(properties);
                        };

                        /**
                         * Encodes the specified State message. Does not implicitly {@link anytype.Event.Block.Set.File.State.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.File.State
                         * @static
                         * @param {anytype.Event.Block.Set.File.IState} message State message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        State.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified State message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.File.State.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.File.State
                         * @static
                         * @param {anytype.Event.Block.Set.File.IState} message State message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        State.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a State message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.File.State
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.File.State} State
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        State.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.File.State();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.int32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a State message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.File.State
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.File.State} State
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        State.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a State message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.File.State
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        State.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                switch (message.value) {
                                default:
                                    return "value: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a State message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.File.State
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.File.State} State
                         */
                        State.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.File.State)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.File.State();
                            switch (object.value) {
                            case "Empty":
                            case 0:
                                message.value = 0;
                                break;
                            case "Uploading":
                            case 1:
                                message.value = 1;
                                break;
                            case "PreviewDownloaded":
                            case 2:
                                message.value = 2;
                                break;
                            case "Downloading":
                            case 3:
                                message.value = 3;
                                break;
                            case "Done":
                            case 4:
                                message.value = 4;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a State message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.File.State
                         * @static
                         * @param {anytype.Event.Block.Set.File.State} message State
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        State.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = options.enums === String ? "Empty" : 0;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = options.enums === String ? $root.anytype.model.Block.Content.File.State[message.value] : message.value;
                            return object;
                        };

                        /**
                         * Converts this State to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.File.State
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        State.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return State;
                    })();

                    File.Type = (function() {

                        /**
                         * Properties of a Type.
                         * @memberof anytype.Event.Block.Set.File
                         * @interface IType
                         * @property {anytype.model.Block.Content.File.Type|null} [value] Type value
                         */

                        /**
                         * Constructs a new Type.
                         * @memberof anytype.Event.Block.Set.File
                         * @classdesc Represents a Type.
                         * @implements IType
                         * @constructor
                         * @param {anytype.Event.Block.Set.File.IType=} [properties] Properties to set
                         */
                        function Type(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Type value.
                         * @member {anytype.model.Block.Content.File.Type} value
                         * @memberof anytype.Event.Block.Set.File.Type
                         * @instance
                         */
                        Type.prototype.value = 0;

                        /**
                         * Creates a new Type instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.File.Type
                         * @static
                         * @param {anytype.Event.Block.Set.File.IType=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.File.Type} Type instance
                         */
                        Type.create = function create(properties) {
                            return new Type(properties);
                        };

                        /**
                         * Encodes the specified Type message. Does not implicitly {@link anytype.Event.Block.Set.File.Type.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.File.Type
                         * @static
                         * @param {anytype.Event.Block.Set.File.IType} message Type message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Type.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified Type message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.File.Type.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.File.Type
                         * @static
                         * @param {anytype.Event.Block.Set.File.IType} message Type message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Type.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Type message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.File.Type
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.File.Type} Type
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Type.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.File.Type();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.int32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Type message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.File.Type
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.File.Type} Type
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Type.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Type message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.File.Type
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Type.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                switch (message.value) {
                                default:
                                    return "value: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a Type message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.File.Type
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.File.Type} Type
                         */
                        Type.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.File.Type)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.File.Type();
                            switch (object.value) {
                            case "File":
                            case 0:
                                message.value = 0;
                                break;
                            case "Image":
                            case 1:
                                message.value = 1;
                                break;
                            case "Video":
                            case 2:
                                message.value = 2;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Type message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.File.Type
                         * @static
                         * @param {anytype.Event.Block.Set.File.Type} message Type
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Type.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = options.enums === String ? "File" : 0;
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = options.enums === String ? $root.anytype.model.Block.Content.File.Type[message.value] : message.value;
                            return object;
                        };

                        /**
                         * Converts this Type to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.File.Type
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Type.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Type;
                    })();

                    File.LocalFilePath = (function() {

                        /**
                         * Properties of a LocalFilePath.
                         * @memberof anytype.Event.Block.Set.File
                         * @interface ILocalFilePath
                         * @property {string|null} [value] LocalFilePath value
                         */

                        /**
                         * Constructs a new LocalFilePath.
                         * @memberof anytype.Event.Block.Set.File
                         * @classdesc Represents a LocalFilePath.
                         * @implements ILocalFilePath
                         * @constructor
                         * @param {anytype.Event.Block.Set.File.ILocalFilePath=} [properties] Properties to set
                         */
                        function LocalFilePath(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * LocalFilePath value.
                         * @member {string} value
                         * @memberof anytype.Event.Block.Set.File.LocalFilePath
                         * @instance
                         */
                        LocalFilePath.prototype.value = "";

                        /**
                         * Creates a new LocalFilePath instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.File.LocalFilePath
                         * @static
                         * @param {anytype.Event.Block.Set.File.ILocalFilePath=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.File.LocalFilePath} LocalFilePath instance
                         */
                        LocalFilePath.create = function create(properties) {
                            return new LocalFilePath(properties);
                        };

                        /**
                         * Encodes the specified LocalFilePath message. Does not implicitly {@link anytype.Event.Block.Set.File.LocalFilePath.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.File.LocalFilePath
                         * @static
                         * @param {anytype.Event.Block.Set.File.ILocalFilePath} message LocalFilePath message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        LocalFilePath.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified LocalFilePath message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.File.LocalFilePath.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.File.LocalFilePath
                         * @static
                         * @param {anytype.Event.Block.Set.File.ILocalFilePath} message LocalFilePath message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        LocalFilePath.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a LocalFilePath message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.File.LocalFilePath
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.File.LocalFilePath} LocalFilePath
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        LocalFilePath.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.File.LocalFilePath();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a LocalFilePath message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.File.LocalFilePath
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.File.LocalFilePath} LocalFilePath
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        LocalFilePath.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a LocalFilePath message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.File.LocalFilePath
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        LocalFilePath.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!$util.isString(message.value))
                                    return "value: string expected";
                            return null;
                        };

                        /**
                         * Creates a LocalFilePath message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.File.LocalFilePath
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.File.LocalFilePath} LocalFilePath
                         */
                        LocalFilePath.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.File.LocalFilePath)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.File.LocalFilePath();
                            if (object.value != null)
                                message.value = String(object.value);
                            return message;
                        };

                        /**
                         * Creates a plain object from a LocalFilePath message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.File.LocalFilePath
                         * @static
                         * @param {anytype.Event.Block.Set.File.LocalFilePath} message LocalFilePath
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        LocalFilePath.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = "";
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = message.value;
                            return object;
                        };

                        /**
                         * Converts this LocalFilePath to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.File.LocalFilePath
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        LocalFilePath.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return LocalFilePath;
                    })();

                    File.PreviewLocalFilePath = (function() {

                        /**
                         * Properties of a PreviewLocalFilePath.
                         * @memberof anytype.Event.Block.Set.File
                         * @interface IPreviewLocalFilePath
                         * @property {string|null} [value] PreviewLocalFilePath value
                         */

                        /**
                         * Constructs a new PreviewLocalFilePath.
                         * @memberof anytype.Event.Block.Set.File
                         * @classdesc Represents a PreviewLocalFilePath.
                         * @implements IPreviewLocalFilePath
                         * @constructor
                         * @param {anytype.Event.Block.Set.File.IPreviewLocalFilePath=} [properties] Properties to set
                         */
                        function PreviewLocalFilePath(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * PreviewLocalFilePath value.
                         * @member {string} value
                         * @memberof anytype.Event.Block.Set.File.PreviewLocalFilePath
                         * @instance
                         */
                        PreviewLocalFilePath.prototype.value = "";

                        /**
                         * Creates a new PreviewLocalFilePath instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.File.PreviewLocalFilePath
                         * @static
                         * @param {anytype.Event.Block.Set.File.IPreviewLocalFilePath=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.File.PreviewLocalFilePath} PreviewLocalFilePath instance
                         */
                        PreviewLocalFilePath.create = function create(properties) {
                            return new PreviewLocalFilePath(properties);
                        };

                        /**
                         * Encodes the specified PreviewLocalFilePath message. Does not implicitly {@link anytype.Event.Block.Set.File.PreviewLocalFilePath.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.File.PreviewLocalFilePath
                         * @static
                         * @param {anytype.Event.Block.Set.File.IPreviewLocalFilePath} message PreviewLocalFilePath message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PreviewLocalFilePath.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified PreviewLocalFilePath message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.File.PreviewLocalFilePath.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.File.PreviewLocalFilePath
                         * @static
                         * @param {anytype.Event.Block.Set.File.IPreviewLocalFilePath} message PreviewLocalFilePath message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        PreviewLocalFilePath.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a PreviewLocalFilePath message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.File.PreviewLocalFilePath
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.File.PreviewLocalFilePath} PreviewLocalFilePath
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PreviewLocalFilePath.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.File.PreviewLocalFilePath();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a PreviewLocalFilePath message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.File.PreviewLocalFilePath
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.File.PreviewLocalFilePath} PreviewLocalFilePath
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        PreviewLocalFilePath.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a PreviewLocalFilePath message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.File.PreviewLocalFilePath
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PreviewLocalFilePath.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!$util.isString(message.value))
                                    return "value: string expected";
                            return null;
                        };

                        /**
                         * Creates a PreviewLocalFilePath message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.File.PreviewLocalFilePath
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.File.PreviewLocalFilePath} PreviewLocalFilePath
                         */
                        PreviewLocalFilePath.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.File.PreviewLocalFilePath)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.File.PreviewLocalFilePath();
                            if (object.value != null)
                                message.value = String(object.value);
                            return message;
                        };

                        /**
                         * Creates a plain object from a PreviewLocalFilePath message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.File.PreviewLocalFilePath
                         * @static
                         * @param {anytype.Event.Block.Set.File.PreviewLocalFilePath} message PreviewLocalFilePath
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PreviewLocalFilePath.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = "";
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = message.value;
                            return object;
                        };

                        /**
                         * Converts this PreviewLocalFilePath to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.File.PreviewLocalFilePath
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PreviewLocalFilePath.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return PreviewLocalFilePath;
                    })();

                    return File;
                })();

                Set.Icon = (function() {

                    /**
                     * Properties of an Icon.
                     * @memberof anytype.Event.Block.Set
                     * @interface IIcon
                     * @property {string|null} [id] Icon id
                     * @property {anytype.Event.Block.Set.Icon.IName|null} [name] Icon name
                     */

                    /**
                     * Constructs a new Icon.
                     * @memberof anytype.Event.Block.Set
                     * @classdesc Represents an Icon.
                     * @implements IIcon
                     * @constructor
                     * @param {anytype.Event.Block.Set.IIcon=} [properties] Properties to set
                     */
                    function Icon(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Icon id.
                     * @member {string} id
                     * @memberof anytype.Event.Block.Set.Icon
                     * @instance
                     */
                    Icon.prototype.id = "";

                    /**
                     * Icon name.
                     * @member {anytype.Event.Block.Set.Icon.IName|null|undefined} name
                     * @memberof anytype.Event.Block.Set.Icon
                     * @instance
                     */
                    Icon.prototype.name = null;

                    /**
                     * Creates a new Icon instance using the specified properties.
                     * @function create
                     * @memberof anytype.Event.Block.Set.Icon
                     * @static
                     * @param {anytype.Event.Block.Set.IIcon=} [properties] Properties to set
                     * @returns {anytype.Event.Block.Set.Icon} Icon instance
                     */
                    Icon.create = function create(properties) {
                        return new Icon(properties);
                    };

                    /**
                     * Encodes the specified Icon message. Does not implicitly {@link anytype.Event.Block.Set.Icon.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Event.Block.Set.Icon
                     * @static
                     * @param {anytype.Event.Block.Set.IIcon} message Icon message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Icon.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.id != null && message.hasOwnProperty("id"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                        if (message.name != null && message.hasOwnProperty("name"))
                            $root.anytype.Event.Block.Set.Icon.Name.encode(message.name, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Icon message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.Icon.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Event.Block.Set.Icon
                     * @static
                     * @param {anytype.Event.Block.Set.IIcon} message Icon message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Icon.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Icon message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Event.Block.Set.Icon
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Event.Block.Set.Icon} Icon
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Icon.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.Icon();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.id = reader.string();
                                break;
                            case 2:
                                message.name = $root.anytype.Event.Block.Set.Icon.Name.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Icon message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Event.Block.Set.Icon
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Event.Block.Set.Icon} Icon
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Icon.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Icon message.
                     * @function verify
                     * @memberof anytype.Event.Block.Set.Icon
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Icon.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.name != null && message.hasOwnProperty("name")) {
                            var error = $root.anytype.Event.Block.Set.Icon.Name.verify(message.name);
                            if (error)
                                return "name." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an Icon message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Event.Block.Set.Icon
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Event.Block.Set.Icon} Icon
                     */
                    Icon.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Event.Block.Set.Icon)
                            return object;
                        var message = new $root.anytype.Event.Block.Set.Icon();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.name != null) {
                            if (typeof object.name !== "object")
                                throw TypeError(".anytype.Event.Block.Set.Icon.name: object expected");
                            message.name = $root.anytype.Event.Block.Set.Icon.Name.fromObject(object.name);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Icon message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Event.Block.Set.Icon
                     * @static
                     * @param {anytype.Event.Block.Set.Icon} message Icon
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Icon.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.name = null;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = $root.anytype.Event.Block.Set.Icon.Name.toObject(message.name, options);
                        return object;
                    };

                    /**
                     * Converts this Icon to JSON.
                     * @function toJSON
                     * @memberof anytype.Event.Block.Set.Icon
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Icon.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Icon.Name = (function() {

                        /**
                         * Properties of a Name.
                         * @memberof anytype.Event.Block.Set.Icon
                         * @interface IName
                         * @property {string|null} [value] Name value
                         */

                        /**
                         * Constructs a new Name.
                         * @memberof anytype.Event.Block.Set.Icon
                         * @classdesc Represents a Name.
                         * @implements IName
                         * @constructor
                         * @param {anytype.Event.Block.Set.Icon.IName=} [properties] Properties to set
                         */
                        function Name(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Name value.
                         * @member {string} value
                         * @memberof anytype.Event.Block.Set.Icon.Name
                         * @instance
                         */
                        Name.prototype.value = "";

                        /**
                         * Creates a new Name instance using the specified properties.
                         * @function create
                         * @memberof anytype.Event.Block.Set.Icon.Name
                         * @static
                         * @param {anytype.Event.Block.Set.Icon.IName=} [properties] Properties to set
                         * @returns {anytype.Event.Block.Set.Icon.Name} Name instance
                         */
                        Name.create = function create(properties) {
                            return new Name(properties);
                        };

                        /**
                         * Encodes the specified Name message. Does not implicitly {@link anytype.Event.Block.Set.Icon.Name.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.Event.Block.Set.Icon.Name
                         * @static
                         * @param {anytype.Event.Block.Set.Icon.IName} message Name message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Name.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.value != null && message.hasOwnProperty("value"))
                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.value);
                            return writer;
                        };

                        /**
                         * Encodes the specified Name message, length delimited. Does not implicitly {@link anytype.Event.Block.Set.Icon.Name.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.Event.Block.Set.Icon.Name
                         * @static
                         * @param {anytype.Event.Block.Set.Icon.IName} message Name message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Name.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Name message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.Event.Block.Set.Icon.Name
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.Event.Block.Set.Icon.Name} Name
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Name.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Block.Set.Icon.Name();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Name message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.Event.Block.Set.Icon.Name
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.Event.Block.Set.Icon.Name} Name
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Name.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Name message.
                         * @function verify
                         * @memberof anytype.Event.Block.Set.Icon.Name
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Name.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.value != null && message.hasOwnProperty("value"))
                                if (!$util.isString(message.value))
                                    return "value: string expected";
                            return null;
                        };

                        /**
                         * Creates a Name message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.Event.Block.Set.Icon.Name
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.Event.Block.Set.Icon.Name} Name
                         */
                        Name.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.Event.Block.Set.Icon.Name)
                                return object;
                            var message = new $root.anytype.Event.Block.Set.Icon.Name();
                            if (object.value != null)
                                message.value = String(object.value);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Name message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.Event.Block.Set.Icon.Name
                         * @static
                         * @param {anytype.Event.Block.Set.Icon.Name} message Name
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Name.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.value = "";
                            if (message.value != null && message.hasOwnProperty("value"))
                                object.value = message.value;
                            return object;
                        };

                        /**
                         * Converts this Name to JSON.
                         * @function toJSON
                         * @memberof anytype.Event.Block.Set.Icon.Name
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Name.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Name;
                    })();

                    return Icon;
                })();

                return Set;
            })();

            return Block;
        })();

        Event.User = (function() {

            /**
             * Properties of a User.
             * @memberof anytype.Event
             * @interface IUser
             */

            /**
             * Constructs a new User.
             * @memberof anytype.Event
             * @classdesc Represents a User.
             * @implements IUser
             * @constructor
             * @param {anytype.Event.IUser=} [properties] Properties to set
             */
            function User(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new User instance using the specified properties.
             * @function create
             * @memberof anytype.Event.User
             * @static
             * @param {anytype.Event.IUser=} [properties] Properties to set
             * @returns {anytype.Event.User} User instance
             */
            User.create = function create(properties) {
                return new User(properties);
            };

            /**
             * Encodes the specified User message. Does not implicitly {@link anytype.Event.User.verify|verify} messages.
             * @function encode
             * @memberof anytype.Event.User
             * @static
             * @param {anytype.Event.IUser} message User message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            User.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified User message, length delimited. Does not implicitly {@link anytype.Event.User.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Event.User
             * @static
             * @param {anytype.Event.IUser} message User message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            User.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a User message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Event.User
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Event.User} User
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            User.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.User();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a User message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Event.User
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Event.User} User
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            User.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a User message.
             * @function verify
             * @memberof anytype.Event.User
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            User.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a User message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Event.User
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Event.User} User
             */
            User.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Event.User)
                    return object;
                return new $root.anytype.Event.User();
            };

            /**
             * Creates a plain object from a User message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Event.User
             * @static
             * @param {anytype.Event.User} message User
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            User.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this User to JSON.
             * @function toJSON
             * @memberof anytype.Event.User
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            User.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            User.Block = (function() {

                /**
                 * Properties of a Block.
                 * @memberof anytype.Event.User
                 * @interface IBlock
                 */

                /**
                 * Constructs a new Block.
                 * @memberof anytype.Event.User
                 * @classdesc Represents a Block.
                 * @implements IBlock
                 * @constructor
                 * @param {anytype.Event.User.IBlock=} [properties] Properties to set
                 */
                function Block(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Block instance using the specified properties.
                 * @function create
                 * @memberof anytype.Event.User.Block
                 * @static
                 * @param {anytype.Event.User.IBlock=} [properties] Properties to set
                 * @returns {anytype.Event.User.Block} Block instance
                 */
                Block.create = function create(properties) {
                    return new Block(properties);
                };

                /**
                 * Encodes the specified Block message. Does not implicitly {@link anytype.Event.User.Block.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.Event.User.Block
                 * @static
                 * @param {anytype.Event.User.IBlock} message Block message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Block.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Block message, length delimited. Does not implicitly {@link anytype.Event.User.Block.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.Event.User.Block
                 * @static
                 * @param {anytype.Event.User.IBlock} message Block message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Block.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Block message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.Event.User.Block
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.Event.User.Block} Block
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Block.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.User.Block();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Block message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.Event.User.Block
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.Event.User.Block} Block
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Block.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Block message.
                 * @function verify
                 * @memberof anytype.Event.User.Block
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Block.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Block message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.Event.User.Block
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.Event.User.Block} Block
                 */
                Block.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.Event.User.Block)
                        return object;
                    return new $root.anytype.Event.User.Block();
                };

                /**
                 * Creates a plain object from a Block message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.Event.User.Block
                 * @static
                 * @param {anytype.Event.User.Block} message Block
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Block.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Block to JSON.
                 * @function toJSON
                 * @memberof anytype.Event.User.Block
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Block.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Block.Join = (function() {

                    /**
                     * Properties of a Join.
                     * @memberof anytype.Event.User.Block
                     * @interface IJoin
                     * @property {anytype.Event.IAccount|null} [account] Join account
                     */

                    /**
                     * Constructs a new Join.
                     * @memberof anytype.Event.User.Block
                     * @classdesc Middleware to front end event message, that will be sent in this scenario:
                     * Precondition: user A opened a block
                     * 1. User B opens the same block
                     * 2. User A receives a message about p.1
                     * @implements IJoin
                     * @constructor
                     * @param {anytype.Event.User.Block.IJoin=} [properties] Properties to set
                     */
                    function Join(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Join account.
                     * @member {anytype.Event.IAccount|null|undefined} account
                     * @memberof anytype.Event.User.Block.Join
                     * @instance
                     */
                    Join.prototype.account = null;

                    /**
                     * Creates a new Join instance using the specified properties.
                     * @function create
                     * @memberof anytype.Event.User.Block.Join
                     * @static
                     * @param {anytype.Event.User.Block.IJoin=} [properties] Properties to set
                     * @returns {anytype.Event.User.Block.Join} Join instance
                     */
                    Join.create = function create(properties) {
                        return new Join(properties);
                    };

                    /**
                     * Encodes the specified Join message. Does not implicitly {@link anytype.Event.User.Block.Join.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Event.User.Block.Join
                     * @static
                     * @param {anytype.Event.User.Block.IJoin} message Join message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Join.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.account != null && message.hasOwnProperty("account"))
                            $root.anytype.Event.Account.encode(message.account, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Join message, length delimited. Does not implicitly {@link anytype.Event.User.Block.Join.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Event.User.Block.Join
                     * @static
                     * @param {anytype.Event.User.Block.IJoin} message Join message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Join.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Join message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Event.User.Block.Join
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Event.User.Block.Join} Join
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Join.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.User.Block.Join();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.account = $root.anytype.Event.Account.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Join message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Event.User.Block.Join
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Event.User.Block.Join} Join
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Join.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Join message.
                     * @function verify
                     * @memberof anytype.Event.User.Block.Join
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Join.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.account != null && message.hasOwnProperty("account")) {
                            var error = $root.anytype.Event.Account.verify(message.account);
                            if (error)
                                return "account." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Join message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Event.User.Block.Join
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Event.User.Block.Join} Join
                     */
                    Join.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Event.User.Block.Join)
                            return object;
                        var message = new $root.anytype.Event.User.Block.Join();
                        if (object.account != null) {
                            if (typeof object.account !== "object")
                                throw TypeError(".anytype.Event.User.Block.Join.account: object expected");
                            message.account = $root.anytype.Event.Account.fromObject(object.account);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Join message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Event.User.Block.Join
                     * @static
                     * @param {anytype.Event.User.Block.Join} message Join
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Join.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.account = null;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = $root.anytype.Event.Account.toObject(message.account, options);
                        return object;
                    };

                    /**
                     * Converts this Join to JSON.
                     * @function toJSON
                     * @memberof anytype.Event.User.Block.Join
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Join.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Join;
                })();

                Block.Left = (function() {

                    /**
                     * Properties of a Left.
                     * @memberof anytype.Event.User.Block
                     * @interface ILeft
                     * @property {anytype.Event.IAccount|null} [account] Left account
                     */

                    /**
                     * Constructs a new Left.
                     * @memberof anytype.Event.User.Block
                     * @classdesc Middleware to front end event message, that will be sent in this scenario:
                     * Precondition: user A and user B opened the same block
                     * 1. User B closes the block
                     * 2. User A receives a message about p.1
                     * @implements ILeft
                     * @constructor
                     * @param {anytype.Event.User.Block.ILeft=} [properties] Properties to set
                     */
                    function Left(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Left account.
                     * @member {anytype.Event.IAccount|null|undefined} account
                     * @memberof anytype.Event.User.Block.Left
                     * @instance
                     */
                    Left.prototype.account = null;

                    /**
                     * Creates a new Left instance using the specified properties.
                     * @function create
                     * @memberof anytype.Event.User.Block.Left
                     * @static
                     * @param {anytype.Event.User.Block.ILeft=} [properties] Properties to set
                     * @returns {anytype.Event.User.Block.Left} Left instance
                     */
                    Left.create = function create(properties) {
                        return new Left(properties);
                    };

                    /**
                     * Encodes the specified Left message. Does not implicitly {@link anytype.Event.User.Block.Left.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Event.User.Block.Left
                     * @static
                     * @param {anytype.Event.User.Block.ILeft} message Left message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Left.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.account != null && message.hasOwnProperty("account"))
                            $root.anytype.Event.Account.encode(message.account, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified Left message, length delimited. Does not implicitly {@link anytype.Event.User.Block.Left.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Event.User.Block.Left
                     * @static
                     * @param {anytype.Event.User.Block.ILeft} message Left message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Left.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Left message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Event.User.Block.Left
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Event.User.Block.Left} Left
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Left.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.User.Block.Left();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.account = $root.anytype.Event.Account.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Left message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Event.User.Block.Left
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Event.User.Block.Left} Left
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Left.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Left message.
                     * @function verify
                     * @memberof anytype.Event.User.Block.Left
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Left.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.account != null && message.hasOwnProperty("account")) {
                            var error = $root.anytype.Event.Account.verify(message.account);
                            if (error)
                                return "account." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Left message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Event.User.Block.Left
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Event.User.Block.Left} Left
                     */
                    Left.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Event.User.Block.Left)
                            return object;
                        var message = new $root.anytype.Event.User.Block.Left();
                        if (object.account != null) {
                            if (typeof object.account !== "object")
                                throw TypeError(".anytype.Event.User.Block.Left.account: object expected");
                            message.account = $root.anytype.Event.Account.fromObject(object.account);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Left message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Event.User.Block.Left
                     * @static
                     * @param {anytype.Event.User.Block.Left} message Left
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Left.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.account = null;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = $root.anytype.Event.Account.toObject(message.account, options);
                        return object;
                    };

                    /**
                     * Converts this Left to JSON.
                     * @function toJSON
                     * @memberof anytype.Event.User.Block.Left
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Left.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Left;
                })();

                Block.TextRange = (function() {

                    /**
                     * Properties of a TextRange.
                     * @memberof anytype.Event.User.Block
                     * @interface ITextRange
                     * @property {anytype.Event.IAccount|null} [account] TextRange account
                     * @property {string|null} [blockId] TextRange blockId
                     * @property {anytype.model.IRange|null} [range] TextRange range
                     */

                    /**
                     * Constructs a new TextRange.
                     * @memberof anytype.Event.User.Block
                     * @classdesc Middleware to front end event message, that will be sent in this scenario:
                     * Precondition: user A and user B opened the same block
                     * 1. User B sets cursor or selects a text region into a text block
                     * 2. User A receives a message about p.1
                     * @implements ITextRange
                     * @constructor
                     * @param {anytype.Event.User.Block.ITextRange=} [properties] Properties to set
                     */
                    function TextRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TextRange account.
                     * @member {anytype.Event.IAccount|null|undefined} account
                     * @memberof anytype.Event.User.Block.TextRange
                     * @instance
                     */
                    TextRange.prototype.account = null;

                    /**
                     * TextRange blockId.
                     * @member {string} blockId
                     * @memberof anytype.Event.User.Block.TextRange
                     * @instance
                     */
                    TextRange.prototype.blockId = "";

                    /**
                     * TextRange range.
                     * @member {anytype.model.IRange|null|undefined} range
                     * @memberof anytype.Event.User.Block.TextRange
                     * @instance
                     */
                    TextRange.prototype.range = null;

                    /**
                     * Creates a new TextRange instance using the specified properties.
                     * @function create
                     * @memberof anytype.Event.User.Block.TextRange
                     * @static
                     * @param {anytype.Event.User.Block.ITextRange=} [properties] Properties to set
                     * @returns {anytype.Event.User.Block.TextRange} TextRange instance
                     */
                    TextRange.create = function create(properties) {
                        return new TextRange(properties);
                    };

                    /**
                     * Encodes the specified TextRange message. Does not implicitly {@link anytype.Event.User.Block.TextRange.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Event.User.Block.TextRange
                     * @static
                     * @param {anytype.Event.User.Block.ITextRange} message TextRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TextRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.account != null && message.hasOwnProperty("account"))
                            $root.anytype.Event.Account.encode(message.account, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockId);
                        if (message.range != null && message.hasOwnProperty("range"))
                            $root.anytype.model.Range.encode(message.range, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        return writer;
                    };

                    /**
                     * Encodes the specified TextRange message, length delimited. Does not implicitly {@link anytype.Event.User.Block.TextRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Event.User.Block.TextRange
                     * @static
                     * @param {anytype.Event.User.Block.ITextRange} message TextRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TextRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a TextRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Event.User.Block.TextRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Event.User.Block.TextRange} TextRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TextRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.User.Block.TextRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.account = $root.anytype.Event.Account.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.blockId = reader.string();
                                break;
                            case 3:
                                message.range = $root.anytype.model.Range.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a TextRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Event.User.Block.TextRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Event.User.Block.TextRange} TextRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TextRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a TextRange message.
                     * @function verify
                     * @memberof anytype.Event.User.Block.TextRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TextRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.account != null && message.hasOwnProperty("account")) {
                            var error = $root.anytype.Event.Account.verify(message.account);
                            if (error)
                                return "account." + error;
                        }
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            if (!$util.isString(message.blockId))
                                return "blockId: string expected";
                        if (message.range != null && message.hasOwnProperty("range")) {
                            var error = $root.anytype.model.Range.verify(message.range);
                            if (error)
                                return "range." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a TextRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Event.User.Block.TextRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Event.User.Block.TextRange} TextRange
                     */
                    TextRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Event.User.Block.TextRange)
                            return object;
                        var message = new $root.anytype.Event.User.Block.TextRange();
                        if (object.account != null) {
                            if (typeof object.account !== "object")
                                throw TypeError(".anytype.Event.User.Block.TextRange.account: object expected");
                            message.account = $root.anytype.Event.Account.fromObject(object.account);
                        }
                        if (object.blockId != null)
                            message.blockId = String(object.blockId);
                        if (object.range != null) {
                            if (typeof object.range !== "object")
                                throw TypeError(".anytype.Event.User.Block.TextRange.range: object expected");
                            message.range = $root.anytype.model.Range.fromObject(object.range);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TextRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Event.User.Block.TextRange
                     * @static
                     * @param {anytype.Event.User.Block.TextRange} message TextRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TextRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.account = null;
                            object.blockId = "";
                            object.range = null;
                        }
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = $root.anytype.Event.Account.toObject(message.account, options);
                        if (message.blockId != null && message.hasOwnProperty("blockId"))
                            object.blockId = message.blockId;
                        if (message.range != null && message.hasOwnProperty("range"))
                            object.range = $root.anytype.model.Range.toObject(message.range, options);
                        return object;
                    };

                    /**
                     * Converts this TextRange to JSON.
                     * @function toJSON
                     * @memberof anytype.Event.User.Block.TextRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TextRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return TextRange;
                })();

                Block.SelectRange = (function() {

                    /**
                     * Properties of a SelectRange.
                     * @memberof anytype.Event.User.Block
                     * @interface ISelectRange
                     * @property {anytype.Event.IAccount|null} [account] SelectRange account
                     * @property {Array.<string>|null} [blockIdsArray] SelectRange blockIdsArray
                     */

                    /**
                     * Constructs a new SelectRange.
                     * @memberof anytype.Event.User.Block
                     * @classdesc Middleware to front end event message, that will be sent in this scenario:
                     * Precondition: user A and user B opened the same block
                     * 1. User B selects some inner blocks
                     * 2. User A receives a message about p.1
                     * @implements ISelectRange
                     * @constructor
                     * @param {anytype.Event.User.Block.ISelectRange=} [properties] Properties to set
                     */
                    function SelectRange(properties) {
                        this.blockIdsArray = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SelectRange account.
                     * @member {anytype.Event.IAccount|null|undefined} account
                     * @memberof anytype.Event.User.Block.SelectRange
                     * @instance
                     */
                    SelectRange.prototype.account = null;

                    /**
                     * SelectRange blockIdsArray.
                     * @member {Array.<string>} blockIdsArray
                     * @memberof anytype.Event.User.Block.SelectRange
                     * @instance
                     */
                    SelectRange.prototype.blockIdsArray = $util.emptyArray;

                    /**
                     * Creates a new SelectRange instance using the specified properties.
                     * @function create
                     * @memberof anytype.Event.User.Block.SelectRange
                     * @static
                     * @param {anytype.Event.User.Block.ISelectRange=} [properties] Properties to set
                     * @returns {anytype.Event.User.Block.SelectRange} SelectRange instance
                     */
                    SelectRange.create = function create(properties) {
                        return new SelectRange(properties);
                    };

                    /**
                     * Encodes the specified SelectRange message. Does not implicitly {@link anytype.Event.User.Block.SelectRange.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.Event.User.Block.SelectRange
                     * @static
                     * @param {anytype.Event.User.Block.ISelectRange} message SelectRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SelectRange.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.account != null && message.hasOwnProperty("account"))
                            $root.anytype.Event.Account.encode(message.account, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                        if (message.blockIdsArray != null && message.blockIdsArray.length)
                            for (var i = 0; i < message.blockIdsArray.length; ++i)
                                writer.uint32(/* id 2, wireType 2 =*/18).string(message.blockIdsArray[i]);
                        return writer;
                    };

                    /**
                     * Encodes the specified SelectRange message, length delimited. Does not implicitly {@link anytype.Event.User.Block.SelectRange.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.Event.User.Block.SelectRange
                     * @static
                     * @param {anytype.Event.User.Block.ISelectRange} message SelectRange message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    SelectRange.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a SelectRange message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.Event.User.Block.SelectRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.Event.User.Block.SelectRange} SelectRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SelectRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.User.Block.SelectRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.account = $root.anytype.Event.Account.decode(reader, reader.uint32());
                                break;
                            case 2:
                                if (!(message.blockIdsArray && message.blockIdsArray.length))
                                    message.blockIdsArray = [];
                                message.blockIdsArray.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a SelectRange message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.Event.User.Block.SelectRange
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.Event.User.Block.SelectRange} SelectRange
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    SelectRange.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a SelectRange message.
                     * @function verify
                     * @memberof anytype.Event.User.Block.SelectRange
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SelectRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.account != null && message.hasOwnProperty("account")) {
                            var error = $root.anytype.Event.Account.verify(message.account);
                            if (error)
                                return "account." + error;
                        }
                        if (message.blockIdsArray != null && message.hasOwnProperty("blockIdsArray")) {
                            if (!Array.isArray(message.blockIdsArray))
                                return "blockIdsArray: array expected";
                            for (var i = 0; i < message.blockIdsArray.length; ++i)
                                if (!$util.isString(message.blockIdsArray[i]))
                                    return "blockIdsArray: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a SelectRange message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.Event.User.Block.SelectRange
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.Event.User.Block.SelectRange} SelectRange
                     */
                    SelectRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.Event.User.Block.SelectRange)
                            return object;
                        var message = new $root.anytype.Event.User.Block.SelectRange();
                        if (object.account != null) {
                            if (typeof object.account !== "object")
                                throw TypeError(".anytype.Event.User.Block.SelectRange.account: object expected");
                            message.account = $root.anytype.Event.Account.fromObject(object.account);
                        }
                        if (object.blockIdsArray) {
                            if (!Array.isArray(object.blockIdsArray))
                                throw TypeError(".anytype.Event.User.Block.SelectRange.blockIdsArray: array expected");
                            message.blockIdsArray = [];
                            for (var i = 0; i < object.blockIdsArray.length; ++i)
                                message.blockIdsArray[i] = String(object.blockIdsArray[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a SelectRange message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.Event.User.Block.SelectRange
                     * @static
                     * @param {anytype.Event.User.Block.SelectRange} message SelectRange
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SelectRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.blockIdsArray = [];
                        if (options.defaults)
                            object.account = null;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = $root.anytype.Event.Account.toObject(message.account, options);
                        if (message.blockIdsArray && message.blockIdsArray.length) {
                            object.blockIdsArray = [];
                            for (var j = 0; j < message.blockIdsArray.length; ++j)
                                object.blockIdsArray[j] = message.blockIdsArray[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this SelectRange to JSON.
                     * @function toJSON
                     * @memberof anytype.Event.User.Block.SelectRange
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SelectRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SelectRange;
                })();

                return Block;
            })();

            return User;
        })();

        Event.Ping = (function() {

            /**
             * Properties of a Ping.
             * @memberof anytype.Event
             * @interface IPing
             * @property {number|null} [index] Ping index
             */

            /**
             * Constructs a new Ping.
             * @memberof anytype.Event
             * @classdesc Represents a Ping.
             * @implements IPing
             * @constructor
             * @param {anytype.Event.IPing=} [properties] Properties to set
             */
            function Ping(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Ping index.
             * @member {number} index
             * @memberof anytype.Event.Ping
             * @instance
             */
            Ping.prototype.index = 0;

            /**
             * Creates a new Ping instance using the specified properties.
             * @function create
             * @memberof anytype.Event.Ping
             * @static
             * @param {anytype.Event.IPing=} [properties] Properties to set
             * @returns {anytype.Event.Ping} Ping instance
             */
            Ping.create = function create(properties) {
                return new Ping(properties);
            };

            /**
             * Encodes the specified Ping message. Does not implicitly {@link anytype.Event.Ping.verify|verify} messages.
             * @function encode
             * @memberof anytype.Event.Ping
             * @static
             * @param {anytype.Event.IPing} message Ping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ping.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && message.hasOwnProperty("index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                return writer;
            };

            /**
             * Encodes the specified Ping message, length delimited. Does not implicitly {@link anytype.Event.Ping.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.Event.Ping
             * @static
             * @param {anytype.Event.IPing} message Ping message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ping.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Ping message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.Event.Ping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.Event.Ping} Ping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ping.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.Event.Ping();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.index = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Ping message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.Event.Ping
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.Event.Ping} Ping
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ping.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Ping message.
             * @function verify
             * @memberof anytype.Event.Ping
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Ping.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                return null;
            };

            /**
             * Creates a Ping message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.Event.Ping
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.Event.Ping} Ping
             */
            Ping.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.Event.Ping)
                    return object;
                var message = new $root.anytype.Event.Ping();
                if (object.index != null)
                    message.index = object.index | 0;
                return message;
            };

            /**
             * Creates a plain object from a Ping message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.Event.Ping
             * @static
             * @param {anytype.Event.Ping} message Ping
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Ping.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.index = 0;
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                return object;
            };

            /**
             * Converts this Ping to JSON.
             * @function toJSON
             * @memberof anytype.Event.Ping
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Ping.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Ping;
        })();

        return Event;
    })();

    anytype.ClientCommands = (function() {

        /**
         * Constructs a new ClientCommands service.
         * @memberof anytype
         * @classdesc Represents a ClientCommands
         * @extends $protobuf.rpc.Service
         * @constructor
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         */
        function ClientCommands(rpcImpl, requestDelimited, responseDelimited) {
            $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
        }

        (ClientCommands.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ClientCommands;

        /**
         * Creates new ClientCommands service using the specified rpc implementation.
         * @function create
         * @memberof anytype.ClientCommands
         * @static
         * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
         * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
         * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
         * @returns {ClientCommands} RPC service. Useful where requests and/or responses are streamed.
         */
        ClientCommands.create = function create(rpcImpl, requestDelimited, responseDelimited) {
            return new this(rpcImpl, requestDelimited, responseDelimited);
        };

        /**
         * Callback as used by {@link anytype.ClientCommands#walletCreate}.
         * @memberof anytype.ClientCommands
         * @typedef WalletCreateCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Wallet.Create.Response} [response] Response
         */

        /**
         * Calls WalletCreate.
         * @function walletCreate
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Wallet.Create.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.WalletCreateCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.walletCreate = function walletCreate(request, callback) {
            return this.rpcCall(walletCreate, $root.anytype.Rpc.Wallet.Create.Request, $root.anytype.Rpc.Wallet.Create.Response, request, callback);
        }, "name", { value: "WalletCreate" });

        /**
         * Calls WalletCreate.
         * @function walletCreate
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Wallet.Create.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Wallet.Create.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#walletRecover}.
         * @memberof anytype.ClientCommands
         * @typedef WalletRecoverCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Wallet.Recover.Response} [response] Response
         */

        /**
         * Calls WalletRecover.
         * @function walletRecover
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Wallet.Recover.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.WalletRecoverCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.walletRecover = function walletRecover(request, callback) {
            return this.rpcCall(walletRecover, $root.anytype.Rpc.Wallet.Recover.Request, $root.anytype.Rpc.Wallet.Recover.Response, request, callback);
        }, "name", { value: "WalletRecover" });

        /**
         * Calls WalletRecover.
         * @function walletRecover
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Wallet.Recover.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Wallet.Recover.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#accountRecover}.
         * @memberof anytype.ClientCommands
         * @typedef AccountRecoverCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Account.Recover.Response} [response] Response
         */

        /**
         * Calls AccountRecover.
         * @function accountRecover
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Account.Recover.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.AccountRecoverCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.accountRecover = function accountRecover(request, callback) {
            return this.rpcCall(accountRecover, $root.anytype.Rpc.Account.Recover.Request, $root.anytype.Rpc.Account.Recover.Response, request, callback);
        }, "name", { value: "AccountRecover" });

        /**
         * Calls AccountRecover.
         * @function accountRecover
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Account.Recover.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Account.Recover.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#accountCreate}.
         * @memberof anytype.ClientCommands
         * @typedef AccountCreateCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Account.Create.Response} [response] Response
         */

        /**
         * Calls AccountCreate.
         * @function accountCreate
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Account.Create.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.AccountCreateCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.accountCreate = function accountCreate(request, callback) {
            return this.rpcCall(accountCreate, $root.anytype.Rpc.Account.Create.Request, $root.anytype.Rpc.Account.Create.Response, request, callback);
        }, "name", { value: "AccountCreate" });

        /**
         * Calls AccountCreate.
         * @function accountCreate
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Account.Create.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Account.Create.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#accountSelect}.
         * @memberof anytype.ClientCommands
         * @typedef AccountSelectCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Account.Select.Response} [response] Response
         */

        /**
         * Calls AccountSelect.
         * @function accountSelect
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Account.Select.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.AccountSelectCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.accountSelect = function accountSelect(request, callback) {
            return this.rpcCall(accountSelect, $root.anytype.Rpc.Account.Select.Request, $root.anytype.Rpc.Account.Select.Response, request, callback);
        }, "name", { value: "AccountSelect" });

        /**
         * Calls AccountSelect.
         * @function accountSelect
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Account.Select.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Account.Select.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#imageGetBlob}.
         * @memberof anytype.ClientCommands
         * @typedef ImageGetBlobCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Ipfs.Image.Get.Blob.Response} [response] Response
         */

        /**
         * Calls ImageGetBlob.
         * @function imageGetBlob
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Ipfs.Image.Get.Blob.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.ImageGetBlobCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.imageGetBlob = function imageGetBlob(request, callback) {
            return this.rpcCall(imageGetBlob, $root.anytype.Rpc.Ipfs.Image.Get.Blob.Request, $root.anytype.Rpc.Ipfs.Image.Get.Blob.Response, request, callback);
        }, "name", { value: "ImageGetBlob" });

        /**
         * Calls ImageGetBlob.
         * @function imageGetBlob
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Ipfs.Image.Get.Blob.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Ipfs.Image.Get.Blob.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#versionGet}.
         * @memberof anytype.ClientCommands
         * @typedef VersionGetCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Version.Get.Response} [response] Response
         */

        /**
         * Calls VersionGet.
         * @function versionGet
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Version.Get.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.VersionGetCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.versionGet = function versionGet(request, callback) {
            return this.rpcCall(versionGet, $root.anytype.Rpc.Version.Get.Request, $root.anytype.Rpc.Version.Get.Response, request, callback);
        }, "name", { value: "VersionGet" });

        /**
         * Calls VersionGet.
         * @function versionGet
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Version.Get.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Version.Get.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#logSend}.
         * @memberof anytype.ClientCommands
         * @typedef LogSendCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Log.Send.Response} [response] Response
         */

        /**
         * Calls LogSend.
         * @function logSend
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Log.Send.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.LogSendCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.logSend = function logSend(request, callback) {
            return this.rpcCall(logSend, $root.anytype.Rpc.Log.Send.Request, $root.anytype.Rpc.Log.Send.Response, request, callback);
        }, "name", { value: "LogSend" });

        /**
         * Calls LogSend.
         * @function logSend
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Log.Send.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Log.Send.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#configGet}.
         * @memberof anytype.ClientCommands
         * @typedef ConfigGetCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Config.Get.Response} [response] Response
         */

        /**
         * Calls ConfigGet.
         * @function configGet
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Config.Get.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.ConfigGetCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.configGet = function configGet(request, callback) {
            return this.rpcCall(configGet, $root.anytype.Rpc.Config.Get.Request, $root.anytype.Rpc.Config.Get.Response, request, callback);
        }, "name", { value: "ConfigGet" });

        /**
         * Calls ConfigGet.
         * @function configGet
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Config.Get.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Config.Get.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#externalDropFiles}.
         * @memberof anytype.ClientCommands
         * @typedef ExternalDropFilesCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.ExternalDrop.Files.Response} [response] Response
         */

        /**
         * Calls ExternalDropFiles.
         * @function externalDropFiles
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.ExternalDrop.Files.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.ExternalDropFilesCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.externalDropFiles = function externalDropFiles(request, callback) {
            return this.rpcCall(externalDropFiles, $root.anytype.Rpc.ExternalDrop.Files.Request, $root.anytype.Rpc.ExternalDrop.Files.Response, request, callback);
        }, "name", { value: "ExternalDropFiles" });

        /**
         * Calls ExternalDropFiles.
         * @function externalDropFiles
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.ExternalDrop.Files.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.ExternalDrop.Files.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#externalDropContent}.
         * @memberof anytype.ClientCommands
         * @typedef ExternalDropContentCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.ExternalDrop.Content.Response} [response] Response
         */

        /**
         * Calls ExternalDropContent.
         * @function externalDropContent
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.ExternalDrop.Content.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.ExternalDropContentCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.externalDropContent = function externalDropContent(request, callback) {
            return this.rpcCall(externalDropContent, $root.anytype.Rpc.ExternalDrop.Content.Request, $root.anytype.Rpc.ExternalDrop.Content.Response, request, callback);
        }, "name", { value: "ExternalDropContent" });

        /**
         * Calls ExternalDropContent.
         * @function externalDropContent
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.ExternalDrop.Content.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.ExternalDrop.Content.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockUpload}.
         * @memberof anytype.ClientCommands
         * @typedef BlockUploadCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Upload.Response} [response] Response
         */

        /**
         * Calls BlockUpload.
         * @function blockUpload
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Upload.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockUploadCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockUpload = function blockUpload(request, callback) {
            return this.rpcCall(blockUpload, $root.anytype.Rpc.Block.Upload.Request, $root.anytype.Rpc.Block.Upload.Response, request, callback);
        }, "name", { value: "BlockUpload" });

        /**
         * Calls BlockUpload.
         * @function blockUpload
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Upload.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Upload.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockReplace}.
         * @memberof anytype.ClientCommands
         * @typedef BlockReplaceCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Replace.Response} [response] Response
         */

        /**
         * Calls BlockReplace.
         * @function blockReplace
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Replace.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockReplaceCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockReplace = function blockReplace(request, callback) {
            return this.rpcCall(blockReplace, $root.anytype.Rpc.Block.Replace.Request, $root.anytype.Rpc.Block.Replace.Response, request, callback);
        }, "name", { value: "BlockReplace" });

        /**
         * Calls BlockReplace.
         * @function blockReplace
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Replace.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Replace.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockOpen}.
         * @memberof anytype.ClientCommands
         * @typedef BlockOpenCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Open.Response} [response] Response
         */

        /**
         * Calls BlockOpen.
         * @function blockOpen
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Open.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockOpenCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockOpen = function blockOpen(request, callback) {
            return this.rpcCall(blockOpen, $root.anytype.Rpc.Block.Open.Request, $root.anytype.Rpc.Block.Open.Response, request, callback);
        }, "name", { value: "BlockOpen" });

        /**
         * Calls BlockOpen.
         * @function blockOpen
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Open.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Open.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockCreate}.
         * @memberof anytype.ClientCommands
         * @typedef BlockCreateCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Create.Response} [response] Response
         */

        /**
         * Calls BlockCreate.
         * @function blockCreate
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Create.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockCreateCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockCreate = function blockCreate(request, callback) {
            return this.rpcCall(blockCreate, $root.anytype.Rpc.Block.Create.Request, $root.anytype.Rpc.Block.Create.Response, request, callback);
        }, "name", { value: "BlockCreate" });

        /**
         * Calls BlockCreate.
         * @function blockCreate
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Create.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Create.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockUnlink}.
         * @memberof anytype.ClientCommands
         * @typedef BlockUnlinkCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Unlink.Response} [response] Response
         */

        /**
         * Calls BlockUnlink.
         * @function blockUnlink
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Unlink.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockUnlinkCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockUnlink = function blockUnlink(request, callback) {
            return this.rpcCall(blockUnlink, $root.anytype.Rpc.Block.Unlink.Request, $root.anytype.Rpc.Block.Unlink.Response, request, callback);
        }, "name", { value: "BlockUnlink" });

        /**
         * Calls BlockUnlink.
         * @function blockUnlink
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Unlink.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Unlink.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockDuplicate}.
         * @memberof anytype.ClientCommands
         * @typedef BlockDuplicateCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Duplicate.Response} [response] Response
         */

        /**
         * Calls BlockDuplicate.
         * @function blockDuplicate
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Duplicate.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockDuplicateCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockDuplicate = function blockDuplicate(request, callback) {
            return this.rpcCall(blockDuplicate, $root.anytype.Rpc.Block.Duplicate.Request, $root.anytype.Rpc.Block.Duplicate.Response, request, callback);
        }, "name", { value: "BlockDuplicate" });

        /**
         * Calls BlockDuplicate.
         * @function blockDuplicate
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Duplicate.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Duplicate.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockClose}.
         * @memberof anytype.ClientCommands
         * @typedef BlockCloseCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Close.Response} [response] Response
         */

        /**
         * Calls BlockClose.
         * @function blockClose
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Close.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockCloseCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockClose = function blockClose(request, callback) {
            return this.rpcCall(blockClose, $root.anytype.Rpc.Block.Close.Request, $root.anytype.Rpc.Block.Close.Response, request, callback);
        }, "name", { value: "BlockClose" });

        /**
         * Calls BlockClose.
         * @function blockClose
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Close.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Close.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockDownload}.
         * @memberof anytype.ClientCommands
         * @typedef BlockDownloadCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Download.Response} [response] Response
         */

        /**
         * Calls BlockDownload.
         * @function blockDownload
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Download.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockDownloadCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockDownload = function blockDownload(request, callback) {
            return this.rpcCall(blockDownload, $root.anytype.Rpc.Block.Download.Request, $root.anytype.Rpc.Block.Download.Response, request, callback);
        }, "name", { value: "BlockDownload" });

        /**
         * Calls BlockDownload.
         * @function blockDownload
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Download.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Download.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockGetMarks}.
         * @memberof anytype.ClientCommands
         * @typedef BlockGetMarksCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Get.Marks.Response} [response] Response
         */

        /**
         * Calls BlockGetMarks.
         * @function blockGetMarks
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Get.Marks.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockGetMarksCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockGetMarks = function blockGetMarks(request, callback) {
            return this.rpcCall(blockGetMarks, $root.anytype.Rpc.Block.Get.Marks.Request, $root.anytype.Rpc.Block.Get.Marks.Response, request, callback);
        }, "name", { value: "BlockGetMarks" });

        /**
         * Calls BlockGetMarks.
         * @function blockGetMarks
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Get.Marks.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Get.Marks.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockHistoryMove}.
         * @memberof anytype.ClientCommands
         * @typedef BlockHistoryMoveCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.History.Move.Response} [response] Response
         */

        /**
         * Calls BlockHistoryMove.
         * @function blockHistoryMove
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.History.Move.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockHistoryMoveCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockHistoryMove = function blockHistoryMove(request, callback) {
            return this.rpcCall(blockHistoryMove, $root.anytype.Rpc.Block.History.Move.Request, $root.anytype.Rpc.Block.History.Move.Response, request, callback);
        }, "name", { value: "BlockHistoryMove" });

        /**
         * Calls BlockHistoryMove.
         * @function blockHistoryMove
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.History.Move.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.History.Move.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetFields}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetFieldsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.Fields.Response} [response] Response
         */

        /**
         * Calls BlockSetFields.
         * @function blockSetFields
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Fields.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetFieldsCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetFields = function blockSetFields(request, callback) {
            return this.rpcCall(blockSetFields, $root.anytype.Rpc.Block.Set.Fields.Request, $root.anytype.Rpc.Block.Set.Fields.Response, request, callback);
        }, "name", { value: "BlockSetFields" });

        /**
         * Calls BlockSetFields.
         * @function blockSetFields
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Fields.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.Fields.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetRestrictions}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetRestrictionsCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.Restrictions.Response} [response] Response
         */

        /**
         * Calls BlockSetRestrictions.
         * @function blockSetRestrictions
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Restrictions.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetRestrictionsCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetRestrictions = function blockSetRestrictions(request, callback) {
            return this.rpcCall(blockSetRestrictions, $root.anytype.Rpc.Block.Set.Restrictions.Request, $root.anytype.Rpc.Block.Set.Restrictions.Response, request, callback);
        }, "name", { value: "BlockSetRestrictions" });

        /**
         * Calls BlockSetRestrictions.
         * @function blockSetRestrictions
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Restrictions.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.Restrictions.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetIsArchived}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetIsArchivedCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.IsArchived.Response} [response] Response
         */

        /**
         * Calls BlockSetIsArchived.
         * @function blockSetIsArchived
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.IsArchived.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetIsArchivedCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetIsArchived = function blockSetIsArchived(request, callback) {
            return this.rpcCall(blockSetIsArchived, $root.anytype.Rpc.Block.Set.IsArchived.Request, $root.anytype.Rpc.Block.Set.IsArchived.Response, request, callback);
        }, "name", { value: "BlockSetIsArchived" });

        /**
         * Calls BlockSetIsArchived.
         * @function blockSetIsArchived
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.IsArchived.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.IsArchived.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockListMove}.
         * @memberof anytype.ClientCommands
         * @typedef BlockListMoveCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.BlockList.Move.Response} [response] Response
         */

        /**
         * Calls BlockListMove.
         * @function blockListMove
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.BlockList.Move.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockListMoveCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockListMove = function blockListMove(request, callback) {
            return this.rpcCall(blockListMove, $root.anytype.Rpc.BlockList.Move.Request, $root.anytype.Rpc.BlockList.Move.Response, request, callback);
        }, "name", { value: "BlockListMove" });

        /**
         * Calls BlockListMove.
         * @function blockListMove
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.BlockList.Move.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.BlockList.Move.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockListSetTextStyle}.
         * @memberof anytype.ClientCommands
         * @typedef BlockListSetTextStyleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.BlockList.Set.Text.Style.Response} [response] Response
         */

        /**
         * Calls BlockListSetTextStyle.
         * @function blockListSetTextStyle
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.BlockList.Set.Text.Style.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockListSetTextStyleCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockListSetTextStyle = function blockListSetTextStyle(request, callback) {
            return this.rpcCall(blockListSetTextStyle, $root.anytype.Rpc.BlockList.Set.Text.Style.Request, $root.anytype.Rpc.BlockList.Set.Text.Style.Response, request, callback);
        }, "name", { value: "BlockListSetTextStyle" });

        /**
         * Calls BlockListSetTextStyle.
         * @function blockListSetTextStyle
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.BlockList.Set.Text.Style.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.BlockList.Set.Text.Style.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetTextText}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetTextTextCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.Text.Text.Response} [response] Response
         */

        /**
         * Calls BlockSetTextText.
         * @function blockSetTextText
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Text.Text.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetTextTextCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetTextText = function blockSetTextText(request, callback) {
            return this.rpcCall(blockSetTextText, $root.anytype.Rpc.Block.Set.Text.Text.Request, $root.anytype.Rpc.Block.Set.Text.Text.Response, request, callback);
        }, "name", { value: "BlockSetTextText" });

        /**
         * Calls BlockSetTextText.
         * @function blockSetTextText
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Text.Text.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.Text.Text.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetTextColor}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetTextColorCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.Text.Color.Response} [response] Response
         */

        /**
         * Calls BlockSetTextColor.
         * @function blockSetTextColor
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Text.Color.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetTextColorCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetTextColor = function blockSetTextColor(request, callback) {
            return this.rpcCall(blockSetTextColor, $root.anytype.Rpc.Block.Set.Text.Color.Request, $root.anytype.Rpc.Block.Set.Text.Color.Response, request, callback);
        }, "name", { value: "BlockSetTextColor" });

        /**
         * Calls BlockSetTextColor.
         * @function blockSetTextColor
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Text.Color.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.Text.Color.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetTextBackgroundColor}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetTextBackgroundColorCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.Response} [response] Response
         */

        /**
         * Calls BlockSetTextBackgroundColor.
         * @function blockSetTextBackgroundColor
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetTextBackgroundColorCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetTextBackgroundColor = function blockSetTextBackgroundColor(request, callback) {
            return this.rpcCall(blockSetTextBackgroundColor, $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Request, $root.anytype.Rpc.Block.Set.Text.BackgroundColor.Response, request, callback);
        }, "name", { value: "BlockSetTextBackgroundColor" });

        /**
         * Calls BlockSetTextBackgroundColor.
         * @function blockSetTextBackgroundColor
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Text.BackgroundColor.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.Text.BackgroundColor.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetTextStyle}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetTextStyleCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.Text.Style.Response} [response] Response
         */

        /**
         * Calls BlockSetTextStyle.
         * @function blockSetTextStyle
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Text.Style.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetTextStyleCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetTextStyle = function blockSetTextStyle(request, callback) {
            return this.rpcCall(blockSetTextStyle, $root.anytype.Rpc.Block.Set.Text.Style.Request, $root.anytype.Rpc.Block.Set.Text.Style.Response, request, callback);
        }, "name", { value: "BlockSetTextStyle" });

        /**
         * Calls BlockSetTextStyle.
         * @function blockSetTextStyle
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Text.Style.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.Text.Style.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetTextChecked}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetTextCheckedCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.Text.Checked.Response} [response] Response
         */

        /**
         * Calls BlockSetTextChecked.
         * @function blockSetTextChecked
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Text.Checked.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetTextCheckedCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetTextChecked = function blockSetTextChecked(request, callback) {
            return this.rpcCall(blockSetTextChecked, $root.anytype.Rpc.Block.Set.Text.Checked.Request, $root.anytype.Rpc.Block.Set.Text.Checked.Response, request, callback);
        }, "name", { value: "BlockSetTextChecked" });

        /**
         * Calls BlockSetTextChecked.
         * @function blockSetTextChecked
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Text.Checked.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.Text.Checked.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSplit}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSplitCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Split.Response} [response] Response
         */

        /**
         * Calls BlockSplit.
         * @function blockSplit
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Split.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSplitCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSplit = function blockSplit(request, callback) {
            return this.rpcCall(blockSplit, $root.anytype.Rpc.Block.Split.Request, $root.anytype.Rpc.Block.Split.Response, request, callback);
        }, "name", { value: "BlockSplit" });

        /**
         * Calls BlockSplit.
         * @function blockSplit
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Split.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Split.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockMerge}.
         * @memberof anytype.ClientCommands
         * @typedef BlockMergeCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Merge.Response} [response] Response
         */

        /**
         * Calls BlockMerge.
         * @function blockMerge
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Merge.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockMergeCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockMerge = function blockMerge(request, callback) {
            return this.rpcCall(blockMerge, $root.anytype.Rpc.Block.Merge.Request, $root.anytype.Rpc.Block.Merge.Response, request, callback);
        }, "name", { value: "BlockMerge" });

        /**
         * Calls BlockMerge.
         * @function blockMerge
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Merge.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Merge.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockCopy}.
         * @memberof anytype.ClientCommands
         * @typedef BlockCopyCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Copy.Response} [response] Response
         */

        /**
         * Calls BlockCopy.
         * @function blockCopy
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Copy.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockCopyCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockCopy = function blockCopy(request, callback) {
            return this.rpcCall(blockCopy, $root.anytype.Rpc.Block.Copy.Request, $root.anytype.Rpc.Block.Copy.Response, request, callback);
        }, "name", { value: "BlockCopy" });

        /**
         * Calls BlockCopy.
         * @function blockCopy
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Copy.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Copy.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockPaste}.
         * @memberof anytype.ClientCommands
         * @typedef BlockPasteCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Paste.Response} [response] Response
         */

        /**
         * Calls BlockPaste.
         * @function blockPaste
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Paste.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockPasteCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockPaste = function blockPaste(request, callback) {
            return this.rpcCall(blockPaste, $root.anytype.Rpc.Block.Paste.Request, $root.anytype.Rpc.Block.Paste.Response, request, callback);
        }, "name", { value: "BlockPaste" });

        /**
         * Calls BlockPaste.
         * @function blockPaste
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Paste.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Paste.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetFileName}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetFileNameCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.File.Name.Response} [response] Response
         */

        /**
         * Calls BlockSetFileName.
         * @function blockSetFileName
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.File.Name.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetFileNameCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetFileName = function blockSetFileName(request, callback) {
            return this.rpcCall(blockSetFileName, $root.anytype.Rpc.Block.Set.File.Name.Request, $root.anytype.Rpc.Block.Set.File.Name.Response, request, callback);
        }, "name", { value: "BlockSetFileName" });

        /**
         * Calls BlockSetFileName.
         * @function blockSetFileName
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.File.Name.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.File.Name.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetImageName}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetImageNameCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.Image.Name.Response} [response] Response
         */

        /**
         * Calls BlockSetImageName.
         * @function blockSetImageName
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Image.Name.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetImageNameCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetImageName = function blockSetImageName(request, callback) {
            return this.rpcCall(blockSetImageName, $root.anytype.Rpc.Block.Set.Image.Name.Request, $root.anytype.Rpc.Block.Set.Image.Name.Response, request, callback);
        }, "name", { value: "BlockSetImageName" });

        /**
         * Calls BlockSetImageName.
         * @function blockSetImageName
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Image.Name.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.Image.Name.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetImageWidth}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetImageWidthCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.Image.Width.Response} [response] Response
         */

        /**
         * Calls BlockSetImageWidth.
         * @function blockSetImageWidth
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Image.Width.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetImageWidthCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetImageWidth = function blockSetImageWidth(request, callback) {
            return this.rpcCall(blockSetImageWidth, $root.anytype.Rpc.Block.Set.Image.Width.Request, $root.anytype.Rpc.Block.Set.Image.Width.Response, request, callback);
        }, "name", { value: "BlockSetImageWidth" });

        /**
         * Calls BlockSetImageWidth.
         * @function blockSetImageWidth
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Image.Width.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.Image.Width.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetVideoName}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetVideoNameCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.Video.Name.Response} [response] Response
         */

        /**
         * Calls BlockSetVideoName.
         * @function blockSetVideoName
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Video.Name.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetVideoNameCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetVideoName = function blockSetVideoName(request, callback) {
            return this.rpcCall(blockSetVideoName, $root.anytype.Rpc.Block.Set.Video.Name.Request, $root.anytype.Rpc.Block.Set.Video.Name.Response, request, callback);
        }, "name", { value: "BlockSetVideoName" });

        /**
         * Calls BlockSetVideoName.
         * @function blockSetVideoName
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Video.Name.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.Video.Name.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetVideoWidth}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetVideoWidthCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.Video.Width.Response} [response] Response
         */

        /**
         * Calls BlockSetVideoWidth.
         * @function blockSetVideoWidth
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Video.Width.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetVideoWidthCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetVideoWidth = function blockSetVideoWidth(request, callback) {
            return this.rpcCall(blockSetVideoWidth, $root.anytype.Rpc.Block.Set.Video.Width.Request, $root.anytype.Rpc.Block.Set.Video.Width.Response, request, callback);
        }, "name", { value: "BlockSetVideoWidth" });

        /**
         * Calls BlockSetVideoWidth.
         * @function blockSetVideoWidth
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Video.Width.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.Video.Width.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#blockSetIconName}.
         * @memberof anytype.ClientCommands
         * @typedef BlockSetIconNameCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Block.Set.Icon.Name.Response} [response] Response
         */

        /**
         * Calls BlockSetIconName.
         * @function blockSetIconName
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Icon.Name.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.BlockSetIconNameCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.blockSetIconName = function blockSetIconName(request, callback) {
            return this.rpcCall(blockSetIconName, $root.anytype.Rpc.Block.Set.Icon.Name.Request, $root.anytype.Rpc.Block.Set.Icon.Name.Response, request, callback);
        }, "name", { value: "BlockSetIconName" });

        /**
         * Calls BlockSetIconName.
         * @function blockSetIconName
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Block.Set.Icon.Name.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Block.Set.Icon.Name.Response>} Promise
         * @variation 2
         */

        /**
         * Callback as used by {@link anytype.ClientCommands#ping}.
         * @memberof anytype.ClientCommands
         * @typedef PingCallback
         * @type {function}
         * @param {Error|null} error Error, if any
         * @param {anytype.Rpc.Ping.Response} [response] Response
         */

        /**
         * Calls Ping.
         * @function ping
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Ping.IRequest} request Request message or plain object
         * @param {anytype.ClientCommands.PingCallback} callback Node-style callback called with the error, if any, and Response
         * @returns {undefined}
         * @variation 1
         */
        Object.defineProperty(ClientCommands.prototype.ping = function ping(request, callback) {
            return this.rpcCall(ping, $root.anytype.Rpc.Ping.Request, $root.anytype.Rpc.Ping.Response, request, callback);
        }, "name", { value: "Ping" });

        /**
         * Calls Ping.
         * @function ping
         * @memberof anytype.ClientCommands
         * @instance
         * @param {anytype.Rpc.Ping.IRequest} request Request message or plain object
         * @returns {Promise<anytype.Rpc.Ping.Response>} Promise
         * @variation 2
         */

        return ClientCommands;
    })();

    anytype.model = (function() {

        /**
         * Namespace model.
         * @memberof anytype
         * @namespace
         */
        var model = {};

        model.Block = (function() {

            /**
             * Properties of a Block.
             * @memberof anytype.model
             * @interface IBlock
             * @property {string|null} [id] Block id
             * @property {google.protobuf.IStruct|null} [fields] Block fields
             * @property {anytype.model.Block.IRestrictions|null} [restrictions] Block restrictions
             * @property {Array.<string>|null} [childrenIds] Block childrenIds
             * @property {boolean|null} [isArchived] Block isArchived
             * @property {anytype.model.Block.Content.IDashboard|null} [dashboard] Block dashboard
             * @property {anytype.model.Block.Content.IPage|null} [page] Block page
             * @property {anytype.model.Block.Content.IDataview|null} [dataview] Block dataview
             * @property {anytype.model.Block.Content.IText|null} [text] Block text
             * @property {anytype.model.Block.Content.IFile|null} [file] Block file
             * @property {anytype.model.Block.Content.ILayout|null} [layout] Block layout
             * @property {anytype.model.Block.Content.IDiv|null} [div] Block div
             * @property {anytype.model.Block.Content.IBookmark|null} [bookmark] Block bookmark
             * @property {anytype.model.Block.Content.IIcon|null} [icon] Block icon
             * @property {anytype.model.Block.Content.ILink|null} [link] Block link
             */

            /**
             * Constructs a new Block.
             * @memberof anytype.model
             * @classdesc Represents a Block.
             * @implements IBlock
             * @constructor
             * @param {anytype.model.IBlock=} [properties] Properties to set
             */
            function Block(properties) {
                this.childrenIds = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Block id.
             * @member {string} id
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.id = "";

            /**
             * Block fields.
             * @member {google.protobuf.IStruct|null|undefined} fields
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.fields = null;

            /**
             * Block restrictions.
             * @member {anytype.model.Block.IRestrictions|null|undefined} restrictions
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.restrictions = null;

            /**
             * Block childrenIds.
             * @member {Array.<string>} childrenIds
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.childrenIds = $util.emptyArray;

            /**
             * Block isArchived.
             * @member {boolean} isArchived
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.isArchived = false;

            /**
             * Block dashboard.
             * @member {anytype.model.Block.Content.IDashboard|null|undefined} dashboard
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.dashboard = null;

            /**
             * Block page.
             * @member {anytype.model.Block.Content.IPage|null|undefined} page
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.page = null;

            /**
             * Block dataview.
             * @member {anytype.model.Block.Content.IDataview|null|undefined} dataview
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.dataview = null;

            /**
             * Block text.
             * @member {anytype.model.Block.Content.IText|null|undefined} text
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.text = null;

            /**
             * Block file.
             * @member {anytype.model.Block.Content.IFile|null|undefined} file
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.file = null;

            /**
             * Block layout.
             * @member {anytype.model.Block.Content.ILayout|null|undefined} layout
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.layout = null;

            /**
             * Block div.
             * @member {anytype.model.Block.Content.IDiv|null|undefined} div
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.div = null;

            /**
             * Block bookmark.
             * @member {anytype.model.Block.Content.IBookmark|null|undefined} bookmark
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.bookmark = null;

            /**
             * Block icon.
             * @member {anytype.model.Block.Content.IIcon|null|undefined} icon
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.icon = null;

            /**
             * Block link.
             * @member {anytype.model.Block.Content.ILink|null|undefined} link
             * @memberof anytype.model.Block
             * @instance
             */
            Block.prototype.link = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Block content.
             * @member {"dashboard"|"page"|"dataview"|"text"|"file"|"layout"|"div"|"bookmark"|"icon"|"link"|undefined} content
             * @memberof anytype.model.Block
             * @instance
             */
            Object.defineProperty(Block.prototype, "content", {
                get: $util.oneOfGetter($oneOfFields = ["dashboard", "page", "dataview", "text", "file", "layout", "div", "bookmark", "icon", "link"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Block instance using the specified properties.
             * @function create
             * @memberof anytype.model.Block
             * @static
             * @param {anytype.model.IBlock=} [properties] Properties to set
             * @returns {anytype.model.Block} Block instance
             */
            Block.create = function create(properties) {
                return new Block(properties);
            };

            /**
             * Encodes the specified Block message. Does not implicitly {@link anytype.model.Block.verify|verify} messages.
             * @function encode
             * @memberof anytype.model.Block
             * @static
             * @param {anytype.model.IBlock} message Block message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Block.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.fields != null && message.hasOwnProperty("fields"))
                    $root.google.protobuf.Struct.encode(message.fields, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.restrictions != null && message.hasOwnProperty("restrictions"))
                    $root.anytype.model.Block.Restrictions.encode(message.restrictions, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.childrenIds != null && message.childrenIds.length)
                    for (var i = 0; i < message.childrenIds.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.childrenIds[i]);
                if (message.isArchived != null && message.hasOwnProperty("isArchived"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isArchived);
                if (message.dashboard != null && message.hasOwnProperty("dashboard"))
                    $root.anytype.model.Block.Content.Dashboard.encode(message.dashboard, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.page != null && message.hasOwnProperty("page"))
                    $root.anytype.model.Block.Content.Page.encode(message.page, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.dataview != null && message.hasOwnProperty("dataview"))
                    $root.anytype.model.Block.Content.Dataview.encode(message.dataview, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.text != null && message.hasOwnProperty("text"))
                    $root.anytype.model.Block.Content.Text.encode(message.text, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.file != null && message.hasOwnProperty("file"))
                    $root.anytype.model.Block.Content.File.encode(message.file, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.layout != null && message.hasOwnProperty("layout"))
                    $root.anytype.model.Block.Content.Layout.encode(message.layout, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.div != null && message.hasOwnProperty("div"))
                    $root.anytype.model.Block.Content.Div.encode(message.div, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.bookmark != null && message.hasOwnProperty("bookmark"))
                    $root.anytype.model.Block.Content.Bookmark.encode(message.bookmark, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.icon != null && message.hasOwnProperty("icon"))
                    $root.anytype.model.Block.Content.Icon.encode(message.icon, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.link != null && message.hasOwnProperty("link"))
                    $root.anytype.model.Block.Content.Link.encode(message.link, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Block message, length delimited. Does not implicitly {@link anytype.model.Block.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.model.Block
             * @static
             * @param {anytype.model.IBlock} message Block message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Block.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Block message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.model.Block
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.model.Block} Block
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Block.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.fields = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.restrictions = $root.anytype.model.Block.Restrictions.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.childrenIds && message.childrenIds.length))
                            message.childrenIds = [];
                        message.childrenIds.push(reader.string());
                        break;
                    case 5:
                        message.isArchived = reader.bool();
                        break;
                    case 11:
                        message.dashboard = $root.anytype.model.Block.Content.Dashboard.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.page = $root.anytype.model.Block.Content.Page.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.dataview = $root.anytype.model.Block.Content.Dataview.decode(reader, reader.uint32());
                        break;
                    case 14:
                        message.text = $root.anytype.model.Block.Content.Text.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.file = $root.anytype.model.Block.Content.File.decode(reader, reader.uint32());
                        break;
                    case 16:
                        message.layout = $root.anytype.model.Block.Content.Layout.decode(reader, reader.uint32());
                        break;
                    case 17:
                        message.div = $root.anytype.model.Block.Content.Div.decode(reader, reader.uint32());
                        break;
                    case 18:
                        message.bookmark = $root.anytype.model.Block.Content.Bookmark.decode(reader, reader.uint32());
                        break;
                    case 19:
                        message.icon = $root.anytype.model.Block.Content.Icon.decode(reader, reader.uint32());
                        break;
                    case 20:
                        message.link = $root.anytype.model.Block.Content.Link.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Block message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.model.Block
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.model.Block} Block
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Block.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Block message.
             * @function verify
             * @memberof anytype.model.Block
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Block.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    var error = $root.google.protobuf.Struct.verify(message.fields);
                    if (error)
                        return "fields." + error;
                }
                if (message.restrictions != null && message.hasOwnProperty("restrictions")) {
                    var error = $root.anytype.model.Block.Restrictions.verify(message.restrictions);
                    if (error)
                        return "restrictions." + error;
                }
                if (message.childrenIds != null && message.hasOwnProperty("childrenIds")) {
                    if (!Array.isArray(message.childrenIds))
                        return "childrenIds: array expected";
                    for (var i = 0; i < message.childrenIds.length; ++i)
                        if (!$util.isString(message.childrenIds[i]))
                            return "childrenIds: string[] expected";
                }
                if (message.isArchived != null && message.hasOwnProperty("isArchived"))
                    if (typeof message.isArchived !== "boolean")
                        return "isArchived: boolean expected";
                if (message.dashboard != null && message.hasOwnProperty("dashboard")) {
                    properties.content = 1;
                    {
                        var error = $root.anytype.model.Block.Content.Dashboard.verify(message.dashboard);
                        if (error)
                            return "dashboard." + error;
                    }
                }
                if (message.page != null && message.hasOwnProperty("page")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.anytype.model.Block.Content.Page.verify(message.page);
                        if (error)
                            return "page." + error;
                    }
                }
                if (message.dataview != null && message.hasOwnProperty("dataview")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.anytype.model.Block.Content.Dataview.verify(message.dataview);
                        if (error)
                            return "dataview." + error;
                    }
                }
                if (message.text != null && message.hasOwnProperty("text")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.anytype.model.Block.Content.Text.verify(message.text);
                        if (error)
                            return "text." + error;
                    }
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.anytype.model.Block.Content.File.verify(message.file);
                        if (error)
                            return "file." + error;
                    }
                }
                if (message.layout != null && message.hasOwnProperty("layout")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.anytype.model.Block.Content.Layout.verify(message.layout);
                        if (error)
                            return "layout." + error;
                    }
                }
                if (message.div != null && message.hasOwnProperty("div")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.anytype.model.Block.Content.Div.verify(message.div);
                        if (error)
                            return "div." + error;
                    }
                }
                if (message.bookmark != null && message.hasOwnProperty("bookmark")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.anytype.model.Block.Content.Bookmark.verify(message.bookmark);
                        if (error)
                            return "bookmark." + error;
                    }
                }
                if (message.icon != null && message.hasOwnProperty("icon")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.anytype.model.Block.Content.Icon.verify(message.icon);
                        if (error)
                            return "icon." + error;
                    }
                }
                if (message.link != null && message.hasOwnProperty("link")) {
                    if (properties.content === 1)
                        return "content: multiple values";
                    properties.content = 1;
                    {
                        var error = $root.anytype.model.Block.Content.Link.verify(message.link);
                        if (error)
                            return "link." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Block message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.model.Block
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.model.Block} Block
             */
            Block.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.model.Block)
                    return object;
                var message = new $root.anytype.model.Block();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.fields != null) {
                    if (typeof object.fields !== "object")
                        throw TypeError(".anytype.model.Block.fields: object expected");
                    message.fields = $root.google.protobuf.Struct.fromObject(object.fields);
                }
                if (object.restrictions != null) {
                    if (typeof object.restrictions !== "object")
                        throw TypeError(".anytype.model.Block.restrictions: object expected");
                    message.restrictions = $root.anytype.model.Block.Restrictions.fromObject(object.restrictions);
                }
                if (object.childrenIds) {
                    if (!Array.isArray(object.childrenIds))
                        throw TypeError(".anytype.model.Block.childrenIds: array expected");
                    message.childrenIds = [];
                    for (var i = 0; i < object.childrenIds.length; ++i)
                        message.childrenIds[i] = String(object.childrenIds[i]);
                }
                if (object.isArchived != null)
                    message.isArchived = Boolean(object.isArchived);
                if (object.dashboard != null) {
                    if (typeof object.dashboard !== "object")
                        throw TypeError(".anytype.model.Block.dashboard: object expected");
                    message.dashboard = $root.anytype.model.Block.Content.Dashboard.fromObject(object.dashboard);
                }
                if (object.page != null) {
                    if (typeof object.page !== "object")
                        throw TypeError(".anytype.model.Block.page: object expected");
                    message.page = $root.anytype.model.Block.Content.Page.fromObject(object.page);
                }
                if (object.dataview != null) {
                    if (typeof object.dataview !== "object")
                        throw TypeError(".anytype.model.Block.dataview: object expected");
                    message.dataview = $root.anytype.model.Block.Content.Dataview.fromObject(object.dataview);
                }
                if (object.text != null) {
                    if (typeof object.text !== "object")
                        throw TypeError(".anytype.model.Block.text: object expected");
                    message.text = $root.anytype.model.Block.Content.Text.fromObject(object.text);
                }
                if (object.file != null) {
                    if (typeof object.file !== "object")
                        throw TypeError(".anytype.model.Block.file: object expected");
                    message.file = $root.anytype.model.Block.Content.File.fromObject(object.file);
                }
                if (object.layout != null) {
                    if (typeof object.layout !== "object")
                        throw TypeError(".anytype.model.Block.layout: object expected");
                    message.layout = $root.anytype.model.Block.Content.Layout.fromObject(object.layout);
                }
                if (object.div != null) {
                    if (typeof object.div !== "object")
                        throw TypeError(".anytype.model.Block.div: object expected");
                    message.div = $root.anytype.model.Block.Content.Div.fromObject(object.div);
                }
                if (object.bookmark != null) {
                    if (typeof object.bookmark !== "object")
                        throw TypeError(".anytype.model.Block.bookmark: object expected");
                    message.bookmark = $root.anytype.model.Block.Content.Bookmark.fromObject(object.bookmark);
                }
                if (object.icon != null) {
                    if (typeof object.icon !== "object")
                        throw TypeError(".anytype.model.Block.icon: object expected");
                    message.icon = $root.anytype.model.Block.Content.Icon.fromObject(object.icon);
                }
                if (object.link != null) {
                    if (typeof object.link !== "object")
                        throw TypeError(".anytype.model.Block.link: object expected");
                    message.link = $root.anytype.model.Block.Content.Link.fromObject(object.link);
                }
                return message;
            };

            /**
             * Creates a plain object from a Block message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.model.Block
             * @static
             * @param {anytype.model.Block} message Block
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Block.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.childrenIds = [];
                if (options.defaults) {
                    object.id = "";
                    object.fields = null;
                    object.restrictions = null;
                    object.isArchived = false;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.fields != null && message.hasOwnProperty("fields"))
                    object.fields = $root.google.protobuf.Struct.toObject(message.fields, options);
                if (message.restrictions != null && message.hasOwnProperty("restrictions"))
                    object.restrictions = $root.anytype.model.Block.Restrictions.toObject(message.restrictions, options);
                if (message.childrenIds && message.childrenIds.length) {
                    object.childrenIds = [];
                    for (var j = 0; j < message.childrenIds.length; ++j)
                        object.childrenIds[j] = message.childrenIds[j];
                }
                if (message.isArchived != null && message.hasOwnProperty("isArchived"))
                    object.isArchived = message.isArchived;
                if (message.dashboard != null && message.hasOwnProperty("dashboard")) {
                    object.dashboard = $root.anytype.model.Block.Content.Dashboard.toObject(message.dashboard, options);
                    if (options.oneofs)
                        object.content = "dashboard";
                }
                if (message.page != null && message.hasOwnProperty("page")) {
                    object.page = $root.anytype.model.Block.Content.Page.toObject(message.page, options);
                    if (options.oneofs)
                        object.content = "page";
                }
                if (message.dataview != null && message.hasOwnProperty("dataview")) {
                    object.dataview = $root.anytype.model.Block.Content.Dataview.toObject(message.dataview, options);
                    if (options.oneofs)
                        object.content = "dataview";
                }
                if (message.text != null && message.hasOwnProperty("text")) {
                    object.text = $root.anytype.model.Block.Content.Text.toObject(message.text, options);
                    if (options.oneofs)
                        object.content = "text";
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = $root.anytype.model.Block.Content.File.toObject(message.file, options);
                    if (options.oneofs)
                        object.content = "file";
                }
                if (message.layout != null && message.hasOwnProperty("layout")) {
                    object.layout = $root.anytype.model.Block.Content.Layout.toObject(message.layout, options);
                    if (options.oneofs)
                        object.content = "layout";
                }
                if (message.div != null && message.hasOwnProperty("div")) {
                    object.div = $root.anytype.model.Block.Content.Div.toObject(message.div, options);
                    if (options.oneofs)
                        object.content = "div";
                }
                if (message.bookmark != null && message.hasOwnProperty("bookmark")) {
                    object.bookmark = $root.anytype.model.Block.Content.Bookmark.toObject(message.bookmark, options);
                    if (options.oneofs)
                        object.content = "bookmark";
                }
                if (message.icon != null && message.hasOwnProperty("icon")) {
                    object.icon = $root.anytype.model.Block.Content.Icon.toObject(message.icon, options);
                    if (options.oneofs)
                        object.content = "icon";
                }
                if (message.link != null && message.hasOwnProperty("link")) {
                    object.link = $root.anytype.model.Block.Content.Link.toObject(message.link, options);
                    if (options.oneofs)
                        object.content = "link";
                }
                return object;
            };

            /**
             * Converts this Block to JSON.
             * @function toJSON
             * @memberof anytype.model.Block
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Block.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Block.Restrictions = (function() {

                /**
                 * Properties of a Restrictions.
                 * @memberof anytype.model.Block
                 * @interface IRestrictions
                 * @property {boolean|null} [read] Restrictions read
                 * @property {boolean|null} [edit] Restrictions edit
                 * @property {boolean|null} [remove] Restrictions remove
                 * @property {boolean|null} [drag] Restrictions drag
                 * @property {boolean|null} [dropOn] Restrictions dropOn
                 */

                /**
                 * Constructs a new Restrictions.
                 * @memberof anytype.model.Block
                 * @classdesc Represents a Restrictions.
                 * @implements IRestrictions
                 * @constructor
                 * @param {anytype.model.Block.IRestrictions=} [properties] Properties to set
                 */
                function Restrictions(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Restrictions read.
                 * @member {boolean} read
                 * @memberof anytype.model.Block.Restrictions
                 * @instance
                 */
                Restrictions.prototype.read = false;

                /**
                 * Restrictions edit.
                 * @member {boolean} edit
                 * @memberof anytype.model.Block.Restrictions
                 * @instance
                 */
                Restrictions.prototype.edit = false;

                /**
                 * Restrictions remove.
                 * @member {boolean} remove
                 * @memberof anytype.model.Block.Restrictions
                 * @instance
                 */
                Restrictions.prototype.remove = false;

                /**
                 * Restrictions drag.
                 * @member {boolean} drag
                 * @memberof anytype.model.Block.Restrictions
                 * @instance
                 */
                Restrictions.prototype.drag = false;

                /**
                 * Restrictions dropOn.
                 * @member {boolean} dropOn
                 * @memberof anytype.model.Block.Restrictions
                 * @instance
                 */
                Restrictions.prototype.dropOn = false;

                /**
                 * Creates a new Restrictions instance using the specified properties.
                 * @function create
                 * @memberof anytype.model.Block.Restrictions
                 * @static
                 * @param {anytype.model.Block.IRestrictions=} [properties] Properties to set
                 * @returns {anytype.model.Block.Restrictions} Restrictions instance
                 */
                Restrictions.create = function create(properties) {
                    return new Restrictions(properties);
                };

                /**
                 * Encodes the specified Restrictions message. Does not implicitly {@link anytype.model.Block.Restrictions.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.model.Block.Restrictions
                 * @static
                 * @param {anytype.model.Block.IRestrictions} message Restrictions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Restrictions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.read != null && message.hasOwnProperty("read"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.read);
                    if (message.edit != null && message.hasOwnProperty("edit"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.edit);
                    if (message.remove != null && message.hasOwnProperty("remove"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.remove);
                    if (message.drag != null && message.hasOwnProperty("drag"))
                        writer.uint32(/* id 4, wireType 0 =*/32).bool(message.drag);
                    if (message.dropOn != null && message.hasOwnProperty("dropOn"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.dropOn);
                    return writer;
                };

                /**
                 * Encodes the specified Restrictions message, length delimited. Does not implicitly {@link anytype.model.Block.Restrictions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.model.Block.Restrictions
                 * @static
                 * @param {anytype.model.Block.IRestrictions} message Restrictions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Restrictions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Restrictions message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.model.Block.Restrictions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.model.Block.Restrictions} Restrictions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Restrictions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Restrictions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.read = reader.bool();
                            break;
                        case 2:
                            message.edit = reader.bool();
                            break;
                        case 3:
                            message.remove = reader.bool();
                            break;
                        case 4:
                            message.drag = reader.bool();
                            break;
                        case 5:
                            message.dropOn = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Restrictions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.model.Block.Restrictions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.model.Block.Restrictions} Restrictions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Restrictions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Restrictions message.
                 * @function verify
                 * @memberof anytype.model.Block.Restrictions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Restrictions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.read != null && message.hasOwnProperty("read"))
                        if (typeof message.read !== "boolean")
                            return "read: boolean expected";
                    if (message.edit != null && message.hasOwnProperty("edit"))
                        if (typeof message.edit !== "boolean")
                            return "edit: boolean expected";
                    if (message.remove != null && message.hasOwnProperty("remove"))
                        if (typeof message.remove !== "boolean")
                            return "remove: boolean expected";
                    if (message.drag != null && message.hasOwnProperty("drag"))
                        if (typeof message.drag !== "boolean")
                            return "drag: boolean expected";
                    if (message.dropOn != null && message.hasOwnProperty("dropOn"))
                        if (typeof message.dropOn !== "boolean")
                            return "dropOn: boolean expected";
                    return null;
                };

                /**
                 * Creates a Restrictions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.model.Block.Restrictions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.model.Block.Restrictions} Restrictions
                 */
                Restrictions.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.model.Block.Restrictions)
                        return object;
                    var message = new $root.anytype.model.Block.Restrictions();
                    if (object.read != null)
                        message.read = Boolean(object.read);
                    if (object.edit != null)
                        message.edit = Boolean(object.edit);
                    if (object.remove != null)
                        message.remove = Boolean(object.remove);
                    if (object.drag != null)
                        message.drag = Boolean(object.drag);
                    if (object.dropOn != null)
                        message.dropOn = Boolean(object.dropOn);
                    return message;
                };

                /**
                 * Creates a plain object from a Restrictions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.model.Block.Restrictions
                 * @static
                 * @param {anytype.model.Block.Restrictions} message Restrictions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Restrictions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.read = false;
                        object.edit = false;
                        object.remove = false;
                        object.drag = false;
                        object.dropOn = false;
                    }
                    if (message.read != null && message.hasOwnProperty("read"))
                        object.read = message.read;
                    if (message.edit != null && message.hasOwnProperty("edit"))
                        object.edit = message.edit;
                    if (message.remove != null && message.hasOwnProperty("remove"))
                        object.remove = message.remove;
                    if (message.drag != null && message.hasOwnProperty("drag"))
                        object.drag = message.drag;
                    if (message.dropOn != null && message.hasOwnProperty("dropOn"))
                        object.dropOn = message.dropOn;
                    return object;
                };

                /**
                 * Converts this Restrictions to JSON.
                 * @function toJSON
                 * @memberof anytype.model.Block.Restrictions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Restrictions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Restrictions;
            })();

            /**
             * Position enum.
             * @name anytype.model.Block.Position
             * @enum {string}
             * @property {number} None=0 None value
             * @property {number} Top=1 Top value
             * @property {number} Bottom=2 Bottom value
             * @property {number} Left=3 Left value
             * @property {number} Right=4 Right value
             * @property {number} Inner=5 Inner value
             */
            Block.Position = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "None"] = 0;
                values[valuesById[1] = "Top"] = 1;
                values[valuesById[2] = "Bottom"] = 2;
                values[valuesById[3] = "Left"] = 3;
                values[valuesById[4] = "Right"] = 4;
                values[valuesById[5] = "Inner"] = 5;
                return values;
            })();

            Block.Content = (function() {

                /**
                 * Properties of a Content.
                 * @memberof anytype.model.Block
                 * @interface IContent
                 */

                /**
                 * Constructs a new Content.
                 * @memberof anytype.model.Block
                 * @classdesc Represents a Content.
                 * @implements IContent
                 * @constructor
                 * @param {anytype.model.Block.IContent=} [properties] Properties to set
                 */
                function Content(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Content instance using the specified properties.
                 * @function create
                 * @memberof anytype.model.Block.Content
                 * @static
                 * @param {anytype.model.Block.IContent=} [properties] Properties to set
                 * @returns {anytype.model.Block.Content} Content instance
                 */
                Content.create = function create(properties) {
                    return new Content(properties);
                };

                /**
                 * Encodes the specified Content message. Does not implicitly {@link anytype.model.Block.Content.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.model.Block.Content
                 * @static
                 * @param {anytype.model.Block.IContent} message Content message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Content.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Content message, length delimited. Does not implicitly {@link anytype.model.Block.Content.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.model.Block.Content
                 * @static
                 * @param {anytype.model.Block.IContent} message Content message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Content.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Content message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.model.Block.Content
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.model.Block.Content} Content
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Content.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Content message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.model.Block.Content
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.model.Block.Content} Content
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Content.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Content message.
                 * @function verify
                 * @memberof anytype.model.Block.Content
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Content.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Content message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.model.Block.Content
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.model.Block.Content} Content
                 */
                Content.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.model.Block.Content)
                        return object;
                    return new $root.anytype.model.Block.Content();
                };

                /**
                 * Creates a plain object from a Content message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.model.Block.Content
                 * @static
                 * @param {anytype.model.Block.Content} message Content
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Content.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Content to JSON.
                 * @function toJSON
                 * @memberof anytype.model.Block.Content
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Content.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Content.Layout = (function() {

                    /**
                     * Properties of a Layout.
                     * @memberof anytype.model.Block.Content
                     * @interface ILayout
                     * @property {anytype.model.Block.Content.Layout.Style|null} [style] Layout style
                     */

                    /**
                     * Constructs a new Layout.
                     * @memberof anytype.model.Block.Content
                     * @classdesc Represents a Layout.
                     * @implements ILayout
                     * @constructor
                     * @param {anytype.model.Block.Content.ILayout=} [properties] Properties to set
                     */
                    function Layout(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Layout style.
                     * @member {anytype.model.Block.Content.Layout.Style} style
                     * @memberof anytype.model.Block.Content.Layout
                     * @instance
                     */
                    Layout.prototype.style = 0;

                    /**
                     * Creates a new Layout instance using the specified properties.
                     * @function create
                     * @memberof anytype.model.Block.Content.Layout
                     * @static
                     * @param {anytype.model.Block.Content.ILayout=} [properties] Properties to set
                     * @returns {anytype.model.Block.Content.Layout} Layout instance
                     */
                    Layout.create = function create(properties) {
                        return new Layout(properties);
                    };

                    /**
                     * Encodes the specified Layout message. Does not implicitly {@link anytype.model.Block.Content.Layout.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.model.Block.Content.Layout
                     * @static
                     * @param {anytype.model.Block.Content.ILayout} message Layout message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Layout.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.style != null && message.hasOwnProperty("style"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.style);
                        return writer;
                    };

                    /**
                     * Encodes the specified Layout message, length delimited. Does not implicitly {@link anytype.model.Block.Content.Layout.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.model.Block.Content.Layout
                     * @static
                     * @param {anytype.model.Block.Content.ILayout} message Layout message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Layout.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Layout message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.model.Block.Content.Layout
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.model.Block.Content.Layout} Layout
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Layout.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content.Layout();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.style = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Layout message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.model.Block.Content.Layout
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.model.Block.Content.Layout} Layout
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Layout.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Layout message.
                     * @function verify
                     * @memberof anytype.model.Block.Content.Layout
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Layout.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.style != null && message.hasOwnProperty("style"))
                            switch (message.style) {
                            default:
                                return "style: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a Layout message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.model.Block.Content.Layout
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.model.Block.Content.Layout} Layout
                     */
                    Layout.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.model.Block.Content.Layout)
                            return object;
                        var message = new $root.anytype.model.Block.Content.Layout();
                        switch (object.style) {
                        case "Row":
                        case 0:
                            message.style = 0;
                            break;
                        case "Column":
                        case 1:
                            message.style = 1;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Layout message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.model.Block.Content.Layout
                     * @static
                     * @param {anytype.model.Block.Content.Layout} message Layout
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Layout.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.style = options.enums === String ? "Row" : 0;
                        if (message.style != null && message.hasOwnProperty("style"))
                            object.style = options.enums === String ? $root.anytype.model.Block.Content.Layout.Style[message.style] : message.style;
                        return object;
                    };

                    /**
                     * Converts this Layout to JSON.
                     * @function toJSON
                     * @memberof anytype.model.Block.Content.Layout
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Layout.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Style enum.
                     * @name anytype.model.Block.Content.Layout.Style
                     * @enum {string}
                     * @property {number} Row=0 Row value
                     * @property {number} Column=1 Column value
                     */
                    Layout.Style = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "Row"] = 0;
                        values[valuesById[1] = "Column"] = 1;
                        return values;
                    })();

                    return Layout;
                })();

                Content.Link = (function() {

                    /**
                     * Properties of a Link.
                     * @memberof anytype.model.Block.Content
                     * @interface ILink
                     * @property {string|null} [targetBlockId] Link targetBlockId
                     * @property {anytype.model.Block.Content.Link.Style|null} [style] Link style
                     * @property {google.protobuf.IStruct|null} [fields] Link fields
                     * @property {boolean|null} [isArchived] Link isArchived
                     */

                    /**
                     * Constructs a new Link.
                     * @memberof anytype.model.Block.Content
                     * @classdesc Represents a Link.
                     * @implements ILink
                     * @constructor
                     * @param {anytype.model.Block.Content.ILink=} [properties] Properties to set
                     */
                    function Link(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Link targetBlockId.
                     * @member {string} targetBlockId
                     * @memberof anytype.model.Block.Content.Link
                     * @instance
                     */
                    Link.prototype.targetBlockId = "";

                    /**
                     * Link style.
                     * @member {anytype.model.Block.Content.Link.Style} style
                     * @memberof anytype.model.Block.Content.Link
                     * @instance
                     */
                    Link.prototype.style = 0;

                    /**
                     * Link fields.
                     * @member {google.protobuf.IStruct|null|undefined} fields
                     * @memberof anytype.model.Block.Content.Link
                     * @instance
                     */
                    Link.prototype.fields = null;

                    /**
                     * Link isArchived.
                     * @member {boolean} isArchived
                     * @memberof anytype.model.Block.Content.Link
                     * @instance
                     */
                    Link.prototype.isArchived = false;

                    /**
                     * Creates a new Link instance using the specified properties.
                     * @function create
                     * @memberof anytype.model.Block.Content.Link
                     * @static
                     * @param {anytype.model.Block.Content.ILink=} [properties] Properties to set
                     * @returns {anytype.model.Block.Content.Link} Link instance
                     */
                    Link.create = function create(properties) {
                        return new Link(properties);
                    };

                    /**
                     * Encodes the specified Link message. Does not implicitly {@link anytype.model.Block.Content.Link.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.model.Block.Content.Link
                     * @static
                     * @param {anytype.model.Block.Content.ILink} message Link message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Link.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.targetBlockId != null && message.hasOwnProperty("targetBlockId"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetBlockId);
                        if (message.style != null && message.hasOwnProperty("style"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.style);
                        if (message.fields != null && message.hasOwnProperty("fields"))
                            $root.google.protobuf.Struct.encode(message.fields, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.isArchived != null && message.hasOwnProperty("isArchived"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isArchived);
                        return writer;
                    };

                    /**
                     * Encodes the specified Link message, length delimited. Does not implicitly {@link anytype.model.Block.Content.Link.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.model.Block.Content.Link
                     * @static
                     * @param {anytype.model.Block.Content.ILink} message Link message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Link.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Link message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.model.Block.Content.Link
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.model.Block.Content.Link} Link
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Link.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content.Link();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.targetBlockId = reader.string();
                                break;
                            case 2:
                                message.style = reader.int32();
                                break;
                            case 3:
                                message.fields = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.isArchived = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Link message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.model.Block.Content.Link
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.model.Block.Content.Link} Link
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Link.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Link message.
                     * @function verify
                     * @memberof anytype.model.Block.Content.Link
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Link.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.targetBlockId != null && message.hasOwnProperty("targetBlockId"))
                            if (!$util.isString(message.targetBlockId))
                                return "targetBlockId: string expected";
                        if (message.style != null && message.hasOwnProperty("style"))
                            switch (message.style) {
                            default:
                                return "style: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        if (message.fields != null && message.hasOwnProperty("fields")) {
                            var error = $root.google.protobuf.Struct.verify(message.fields);
                            if (error)
                                return "fields." + error;
                        }
                        if (message.isArchived != null && message.hasOwnProperty("isArchived"))
                            if (typeof message.isArchived !== "boolean")
                                return "isArchived: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a Link message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.model.Block.Content.Link
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.model.Block.Content.Link} Link
                     */
                    Link.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.model.Block.Content.Link)
                            return object;
                        var message = new $root.anytype.model.Block.Content.Link();
                        if (object.targetBlockId != null)
                            message.targetBlockId = String(object.targetBlockId);
                        switch (object.style) {
                        case "Page":
                        case 0:
                            message.style = 0;
                            break;
                        case "Dataview":
                        case 1:
                            message.style = 1;
                            break;
                        }
                        if (object.fields != null) {
                            if (typeof object.fields !== "object")
                                throw TypeError(".anytype.model.Block.Content.Link.fields: object expected");
                            message.fields = $root.google.protobuf.Struct.fromObject(object.fields);
                        }
                        if (object.isArchived != null)
                            message.isArchived = Boolean(object.isArchived);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Link message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.model.Block.Content.Link
                     * @static
                     * @param {anytype.model.Block.Content.Link} message Link
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Link.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.targetBlockId = "";
                            object.style = options.enums === String ? "Page" : 0;
                            object.fields = null;
                            object.isArchived = false;
                        }
                        if (message.targetBlockId != null && message.hasOwnProperty("targetBlockId"))
                            object.targetBlockId = message.targetBlockId;
                        if (message.style != null && message.hasOwnProperty("style"))
                            object.style = options.enums === String ? $root.anytype.model.Block.Content.Link.Style[message.style] : message.style;
                        if (message.fields != null && message.hasOwnProperty("fields"))
                            object.fields = $root.google.protobuf.Struct.toObject(message.fields, options);
                        if (message.isArchived != null && message.hasOwnProperty("isArchived"))
                            object.isArchived = message.isArchived;
                        return object;
                    };

                    /**
                     * Converts this Link to JSON.
                     * @function toJSON
                     * @memberof anytype.model.Block.Content.Link
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Link.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Style enum.
                     * @name anytype.model.Block.Content.Link.Style
                     * @enum {string}
                     * @property {number} Page=0 Page value
                     * @property {number} Dataview=1 Dataview value
                     */
                    Link.Style = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "Page"] = 0;
                        values[valuesById[1] = "Dataview"] = 1;
                        return values;
                    })();

                    return Link;
                })();

                Content.Div = (function() {

                    /**
                     * Properties of a Div.
                     * @memberof anytype.model.Block.Content
                     * @interface IDiv
                     */

                    /**
                     * Constructs a new Div.
                     * @memberof anytype.model.Block.Content
                     * @classdesc Represents a Div.
                     * @implements IDiv
                     * @constructor
                     * @param {anytype.model.Block.Content.IDiv=} [properties] Properties to set
                     */
                    function Div(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Div instance using the specified properties.
                     * @function create
                     * @memberof anytype.model.Block.Content.Div
                     * @static
                     * @param {anytype.model.Block.Content.IDiv=} [properties] Properties to set
                     * @returns {anytype.model.Block.Content.Div} Div instance
                     */
                    Div.create = function create(properties) {
                        return new Div(properties);
                    };

                    /**
                     * Encodes the specified Div message. Does not implicitly {@link anytype.model.Block.Content.Div.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.model.Block.Content.Div
                     * @static
                     * @param {anytype.model.Block.Content.IDiv} message Div message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Div.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Div message, length delimited. Does not implicitly {@link anytype.model.Block.Content.Div.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.model.Block.Content.Div
                     * @static
                     * @param {anytype.model.Block.Content.IDiv} message Div message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Div.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Div message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.model.Block.Content.Div
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.model.Block.Content.Div} Div
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Div.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content.Div();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Div message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.model.Block.Content.Div
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.model.Block.Content.Div} Div
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Div.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Div message.
                     * @function verify
                     * @memberof anytype.model.Block.Content.Div
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Div.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Div message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.model.Block.Content.Div
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.model.Block.Content.Div} Div
                     */
                    Div.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.model.Block.Content.Div)
                            return object;
                        return new $root.anytype.model.Block.Content.Div();
                    };

                    /**
                     * Creates a plain object from a Div message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.model.Block.Content.Div
                     * @static
                     * @param {anytype.model.Block.Content.Div} message Div
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Div.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Div to JSON.
                     * @function toJSON
                     * @memberof anytype.model.Block.Content.Div
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Div.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Div;
                })();

                Content.Bookmark = (function() {

                    /**
                     * Properties of a Bookmark.
                     * @memberof anytype.model.Block.Content
                     * @interface IBookmark
                     */

                    /**
                     * Constructs a new Bookmark.
                     * @memberof anytype.model.Block.Content
                     * @classdesc Represents a Bookmark.
                     * @implements IBookmark
                     * @constructor
                     * @param {anytype.model.Block.Content.IBookmark=} [properties] Properties to set
                     */
                    function Bookmark(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Bookmark instance using the specified properties.
                     * @function create
                     * @memberof anytype.model.Block.Content.Bookmark
                     * @static
                     * @param {anytype.model.Block.Content.IBookmark=} [properties] Properties to set
                     * @returns {anytype.model.Block.Content.Bookmark} Bookmark instance
                     */
                    Bookmark.create = function create(properties) {
                        return new Bookmark(properties);
                    };

                    /**
                     * Encodes the specified Bookmark message. Does not implicitly {@link anytype.model.Block.Content.Bookmark.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.model.Block.Content.Bookmark
                     * @static
                     * @param {anytype.model.Block.Content.IBookmark} message Bookmark message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Bookmark.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Bookmark message, length delimited. Does not implicitly {@link anytype.model.Block.Content.Bookmark.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.model.Block.Content.Bookmark
                     * @static
                     * @param {anytype.model.Block.Content.IBookmark} message Bookmark message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Bookmark.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Bookmark message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.model.Block.Content.Bookmark
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.model.Block.Content.Bookmark} Bookmark
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Bookmark.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content.Bookmark();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Bookmark message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.model.Block.Content.Bookmark
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.model.Block.Content.Bookmark} Bookmark
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Bookmark.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Bookmark message.
                     * @function verify
                     * @memberof anytype.model.Block.Content.Bookmark
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Bookmark.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Bookmark message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.model.Block.Content.Bookmark
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.model.Block.Content.Bookmark} Bookmark
                     */
                    Bookmark.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.model.Block.Content.Bookmark)
                            return object;
                        return new $root.anytype.model.Block.Content.Bookmark();
                    };

                    /**
                     * Creates a plain object from a Bookmark message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.model.Block.Content.Bookmark
                     * @static
                     * @param {anytype.model.Block.Content.Bookmark} message Bookmark
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Bookmark.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Bookmark to JSON.
                     * @function toJSON
                     * @memberof anytype.model.Block.Content.Bookmark
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Bookmark.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Bookmark;
                })();

                Content.Icon = (function() {

                    /**
                     * Properties of an Icon.
                     * @memberof anytype.model.Block.Content
                     * @interface IIcon
                     * @property {string|null} [name] Icon name
                     */

                    /**
                     * Constructs a new Icon.
                     * @memberof anytype.model.Block.Content
                     * @classdesc Represents an Icon.
                     * @implements IIcon
                     * @constructor
                     * @param {anytype.model.Block.Content.IIcon=} [properties] Properties to set
                     */
                    function Icon(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Icon name.
                     * @member {string} name
                     * @memberof anytype.model.Block.Content.Icon
                     * @instance
                     */
                    Icon.prototype.name = "";

                    /**
                     * Creates a new Icon instance using the specified properties.
                     * @function create
                     * @memberof anytype.model.Block.Content.Icon
                     * @static
                     * @param {anytype.model.Block.Content.IIcon=} [properties] Properties to set
                     * @returns {anytype.model.Block.Content.Icon} Icon instance
                     */
                    Icon.create = function create(properties) {
                        return new Icon(properties);
                    };

                    /**
                     * Encodes the specified Icon message. Does not implicitly {@link anytype.model.Block.Content.Icon.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.model.Block.Content.Icon
                     * @static
                     * @param {anytype.model.Block.Content.IIcon} message Icon message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Icon.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.name != null && message.hasOwnProperty("name"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                        return writer;
                    };

                    /**
                     * Encodes the specified Icon message, length delimited. Does not implicitly {@link anytype.model.Block.Content.Icon.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.model.Block.Content.Icon
                     * @static
                     * @param {anytype.model.Block.Content.IIcon} message Icon message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Icon.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Icon message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.model.Block.Content.Icon
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.model.Block.Content.Icon} Icon
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Icon.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content.Icon();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.name = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Icon message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.model.Block.Content.Icon
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.model.Block.Content.Icon} Icon
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Icon.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Icon message.
                     * @function verify
                     * @memberof anytype.model.Block.Content.Icon
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Icon.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        return null;
                    };

                    /**
                     * Creates an Icon message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.model.Block.Content.Icon
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.model.Block.Content.Icon} Icon
                     */
                    Icon.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.model.Block.Content.Icon)
                            return object;
                        var message = new $root.anytype.model.Block.Content.Icon();
                        if (object.name != null)
                            message.name = String(object.name);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Icon message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.model.Block.Content.Icon
                     * @static
                     * @param {anytype.model.Block.Content.Icon} message Icon
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Icon.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.name = "";
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        return object;
                    };

                    /**
                     * Converts this Icon to JSON.
                     * @function toJSON
                     * @memberof anytype.model.Block.Content.Icon
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Icon.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Icon;
                })();

                Content.Dashboard = (function() {

                    /**
                     * Properties of a Dashboard.
                     * @memberof anytype.model.Block.Content
                     * @interface IDashboard
                     * @property {anytype.model.Block.Content.Dashboard.Style|null} [style] Dashboard style
                     */

                    /**
                     * Constructs a new Dashboard.
                     * @memberof anytype.model.Block.Content
                     * @classdesc Represents a Dashboard.
                     * @implements IDashboard
                     * @constructor
                     * @param {anytype.model.Block.Content.IDashboard=} [properties] Properties to set
                     */
                    function Dashboard(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Dashboard style.
                     * @member {anytype.model.Block.Content.Dashboard.Style} style
                     * @memberof anytype.model.Block.Content.Dashboard
                     * @instance
                     */
                    Dashboard.prototype.style = 0;

                    /**
                     * Creates a new Dashboard instance using the specified properties.
                     * @function create
                     * @memberof anytype.model.Block.Content.Dashboard
                     * @static
                     * @param {anytype.model.Block.Content.IDashboard=} [properties] Properties to set
                     * @returns {anytype.model.Block.Content.Dashboard} Dashboard instance
                     */
                    Dashboard.create = function create(properties) {
                        return new Dashboard(properties);
                    };

                    /**
                     * Encodes the specified Dashboard message. Does not implicitly {@link anytype.model.Block.Content.Dashboard.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.model.Block.Content.Dashboard
                     * @static
                     * @param {anytype.model.Block.Content.IDashboard} message Dashboard message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Dashboard.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.style != null && message.hasOwnProperty("style"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.style);
                        return writer;
                    };

                    /**
                     * Encodes the specified Dashboard message, length delimited. Does not implicitly {@link anytype.model.Block.Content.Dashboard.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.model.Block.Content.Dashboard
                     * @static
                     * @param {anytype.model.Block.Content.IDashboard} message Dashboard message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Dashboard.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Dashboard message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.model.Block.Content.Dashboard
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.model.Block.Content.Dashboard} Dashboard
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Dashboard.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content.Dashboard();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.style = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Dashboard message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.model.Block.Content.Dashboard
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.model.Block.Content.Dashboard} Dashboard
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Dashboard.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Dashboard message.
                     * @function verify
                     * @memberof anytype.model.Block.Content.Dashboard
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Dashboard.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.style != null && message.hasOwnProperty("style"))
                            switch (message.style) {
                            default:
                                return "style: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a Dashboard message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.model.Block.Content.Dashboard
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.model.Block.Content.Dashboard} Dashboard
                     */
                    Dashboard.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.model.Block.Content.Dashboard)
                            return object;
                        var message = new $root.anytype.model.Block.Content.Dashboard();
                        switch (object.style) {
                        case "MainScreen":
                        case 0:
                            message.style = 0;
                            break;
                        case "Archive":
                        case 1:
                            message.style = 1;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Dashboard message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.model.Block.Content.Dashboard
                     * @static
                     * @param {anytype.model.Block.Content.Dashboard} message Dashboard
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Dashboard.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.style = options.enums === String ? "MainScreen" : 0;
                        if (message.style != null && message.hasOwnProperty("style"))
                            object.style = options.enums === String ? $root.anytype.model.Block.Content.Dashboard.Style[message.style] : message.style;
                        return object;
                    };

                    /**
                     * Converts this Dashboard to JSON.
                     * @function toJSON
                     * @memberof anytype.model.Block.Content.Dashboard
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Dashboard.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Style enum.
                     * @name anytype.model.Block.Content.Dashboard.Style
                     * @enum {string}
                     * @property {number} MainScreen=0 MainScreen value
                     * @property {number} Archive=1 Archive value
                     */
                    Dashboard.Style = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "MainScreen"] = 0;
                        values[valuesById[1] = "Archive"] = 1;
                        return values;
                    })();

                    return Dashboard;
                })();

                Content.Dataview = (function() {

                    /**
                     * Properties of a Dataview.
                     * @memberof anytype.model.Block.Content
                     * @interface IDataview
                     */

                    /**
                     * Constructs a new Dataview.
                     * @memberof anytype.model.Block.Content
                     * @classdesc Represents a Dataview.
                     * @implements IDataview
                     * @constructor
                     * @param {anytype.model.Block.Content.IDataview=} [properties] Properties to set
                     */
                    function Dataview(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Creates a new Dataview instance using the specified properties.
                     * @function create
                     * @memberof anytype.model.Block.Content.Dataview
                     * @static
                     * @param {anytype.model.Block.Content.IDataview=} [properties] Properties to set
                     * @returns {anytype.model.Block.Content.Dataview} Dataview instance
                     */
                    Dataview.create = function create(properties) {
                        return new Dataview(properties);
                    };

                    /**
                     * Encodes the specified Dataview message. Does not implicitly {@link anytype.model.Block.Content.Dataview.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.model.Block.Content.Dataview
                     * @static
                     * @param {anytype.model.Block.Content.IDataview} message Dataview message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Dataview.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };

                    /**
                     * Encodes the specified Dataview message, length delimited. Does not implicitly {@link anytype.model.Block.Content.Dataview.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.model.Block.Content.Dataview
                     * @static
                     * @param {anytype.model.Block.Content.IDataview} message Dataview message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Dataview.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Dataview message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.model.Block.Content.Dataview
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.model.Block.Content.Dataview} Dataview
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Dataview.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content.Dataview();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Dataview message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.model.Block.Content.Dataview
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.model.Block.Content.Dataview} Dataview
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Dataview.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Dataview message.
                     * @function verify
                     * @memberof anytype.model.Block.Content.Dataview
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Dataview.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a Dataview message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.model.Block.Content.Dataview
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.model.Block.Content.Dataview} Dataview
                     */
                    Dataview.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.model.Block.Content.Dataview)
                            return object;
                        return new $root.anytype.model.Block.Content.Dataview();
                    };

                    /**
                     * Creates a plain object from a Dataview message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.model.Block.Content.Dataview
                     * @static
                     * @param {anytype.model.Block.Content.Dataview} message Dataview
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Dataview.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this Dataview to JSON.
                     * @function toJSON
                     * @memberof anytype.model.Block.Content.Dataview
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Dataview.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Dataview;
                })();

                Content.Text = (function() {

                    /**
                     * Properties of a Text.
                     * @memberof anytype.model.Block.Content
                     * @interface IText
                     * @property {string|null} [text] Text text
                     * @property {anytype.model.Block.Content.Text.Style|null} [style] Text style
                     * @property {anytype.model.Block.Content.Text.IMarks|null} [marks] Text marks
                     * @property {boolean|null} [checked] Text checked
                     * @property {string|null} [color] Text color
                     * @property {string|null} [backgroundColor] Text backgroundColor
                     */

                    /**
                     * Constructs a new Text.
                     * @memberof anytype.model.Block.Content
                     * @classdesc Represents a Text.
                     * @implements IText
                     * @constructor
                     * @param {anytype.model.Block.Content.IText=} [properties] Properties to set
                     */
                    function Text(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Text text.
                     * @member {string} text
                     * @memberof anytype.model.Block.Content.Text
                     * @instance
                     */
                    Text.prototype.text = "";

                    /**
                     * Text style.
                     * @member {anytype.model.Block.Content.Text.Style} style
                     * @memberof anytype.model.Block.Content.Text
                     * @instance
                     */
                    Text.prototype.style = 0;

                    /**
                     * Text marks.
                     * @member {anytype.model.Block.Content.Text.IMarks|null|undefined} marks
                     * @memberof anytype.model.Block.Content.Text
                     * @instance
                     */
                    Text.prototype.marks = null;

                    /**
                     * Text checked.
                     * @member {boolean} checked
                     * @memberof anytype.model.Block.Content.Text
                     * @instance
                     */
                    Text.prototype.checked = false;

                    /**
                     * Text color.
                     * @member {string} color
                     * @memberof anytype.model.Block.Content.Text
                     * @instance
                     */
                    Text.prototype.color = "";

                    /**
                     * Text backgroundColor.
                     * @member {string} backgroundColor
                     * @memberof anytype.model.Block.Content.Text
                     * @instance
                     */
                    Text.prototype.backgroundColor = "";

                    /**
                     * Creates a new Text instance using the specified properties.
                     * @function create
                     * @memberof anytype.model.Block.Content.Text
                     * @static
                     * @param {anytype.model.Block.Content.IText=} [properties] Properties to set
                     * @returns {anytype.model.Block.Content.Text} Text instance
                     */
                    Text.create = function create(properties) {
                        return new Text(properties);
                    };

                    /**
                     * Encodes the specified Text message. Does not implicitly {@link anytype.model.Block.Content.Text.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.model.Block.Content.Text
                     * @static
                     * @param {anytype.model.Block.Content.IText} message Text message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Text.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.text != null && message.hasOwnProperty("text"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                        if (message.style != null && message.hasOwnProperty("style"))
                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.style);
                        if (message.marks != null && message.hasOwnProperty("marks"))
                            $root.anytype.model.Block.Content.Text.Marks.encode(message.marks, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                        if (message.checked != null && message.hasOwnProperty("checked"))
                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.checked);
                        if (message.color != null && message.hasOwnProperty("color"))
                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.color);
                        if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor"))
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.backgroundColor);
                        return writer;
                    };

                    /**
                     * Encodes the specified Text message, length delimited. Does not implicitly {@link anytype.model.Block.Content.Text.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.model.Block.Content.Text
                     * @static
                     * @param {anytype.model.Block.Content.IText} message Text message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Text.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Text message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.model.Block.Content.Text
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.model.Block.Content.Text} Text
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Text.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content.Text();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.text = reader.string();
                                break;
                            case 2:
                                message.style = reader.int32();
                                break;
                            case 3:
                                message.marks = $root.anytype.model.Block.Content.Text.Marks.decode(reader, reader.uint32());
                                break;
                            case 4:
                                message.checked = reader.bool();
                                break;
                            case 5:
                                message.color = reader.string();
                                break;
                            case 6:
                                message.backgroundColor = reader.string();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Text message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.model.Block.Content.Text
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.model.Block.Content.Text} Text
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Text.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Text message.
                     * @function verify
                     * @memberof anytype.model.Block.Content.Text
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Text.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.text != null && message.hasOwnProperty("text"))
                            if (!$util.isString(message.text))
                                return "text: string expected";
                        if (message.style != null && message.hasOwnProperty("style"))
                            switch (message.style) {
                            default:
                                return "style: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            case 11:
                                break;
                            }
                        if (message.marks != null && message.hasOwnProperty("marks")) {
                            var error = $root.anytype.model.Block.Content.Text.Marks.verify(message.marks);
                            if (error)
                                return "marks." + error;
                        }
                        if (message.checked != null && message.hasOwnProperty("checked"))
                            if (typeof message.checked !== "boolean")
                                return "checked: boolean expected";
                        if (message.color != null && message.hasOwnProperty("color"))
                            if (!$util.isString(message.color))
                                return "color: string expected";
                        if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor"))
                            if (!$util.isString(message.backgroundColor))
                                return "backgroundColor: string expected";
                        return null;
                    };

                    /**
                     * Creates a Text message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.model.Block.Content.Text
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.model.Block.Content.Text} Text
                     */
                    Text.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.model.Block.Content.Text)
                            return object;
                        var message = new $root.anytype.model.Block.Content.Text();
                        if (object.text != null)
                            message.text = String(object.text);
                        switch (object.style) {
                        case "Paragraph":
                        case 0:
                            message.style = 0;
                            break;
                        case "Header1":
                        case 1:
                            message.style = 1;
                            break;
                        case "Header2":
                        case 2:
                            message.style = 2;
                            break;
                        case "Header3":
                        case 3:
                            message.style = 3;
                            break;
                        case "Header4":
                        case 4:
                            message.style = 4;
                            break;
                        case "Quote":
                        case 5:
                            message.style = 5;
                            break;
                        case "Code":
                        case 6:
                            message.style = 6;
                            break;
                        case "Title":
                        case 7:
                            message.style = 7;
                            break;
                        case "Checkbox":
                        case 8:
                            message.style = 8;
                            break;
                        case "Marked":
                        case 9:
                            message.style = 9;
                            break;
                        case "Numbered":
                        case 10:
                            message.style = 10;
                            break;
                        case "Toggle":
                        case 11:
                            message.style = 11;
                            break;
                        }
                        if (object.marks != null) {
                            if (typeof object.marks !== "object")
                                throw TypeError(".anytype.model.Block.Content.Text.marks: object expected");
                            message.marks = $root.anytype.model.Block.Content.Text.Marks.fromObject(object.marks);
                        }
                        if (object.checked != null)
                            message.checked = Boolean(object.checked);
                        if (object.color != null)
                            message.color = String(object.color);
                        if (object.backgroundColor != null)
                            message.backgroundColor = String(object.backgroundColor);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Text message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.model.Block.Content.Text
                     * @static
                     * @param {anytype.model.Block.Content.Text} message Text
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Text.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.text = "";
                            object.style = options.enums === String ? "Paragraph" : 0;
                            object.marks = null;
                            object.checked = false;
                            object.color = "";
                            object.backgroundColor = "";
                        }
                        if (message.text != null && message.hasOwnProperty("text"))
                            object.text = message.text;
                        if (message.style != null && message.hasOwnProperty("style"))
                            object.style = options.enums === String ? $root.anytype.model.Block.Content.Text.Style[message.style] : message.style;
                        if (message.marks != null && message.hasOwnProperty("marks"))
                            object.marks = $root.anytype.model.Block.Content.Text.Marks.toObject(message.marks, options);
                        if (message.checked != null && message.hasOwnProperty("checked"))
                            object.checked = message.checked;
                        if (message.color != null && message.hasOwnProperty("color"))
                            object.color = message.color;
                        if (message.backgroundColor != null && message.hasOwnProperty("backgroundColor"))
                            object.backgroundColor = message.backgroundColor;
                        return object;
                    };

                    /**
                     * Converts this Text to JSON.
                     * @function toJSON
                     * @memberof anytype.model.Block.Content.Text
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Text.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Text.Marks = (function() {

                        /**
                         * Properties of a Marks.
                         * @memberof anytype.model.Block.Content.Text
                         * @interface IMarks
                         * @property {Array.<anytype.model.Block.Content.Text.IMark>|null} [marks] Marks marks
                         */

                        /**
                         * Constructs a new Marks.
                         * @memberof anytype.model.Block.Content.Text
                         * @classdesc Represents a Marks.
                         * @implements IMarks
                         * @constructor
                         * @param {anytype.model.Block.Content.Text.IMarks=} [properties] Properties to set
                         */
                        function Marks(properties) {
                            this.marks = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Marks marks.
                         * @member {Array.<anytype.model.Block.Content.Text.IMark>} marks
                         * @memberof anytype.model.Block.Content.Text.Marks
                         * @instance
                         */
                        Marks.prototype.marks = $util.emptyArray;

                        /**
                         * Creates a new Marks instance using the specified properties.
                         * @function create
                         * @memberof anytype.model.Block.Content.Text.Marks
                         * @static
                         * @param {anytype.model.Block.Content.Text.IMarks=} [properties] Properties to set
                         * @returns {anytype.model.Block.Content.Text.Marks} Marks instance
                         */
                        Marks.create = function create(properties) {
                            return new Marks(properties);
                        };

                        /**
                         * Encodes the specified Marks message. Does not implicitly {@link anytype.model.Block.Content.Text.Marks.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.model.Block.Content.Text.Marks
                         * @static
                         * @param {anytype.model.Block.Content.Text.IMarks} message Marks message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Marks.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.marks != null && message.marks.length)
                                for (var i = 0; i < message.marks.length; ++i)
                                    $root.anytype.model.Block.Content.Text.Mark.encode(message.marks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            return writer;
                        };

                        /**
                         * Encodes the specified Marks message, length delimited. Does not implicitly {@link anytype.model.Block.Content.Text.Marks.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.model.Block.Content.Text.Marks
                         * @static
                         * @param {anytype.model.Block.Content.Text.IMarks} message Marks message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Marks.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Marks message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.model.Block.Content.Text.Marks
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.model.Block.Content.Text.Marks} Marks
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Marks.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content.Text.Marks();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    if (!(message.marks && message.marks.length))
                                        message.marks = [];
                                    message.marks.push($root.anytype.model.Block.Content.Text.Mark.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Marks message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.model.Block.Content.Text.Marks
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.model.Block.Content.Text.Marks} Marks
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Marks.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Marks message.
                         * @function verify
                         * @memberof anytype.model.Block.Content.Text.Marks
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Marks.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.marks != null && message.hasOwnProperty("marks")) {
                                if (!Array.isArray(message.marks))
                                    return "marks: array expected";
                                for (var i = 0; i < message.marks.length; ++i) {
                                    var error = $root.anytype.model.Block.Content.Text.Mark.verify(message.marks[i]);
                                    if (error)
                                        return "marks." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Marks message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.model.Block.Content.Text.Marks
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.model.Block.Content.Text.Marks} Marks
                         */
                        Marks.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.model.Block.Content.Text.Marks)
                                return object;
                            var message = new $root.anytype.model.Block.Content.Text.Marks();
                            if (object.marks) {
                                if (!Array.isArray(object.marks))
                                    throw TypeError(".anytype.model.Block.Content.Text.Marks.marks: array expected");
                                message.marks = [];
                                for (var i = 0; i < object.marks.length; ++i) {
                                    if (typeof object.marks[i] !== "object")
                                        throw TypeError(".anytype.model.Block.Content.Text.Marks.marks: object expected");
                                    message.marks[i] = $root.anytype.model.Block.Content.Text.Mark.fromObject(object.marks[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Marks message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.model.Block.Content.Text.Marks
                         * @static
                         * @param {anytype.model.Block.Content.Text.Marks} message Marks
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Marks.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.arrays || options.defaults)
                                object.marks = [];
                            if (message.marks && message.marks.length) {
                                object.marks = [];
                                for (var j = 0; j < message.marks.length; ++j)
                                    object.marks[j] = $root.anytype.model.Block.Content.Text.Mark.toObject(message.marks[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Marks to JSON.
                         * @function toJSON
                         * @memberof anytype.model.Block.Content.Text.Marks
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Marks.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Marks;
                    })();

                    Text.Mark = (function() {

                        /**
                         * Properties of a Mark.
                         * @memberof anytype.model.Block.Content.Text
                         * @interface IMark
                         * @property {anytype.model.IRange|null} [range] Mark range
                         * @property {anytype.model.Block.Content.Text.Mark.Type|null} [type] Mark type
                         * @property {string|null} [param] Mark param
                         */

                        /**
                         * Constructs a new Mark.
                         * @memberof anytype.model.Block.Content.Text
                         * @classdesc Represents a Mark.
                         * @implements IMark
                         * @constructor
                         * @param {anytype.model.Block.Content.Text.IMark=} [properties] Properties to set
                         */
                        function Mark(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Mark range.
                         * @member {anytype.model.IRange|null|undefined} range
                         * @memberof anytype.model.Block.Content.Text.Mark
                         * @instance
                         */
                        Mark.prototype.range = null;

                        /**
                         * Mark type.
                         * @member {anytype.model.Block.Content.Text.Mark.Type} type
                         * @memberof anytype.model.Block.Content.Text.Mark
                         * @instance
                         */
                        Mark.prototype.type = 0;

                        /**
                         * Mark param.
                         * @member {string} param
                         * @memberof anytype.model.Block.Content.Text.Mark
                         * @instance
                         */
                        Mark.prototype.param = "";

                        /**
                         * Creates a new Mark instance using the specified properties.
                         * @function create
                         * @memberof anytype.model.Block.Content.Text.Mark
                         * @static
                         * @param {anytype.model.Block.Content.Text.IMark=} [properties] Properties to set
                         * @returns {anytype.model.Block.Content.Text.Mark} Mark instance
                         */
                        Mark.create = function create(properties) {
                            return new Mark(properties);
                        };

                        /**
                         * Encodes the specified Mark message. Does not implicitly {@link anytype.model.Block.Content.Text.Mark.verify|verify} messages.
                         * @function encode
                         * @memberof anytype.model.Block.Content.Text.Mark
                         * @static
                         * @param {anytype.model.Block.Content.Text.IMark} message Mark message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Mark.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.range != null && message.hasOwnProperty("range"))
                                $root.anytype.model.Range.encode(message.range, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                            if (message.type != null && message.hasOwnProperty("type"))
                                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                            if (message.param != null && message.hasOwnProperty("param"))
                                writer.uint32(/* id 3, wireType 2 =*/26).string(message.param);
                            return writer;
                        };

                        /**
                         * Encodes the specified Mark message, length delimited. Does not implicitly {@link anytype.model.Block.Content.Text.Mark.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof anytype.model.Block.Content.Text.Mark
                         * @static
                         * @param {anytype.model.Block.Content.Text.IMark} message Mark message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        Mark.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };

                        /**
                         * Decodes a Mark message from the specified reader or buffer.
                         * @function decode
                         * @memberof anytype.model.Block.Content.Text.Mark
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {anytype.model.Block.Content.Text.Mark} Mark
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Mark.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content.Text.Mark();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.range = $root.anytype.model.Range.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    message.type = reader.int32();
                                    break;
                                case 3:
                                    message.param = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        /**
                         * Decodes a Mark message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof anytype.model.Block.Content.Text.Mark
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {anytype.model.Block.Content.Text.Mark} Mark
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Mark.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };

                        /**
                         * Verifies a Mark message.
                         * @function verify
                         * @memberof anytype.model.Block.Content.Text.Mark
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Mark.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.range != null && message.hasOwnProperty("range")) {
                                var error = $root.anytype.model.Range.verify(message.range);
                                if (error)
                                    return "range." + error;
                            }
                            if (message.type != null && message.hasOwnProperty("type"))
                                switch (message.type) {
                                default:
                                    return "type: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                    break;
                                }
                            if (message.param != null && message.hasOwnProperty("param"))
                                if (!$util.isString(message.param))
                                    return "param: string expected";
                            return null;
                        };

                        /**
                         * Creates a Mark message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof anytype.model.Block.Content.Text.Mark
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {anytype.model.Block.Content.Text.Mark} Mark
                         */
                        Mark.fromObject = function fromObject(object) {
                            if (object instanceof $root.anytype.model.Block.Content.Text.Mark)
                                return object;
                            var message = new $root.anytype.model.Block.Content.Text.Mark();
                            if (object.range != null) {
                                if (typeof object.range !== "object")
                                    throw TypeError(".anytype.model.Block.Content.Text.Mark.range: object expected");
                                message.range = $root.anytype.model.Range.fromObject(object.range);
                            }
                            switch (object.type) {
                            case "Strikethrough":
                            case 0:
                                message.type = 0;
                                break;
                            case "Keyboard":
                            case 1:
                                message.type = 1;
                                break;
                            case "Italic":
                            case 2:
                                message.type = 2;
                                break;
                            case "Bold":
                            case 3:
                                message.type = 3;
                                break;
                            case "Underscored":
                            case 4:
                                message.type = 4;
                                break;
                            case "Link":
                            case 5:
                                message.type = 5;
                                break;
                            case "TextColor":
                            case 6:
                                message.type = 6;
                                break;
                            case "BackgroundColor":
                            case 7:
                                message.type = 7;
                                break;
                            }
                            if (object.param != null)
                                message.param = String(object.param);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Mark message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof anytype.model.Block.Content.Text.Mark
                         * @static
                         * @param {anytype.model.Block.Content.Text.Mark} message Mark
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Mark.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                object.range = null;
                                object.type = options.enums === String ? "Strikethrough" : 0;
                                object.param = "";
                            }
                            if (message.range != null && message.hasOwnProperty("range"))
                                object.range = $root.anytype.model.Range.toObject(message.range, options);
                            if (message.type != null && message.hasOwnProperty("type"))
                                object.type = options.enums === String ? $root.anytype.model.Block.Content.Text.Mark.Type[message.type] : message.type;
                            if (message.param != null && message.hasOwnProperty("param"))
                                object.param = message.param;
                            return object;
                        };

                        /**
                         * Converts this Mark to JSON.
                         * @function toJSON
                         * @memberof anytype.model.Block.Content.Text.Mark
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Mark.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Type enum.
                         * @name anytype.model.Block.Content.Text.Mark.Type
                         * @enum {string}
                         * @property {number} Strikethrough=0 Strikethrough value
                         * @property {number} Keyboard=1 Keyboard value
                         * @property {number} Italic=2 Italic value
                         * @property {number} Bold=3 Bold value
                         * @property {number} Underscored=4 Underscored value
                         * @property {number} Link=5 Link value
                         * @property {number} TextColor=6 TextColor value
                         * @property {number} BackgroundColor=7 BackgroundColor value
                         */
                        Mark.Type = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "Strikethrough"] = 0;
                            values[valuesById[1] = "Keyboard"] = 1;
                            values[valuesById[2] = "Italic"] = 2;
                            values[valuesById[3] = "Bold"] = 3;
                            values[valuesById[4] = "Underscored"] = 4;
                            values[valuesById[5] = "Link"] = 5;
                            values[valuesById[6] = "TextColor"] = 6;
                            values[valuesById[7] = "BackgroundColor"] = 7;
                            return values;
                        })();

                        return Mark;
                    })();

                    /**
                     * Style enum.
                     * @name anytype.model.Block.Content.Text.Style
                     * @enum {string}
                     * @property {number} Paragraph=0 Paragraph value
                     * @property {number} Header1=1 Header1 value
                     * @property {number} Header2=2 Header2 value
                     * @property {number} Header3=3 Header3 value
                     * @property {number} Header4=4 Header4 value
                     * @property {number} Quote=5 Quote value
                     * @property {number} Code=6 Code value
                     * @property {number} Title=7 Title value
                     * @property {number} Checkbox=8 Checkbox value
                     * @property {number} Marked=9 Marked value
                     * @property {number} Numbered=10 Numbered value
                     * @property {number} Toggle=11 Toggle value
                     */
                    Text.Style = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "Paragraph"] = 0;
                        values[valuesById[1] = "Header1"] = 1;
                        values[valuesById[2] = "Header2"] = 2;
                        values[valuesById[3] = "Header3"] = 3;
                        values[valuesById[4] = "Header4"] = 4;
                        values[valuesById[5] = "Quote"] = 5;
                        values[valuesById[6] = "Code"] = 6;
                        values[valuesById[7] = "Title"] = 7;
                        values[valuesById[8] = "Checkbox"] = 8;
                        values[valuesById[9] = "Marked"] = 9;
                        values[valuesById[10] = "Numbered"] = 10;
                        values[valuesById[11] = "Toggle"] = 11;
                        return values;
                    })();

                    return Text;
                })();

                Content.File = (function() {

                    /**
                     * Properties of a File.
                     * @memberof anytype.model.Block.Content
                     * @interface IFile
                     * @property {string|null} [localFilePath] File localFilePath
                     * @property {string|null} [previewFilePath] File previewFilePath
                     * @property {anytype.model.Block.Content.File.State|null} [state] File state
                     * @property {anytype.model.Block.Content.File.Type|null} [type] File type
                     * @property {number|Long|null} [size] File size
                     * @property {number|Long|null} [addedAt] File addedAt
                     */

                    /**
                     * Constructs a new File.
                     * @memberof anytype.model.Block.Content
                     * @classdesc Represents a File.
                     * @implements IFile
                     * @constructor
                     * @param {anytype.model.Block.Content.IFile=} [properties] Properties to set
                     */
                    function File(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * File localFilePath.
                     * @member {string} localFilePath
                     * @memberof anytype.model.Block.Content.File
                     * @instance
                     */
                    File.prototype.localFilePath = "";

                    /**
                     * File previewFilePath.
                     * @member {string} previewFilePath
                     * @memberof anytype.model.Block.Content.File
                     * @instance
                     */
                    File.prototype.previewFilePath = "";

                    /**
                     * File state.
                     * @member {anytype.model.Block.Content.File.State} state
                     * @memberof anytype.model.Block.Content.File
                     * @instance
                     */
                    File.prototype.state = 0;

                    /**
                     * File type.
                     * @member {anytype.model.Block.Content.File.Type} type
                     * @memberof anytype.model.Block.Content.File
                     * @instance
                     */
                    File.prototype.type = 0;

                    /**
                     * File size.
                     * @member {number|Long} size
                     * @memberof anytype.model.Block.Content.File
                     * @instance
                     */
                    File.prototype.size = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * File addedAt.
                     * @member {number|Long} addedAt
                     * @memberof anytype.model.Block.Content.File
                     * @instance
                     */
                    File.prototype.addedAt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Creates a new File instance using the specified properties.
                     * @function create
                     * @memberof anytype.model.Block.Content.File
                     * @static
                     * @param {anytype.model.Block.Content.IFile=} [properties] Properties to set
                     * @returns {anytype.model.Block.Content.File} File instance
                     */
                    File.create = function create(properties) {
                        return new File(properties);
                    };

                    /**
                     * Encodes the specified File message. Does not implicitly {@link anytype.model.Block.Content.File.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.model.Block.Content.File
                     * @static
                     * @param {anytype.model.Block.Content.IFile} message File message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    File.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.localFilePath != null && message.hasOwnProperty("localFilePath"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.localFilePath);
                        if (message.previewFilePath != null && message.hasOwnProperty("previewFilePath"))
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.previewFilePath);
                        if (message.state != null && message.hasOwnProperty("state"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.state);
                        if (message.type != null && message.hasOwnProperty("type"))
                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                        if (message.size != null && message.hasOwnProperty("size"))
                            writer.uint32(/* id 5, wireType 0 =*/40).int64(message.size);
                        if (message.addedAt != null && message.hasOwnProperty("addedAt"))
                            writer.uint32(/* id 6, wireType 0 =*/48).int64(message.addedAt);
                        return writer;
                    };

                    /**
                     * Encodes the specified File message, length delimited. Does not implicitly {@link anytype.model.Block.Content.File.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.model.Block.Content.File
                     * @static
                     * @param {anytype.model.Block.Content.IFile} message File message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    File.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a File message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.model.Block.Content.File
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.model.Block.Content.File} File
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    File.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content.File();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.localFilePath = reader.string();
                                break;
                            case 2:
                                message.previewFilePath = reader.string();
                                break;
                            case 3:
                                message.state = reader.int32();
                                break;
                            case 4:
                                message.type = reader.int32();
                                break;
                            case 5:
                                message.size = reader.int64();
                                break;
                            case 6:
                                message.addedAt = reader.int64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a File message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.model.Block.Content.File
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.model.Block.Content.File} File
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    File.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a File message.
                     * @function verify
                     * @memberof anytype.model.Block.Content.File
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    File.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.localFilePath != null && message.hasOwnProperty("localFilePath"))
                            if (!$util.isString(message.localFilePath))
                                return "localFilePath: string expected";
                        if (message.previewFilePath != null && message.hasOwnProperty("previewFilePath"))
                            if (!$util.isString(message.previewFilePath))
                                return "previewFilePath: string expected";
                        if (message.state != null && message.hasOwnProperty("state"))
                            switch (message.state) {
                            default:
                                return "state: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        if (message.type != null && message.hasOwnProperty("type"))
                            switch (message.type) {
                            default:
                                return "type: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        if (message.size != null && message.hasOwnProperty("size"))
                            if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                                return "size: integer|Long expected";
                        if (message.addedAt != null && message.hasOwnProperty("addedAt"))
                            if (!$util.isInteger(message.addedAt) && !(message.addedAt && $util.isInteger(message.addedAt.low) && $util.isInteger(message.addedAt.high)))
                                return "addedAt: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a File message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.model.Block.Content.File
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.model.Block.Content.File} File
                     */
                    File.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.model.Block.Content.File)
                            return object;
                        var message = new $root.anytype.model.Block.Content.File();
                        if (object.localFilePath != null)
                            message.localFilePath = String(object.localFilePath);
                        if (object.previewFilePath != null)
                            message.previewFilePath = String(object.previewFilePath);
                        switch (object.state) {
                        case "Empty":
                        case 0:
                            message.state = 0;
                            break;
                        case "Uploading":
                        case 1:
                            message.state = 1;
                            break;
                        case "PreviewDownloaded":
                        case 2:
                            message.state = 2;
                            break;
                        case "Downloading":
                        case 3:
                            message.state = 3;
                            break;
                        case "Done":
                        case 4:
                            message.state = 4;
                            break;
                        }
                        switch (object.type) {
                        case "File":
                        case 0:
                            message.type = 0;
                            break;
                        case "Image":
                        case 1:
                            message.type = 1;
                            break;
                        case "Video":
                        case 2:
                            message.type = 2;
                            break;
                        }
                        if (object.size != null)
                            if ($util.Long)
                                (message.size = $util.Long.fromValue(object.size)).unsigned = false;
                            else if (typeof object.size === "string")
                                message.size = parseInt(object.size, 10);
                            else if (typeof object.size === "number")
                                message.size = object.size;
                            else if (typeof object.size === "object")
                                message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber();
                        if (object.addedAt != null)
                            if ($util.Long)
                                (message.addedAt = $util.Long.fromValue(object.addedAt)).unsigned = false;
                            else if (typeof object.addedAt === "string")
                                message.addedAt = parseInt(object.addedAt, 10);
                            else if (typeof object.addedAt === "number")
                                message.addedAt = object.addedAt;
                            else if (typeof object.addedAt === "object")
                                message.addedAt = new $util.LongBits(object.addedAt.low >>> 0, object.addedAt.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a File message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.model.Block.Content.File
                     * @static
                     * @param {anytype.model.Block.Content.File} message File
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    File.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.localFilePath = "";
                            object.previewFilePath = "";
                            object.state = options.enums === String ? "Empty" : 0;
                            object.type = options.enums === String ? "File" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.size = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.size = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, false);
                                object.addedAt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.addedAt = options.longs === String ? "0" : 0;
                        }
                        if (message.localFilePath != null && message.hasOwnProperty("localFilePath"))
                            object.localFilePath = message.localFilePath;
                        if (message.previewFilePath != null && message.hasOwnProperty("previewFilePath"))
                            object.previewFilePath = message.previewFilePath;
                        if (message.state != null && message.hasOwnProperty("state"))
                            object.state = options.enums === String ? $root.anytype.model.Block.Content.File.State[message.state] : message.state;
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = options.enums === String ? $root.anytype.model.Block.Content.File.Type[message.type] : message.type;
                        if (message.size != null && message.hasOwnProperty("size"))
                            if (typeof message.size === "number")
                                object.size = options.longs === String ? String(message.size) : message.size;
                            else
                                object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber() : message.size;
                        if (message.addedAt != null && message.hasOwnProperty("addedAt"))
                            if (typeof message.addedAt === "number")
                                object.addedAt = options.longs === String ? String(message.addedAt) : message.addedAt;
                            else
                                object.addedAt = options.longs === String ? $util.Long.prototype.toString.call(message.addedAt) : options.longs === Number ? new $util.LongBits(message.addedAt.low >>> 0, message.addedAt.high >>> 0).toNumber() : message.addedAt;
                        return object;
                    };

                    /**
                     * Converts this File to JSON.
                     * @function toJSON
                     * @memberof anytype.model.Block.Content.File
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    File.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Type enum.
                     * @name anytype.model.Block.Content.File.Type
                     * @enum {string}
                     * @property {number} File=0 File value
                     * @property {number} Image=1 Image value
                     * @property {number} Video=2 Video value
                     */
                    File.Type = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "File"] = 0;
                        values[valuesById[1] = "Image"] = 1;
                        values[valuesById[2] = "Video"] = 2;
                        return values;
                    })();

                    /**
                     * State enum.
                     * @name anytype.model.Block.Content.File.State
                     * @enum {string}
                     * @property {number} Empty=0 Empty value
                     * @property {number} Uploading=1 Uploading value
                     * @property {number} PreviewDownloaded=2 PreviewDownloaded value
                     * @property {number} Downloading=3 Downloading value
                     * @property {number} Done=4 Done value
                     */
                    File.State = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "Empty"] = 0;
                        values[valuesById[1] = "Uploading"] = 1;
                        values[valuesById[2] = "PreviewDownloaded"] = 2;
                        values[valuesById[3] = "Downloading"] = 3;
                        values[valuesById[4] = "Done"] = 4;
                        return values;
                    })();

                    return File;
                })();

                Content.Page = (function() {

                    /**
                     * Properties of a Page.
                     * @memberof anytype.model.Block.Content
                     * @interface IPage
                     * @property {anytype.model.Block.Content.Page.Style|null} [style] Page style
                     */

                    /**
                     * Constructs a new Page.
                     * @memberof anytype.model.Block.Content
                     * @classdesc Represents a Page.
                     * @implements IPage
                     * @constructor
                     * @param {anytype.model.Block.Content.IPage=} [properties] Properties to set
                     */
                    function Page(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Page style.
                     * @member {anytype.model.Block.Content.Page.Style} style
                     * @memberof anytype.model.Block.Content.Page
                     * @instance
                     */
                    Page.prototype.style = 0;

                    /**
                     * Creates a new Page instance using the specified properties.
                     * @function create
                     * @memberof anytype.model.Block.Content.Page
                     * @static
                     * @param {anytype.model.Block.Content.IPage=} [properties] Properties to set
                     * @returns {anytype.model.Block.Content.Page} Page instance
                     */
                    Page.create = function create(properties) {
                        return new Page(properties);
                    };

                    /**
                     * Encodes the specified Page message. Does not implicitly {@link anytype.model.Block.Content.Page.verify|verify} messages.
                     * @function encode
                     * @memberof anytype.model.Block.Content.Page
                     * @static
                     * @param {anytype.model.Block.Content.IPage} message Page message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Page.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.style != null && message.hasOwnProperty("style"))
                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.style);
                        return writer;
                    };

                    /**
                     * Encodes the specified Page message, length delimited. Does not implicitly {@link anytype.model.Block.Content.Page.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof anytype.model.Block.Content.Page
                     * @static
                     * @param {anytype.model.Block.Content.IPage} message Page message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Page.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes a Page message from the specified reader or buffer.
                     * @function decode
                     * @memberof anytype.model.Block.Content.Page
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {anytype.model.Block.Content.Page} Page
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Page.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Block.Content.Page();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.style = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes a Page message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof anytype.model.Block.Content.Page
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {anytype.model.Block.Content.Page} Page
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Page.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies a Page message.
                     * @function verify
                     * @memberof anytype.model.Block.Content.Page
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Page.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.style != null && message.hasOwnProperty("style"))
                            switch (message.style) {
                            default:
                                return "style: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a Page message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof anytype.model.Block.Content.Page
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {anytype.model.Block.Content.Page} Page
                     */
                    Page.fromObject = function fromObject(object) {
                        if (object instanceof $root.anytype.model.Block.Content.Page)
                            return object;
                        var message = new $root.anytype.model.Block.Content.Page();
                        switch (object.style) {
                        case "Empty":
                        case 0:
                            message.style = 0;
                            break;
                        case "Task":
                        case 1:
                            message.style = 1;
                            break;
                        case "Set":
                        case 2:
                            message.style = 2;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Page message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof anytype.model.Block.Content.Page
                     * @static
                     * @param {anytype.model.Block.Content.Page} message Page
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Page.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.style = options.enums === String ? "Empty" : 0;
                        if (message.style != null && message.hasOwnProperty("style"))
                            object.style = options.enums === String ? $root.anytype.model.Block.Content.Page.Style[message.style] : message.style;
                        return object;
                    };

                    /**
                     * Converts this Page to JSON.
                     * @function toJSON
                     * @memberof anytype.model.Block.Content.Page
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Page.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Style enum.
                     * @name anytype.model.Block.Content.Page.Style
                     * @enum {string}
                     * @property {number} Empty=0 Empty value
                     * @property {number} Task=1 Task value
                     * @property {number} Set=2 Set value
                     */
                    Page.Style = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "Empty"] = 0;
                        values[valuesById[1] = "Task"] = 1;
                        values[valuesById[2] = "Set"] = 2;
                        return values;
                    })();

                    return Page;
                })();

                return Content;
            })();

            return Block;
        })();

        model.Range = (function() {

            /**
             * Properties of a Range.
             * @memberof anytype.model
             * @interface IRange
             * @property {number|null} [from] Range from
             * @property {number|null} [to] Range to
             */

            /**
             * Constructs a new Range.
             * @memberof anytype.model
             * @classdesc Represents a Range.
             * @implements IRange
             * @constructor
             * @param {anytype.model.IRange=} [properties] Properties to set
             */
            function Range(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Range from.
             * @member {number} from
             * @memberof anytype.model.Range
             * @instance
             */
            Range.prototype.from = 0;

            /**
             * Range to.
             * @member {number} to
             * @memberof anytype.model.Range
             * @instance
             */
            Range.prototype.to = 0;

            /**
             * Creates a new Range instance using the specified properties.
             * @function create
             * @memberof anytype.model.Range
             * @static
             * @param {anytype.model.IRange=} [properties] Properties to set
             * @returns {anytype.model.Range} Range instance
             */
            Range.create = function create(properties) {
                return new Range(properties);
            };

            /**
             * Encodes the specified Range message. Does not implicitly {@link anytype.model.Range.verify|verify} messages.
             * @function encode
             * @memberof anytype.model.Range
             * @static
             * @param {anytype.model.IRange} message Range message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Range.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.from != null && message.hasOwnProperty("from"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.from);
                if (message.to != null && message.hasOwnProperty("to"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.to);
                return writer;
            };

            /**
             * Encodes the specified Range message, length delimited. Does not implicitly {@link anytype.model.Range.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.model.Range
             * @static
             * @param {anytype.model.IRange} message Range message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Range.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Range message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.model.Range
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.model.Range} Range
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Range.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Range();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.from = reader.int32();
                        break;
                    case 2:
                        message.to = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Range message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.model.Range
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.model.Range} Range
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Range.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Range message.
             * @function verify
             * @memberof anytype.model.Range
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Range.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.from != null && message.hasOwnProperty("from"))
                    if (!$util.isInteger(message.from))
                        return "from: integer expected";
                if (message.to != null && message.hasOwnProperty("to"))
                    if (!$util.isInteger(message.to))
                        return "to: integer expected";
                return null;
            };

            /**
             * Creates a Range message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.model.Range
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.model.Range} Range
             */
            Range.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.model.Range)
                    return object;
                var message = new $root.anytype.model.Range();
                if (object.from != null)
                    message.from = object.from | 0;
                if (object.to != null)
                    message.to = object.to | 0;
                return message;
            };

            /**
             * Creates a plain object from a Range message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.model.Range
             * @static
             * @param {anytype.model.Range} message Range
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Range.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.from = 0;
                    object.to = 0;
                }
                if (message.from != null && message.hasOwnProperty("from"))
                    object.from = message.from;
                if (message.to != null && message.hasOwnProperty("to"))
                    object.to = message.to;
                return object;
            };

            /**
             * Converts this Range to JSON.
             * @function toJSON
             * @memberof anytype.model.Range
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Range.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Range;
        })();

        model.Account = (function() {

            /**
             * Properties of an Account.
             * @memberof anytype.model
             * @interface IAccount
             * @property {string|null} [id] Account id
             * @property {string|null} [name] Account name
             * @property {anytype.model.Account.IAvatar|null} [avatar] Account avatar
             */

            /**
             * Constructs a new Account.
             * @memberof anytype.model
             * @classdesc Contains basic information about a user account
             * @implements IAccount
             * @constructor
             * @param {anytype.model.IAccount=} [properties] Properties to set
             */
            function Account(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Account id.
             * @member {string} id
             * @memberof anytype.model.Account
             * @instance
             */
            Account.prototype.id = "";

            /**
             * Account name.
             * @member {string} name
             * @memberof anytype.model.Account
             * @instance
             */
            Account.prototype.name = "";

            /**
             * Account avatar.
             * @member {anytype.model.Account.IAvatar|null|undefined} avatar
             * @memberof anytype.model.Account
             * @instance
             */
            Account.prototype.avatar = null;

            /**
             * Creates a new Account instance using the specified properties.
             * @function create
             * @memberof anytype.model.Account
             * @static
             * @param {anytype.model.IAccount=} [properties] Properties to set
             * @returns {anytype.model.Account} Account instance
             */
            Account.create = function create(properties) {
                return new Account(properties);
            };

            /**
             * Encodes the specified Account message. Does not implicitly {@link anytype.model.Account.verify|verify} messages.
             * @function encode
             * @memberof anytype.model.Account
             * @static
             * @param {anytype.model.IAccount} message Account message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Account.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.name != null && message.hasOwnProperty("name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    $root.anytype.model.Account.Avatar.encode(message.avatar, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Account message, length delimited. Does not implicitly {@link anytype.model.Account.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.model.Account
             * @static
             * @param {anytype.model.IAccount} message Account message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Account.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Account message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.model.Account
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.model.Account} Account
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Account.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Account();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.avatar = $root.anytype.model.Account.Avatar.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Account message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.model.Account
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.model.Account} Account
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Account.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Account message.
             * @function verify
             * @memberof anytype.model.Account
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Account.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.avatar != null && message.hasOwnProperty("avatar")) {
                    var error = $root.anytype.model.Account.Avatar.verify(message.avatar);
                    if (error)
                        return "avatar." + error;
                }
                return null;
            };

            /**
             * Creates an Account message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.model.Account
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.model.Account} Account
             */
            Account.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.model.Account)
                    return object;
                var message = new $root.anytype.model.Account();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.avatar != null) {
                    if (typeof object.avatar !== "object")
                        throw TypeError(".anytype.model.Account.avatar: object expected");
                    message.avatar = $root.anytype.model.Account.Avatar.fromObject(object.avatar);
                }
                return message;
            };

            /**
             * Creates a plain object from an Account message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.model.Account
             * @static
             * @param {anytype.model.Account} message Account
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Account.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = "";
                    object.name = "";
                    object.avatar = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    object.avatar = $root.anytype.model.Account.Avatar.toObject(message.avatar, options);
                return object;
            };

            /**
             * Converts this Account to JSON.
             * @function toJSON
             * @memberof anytype.model.Account
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Account.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Account.Avatar = (function() {

                /**
                 * Properties of an Avatar.
                 * @memberof anytype.model.Account
                 * @interface IAvatar
                 * @property {anytype.model.IImage|null} [image] Avatar image
                 * @property {string|null} [color] Avatar color
                 */

                /**
                 * Constructs a new Avatar.
                 * @memberof anytype.model.Account
                 * @classdesc Avatar of a user's account. It could be an image or color
                 * @implements IAvatar
                 * @constructor
                 * @param {anytype.model.Account.IAvatar=} [properties] Properties to set
                 */
                function Avatar(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Avatar image.
                 * @member {anytype.model.IImage|null|undefined} image
                 * @memberof anytype.model.Account.Avatar
                 * @instance
                 */
                Avatar.prototype.image = null;

                /**
                 * Avatar color.
                 * @member {string} color
                 * @memberof anytype.model.Account.Avatar
                 * @instance
                 */
                Avatar.prototype.color = "";

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * Avatar avatar.
                 * @member {"image"|"color"|undefined} avatar
                 * @memberof anytype.model.Account.Avatar
                 * @instance
                 */
                Object.defineProperty(Avatar.prototype, "avatar", {
                    get: $util.oneOfGetter($oneOfFields = ["image", "color"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Avatar instance using the specified properties.
                 * @function create
                 * @memberof anytype.model.Account.Avatar
                 * @static
                 * @param {anytype.model.Account.IAvatar=} [properties] Properties to set
                 * @returns {anytype.model.Account.Avatar} Avatar instance
                 */
                Avatar.create = function create(properties) {
                    return new Avatar(properties);
                };

                /**
                 * Encodes the specified Avatar message. Does not implicitly {@link anytype.model.Account.Avatar.verify|verify} messages.
                 * @function encode
                 * @memberof anytype.model.Account.Avatar
                 * @static
                 * @param {anytype.model.Account.IAvatar} message Avatar message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Avatar.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.image != null && message.hasOwnProperty("image"))
                        $root.anytype.model.Image.encode(message.image, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.color != null && message.hasOwnProperty("color"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.color);
                    return writer;
                };

                /**
                 * Encodes the specified Avatar message, length delimited. Does not implicitly {@link anytype.model.Account.Avatar.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof anytype.model.Account.Avatar
                 * @static
                 * @param {anytype.model.Account.IAvatar} message Avatar message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Avatar.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Avatar message from the specified reader or buffer.
                 * @function decode
                 * @memberof anytype.model.Account.Avatar
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {anytype.model.Account.Avatar} Avatar
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Avatar.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Account.Avatar();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.image = $root.anytype.model.Image.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.color = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Avatar message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof anytype.model.Account.Avatar
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {anytype.model.Account.Avatar} Avatar
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Avatar.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Avatar message.
                 * @function verify
                 * @memberof anytype.model.Account.Avatar
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Avatar.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.image != null && message.hasOwnProperty("image")) {
                        properties.avatar = 1;
                        {
                            var error = $root.anytype.model.Image.verify(message.image);
                            if (error)
                                return "image." + error;
                        }
                    }
                    if (message.color != null && message.hasOwnProperty("color")) {
                        if (properties.avatar === 1)
                            return "avatar: multiple values";
                        properties.avatar = 1;
                        if (!$util.isString(message.color))
                            return "color: string expected";
                    }
                    return null;
                };

                /**
                 * Creates an Avatar message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof anytype.model.Account.Avatar
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {anytype.model.Account.Avatar} Avatar
                 */
                Avatar.fromObject = function fromObject(object) {
                    if (object instanceof $root.anytype.model.Account.Avatar)
                        return object;
                    var message = new $root.anytype.model.Account.Avatar();
                    if (object.image != null) {
                        if (typeof object.image !== "object")
                            throw TypeError(".anytype.model.Account.Avatar.image: object expected");
                        message.image = $root.anytype.model.Image.fromObject(object.image);
                    }
                    if (object.color != null)
                        message.color = String(object.color);
                    return message;
                };

                /**
                 * Creates a plain object from an Avatar message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof anytype.model.Account.Avatar
                 * @static
                 * @param {anytype.model.Account.Avatar} message Avatar
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Avatar.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.image != null && message.hasOwnProperty("image")) {
                        object.image = $root.anytype.model.Image.toObject(message.image, options);
                        if (options.oneofs)
                            object.avatar = "image";
                    }
                    if (message.color != null && message.hasOwnProperty("color")) {
                        object.color = message.color;
                        if (options.oneofs)
                            object.avatar = "color";
                    }
                    return object;
                };

                /**
                 * Converts this Avatar to JSON.
                 * @function toJSON
                 * @memberof anytype.model.Account.Avatar
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Avatar.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Avatar;
            })();

            return Account;
        })();

        model.Image = (function() {

            /**
             * Properties of an Image.
             * @memberof anytype.model
             * @interface IImage
             * @property {string|null} [id] Image id
             * @property {Array.<anytype.model.Image.Size>|null} [sizes] Image sizes
             * @property {anytype.model.Image.Style|null} [style] Image style
             */

            /**
             * Constructs a new Image.
             * @memberof anytype.model
             * @classdesc Represents an Image.
             * @implements IImage
             * @constructor
             * @param {anytype.model.IImage=} [properties] Properties to set
             */
            function Image(properties) {
                this.sizes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Image id.
             * @member {string} id
             * @memberof anytype.model.Image
             * @instance
             */
            Image.prototype.id = "";

            /**
             * Image sizes.
             * @member {Array.<anytype.model.Image.Size>} sizes
             * @memberof anytype.model.Image
             * @instance
             */
            Image.prototype.sizes = $util.emptyArray;

            /**
             * Image style.
             * @member {anytype.model.Image.Style} style
             * @memberof anytype.model.Image
             * @instance
             */
            Image.prototype.style = 0;

            /**
             * Creates a new Image instance using the specified properties.
             * @function create
             * @memberof anytype.model.Image
             * @static
             * @param {anytype.model.IImage=} [properties] Properties to set
             * @returns {anytype.model.Image} Image instance
             */
            Image.create = function create(properties) {
                return new Image(properties);
            };

            /**
             * Encodes the specified Image message. Does not implicitly {@link anytype.model.Image.verify|verify} messages.
             * @function encode
             * @memberof anytype.model.Image
             * @static
             * @param {anytype.model.IImage} message Image message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Image.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.sizes != null && message.sizes.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.sizes.length; ++i)
                        writer.int32(message.sizes[i]);
                    writer.ldelim();
                }
                if (message.style != null && message.hasOwnProperty("style"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.style);
                return writer;
            };

            /**
             * Encodes the specified Image message, length delimited. Does not implicitly {@link anytype.model.Image.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.model.Image
             * @static
             * @param {anytype.model.IImage} message Image message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Image.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Image message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.model.Image
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.model.Image} Image
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Image.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Image();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        if (!(message.sizes && message.sizes.length))
                            message.sizes = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.sizes.push(reader.int32());
                        } else
                            message.sizes.push(reader.int32());
                        break;
                    case 3:
                        message.style = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Image message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.model.Image
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.model.Image} Image
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Image.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Image message.
             * @function verify
             * @memberof anytype.model.Image
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Image.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.sizes != null && message.hasOwnProperty("sizes")) {
                    if (!Array.isArray(message.sizes))
                        return "sizes: array expected";
                    for (var i = 0; i < message.sizes.length; ++i)
                        switch (message.sizes[i]) {
                        default:
                            return "sizes: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                }
                if (message.style != null && message.hasOwnProperty("style"))
                    switch (message.style) {
                    default:
                        return "style: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates an Image message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.model.Image
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.model.Image} Image
             */
            Image.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.model.Image)
                    return object;
                var message = new $root.anytype.model.Image();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.sizes) {
                    if (!Array.isArray(object.sizes))
                        throw TypeError(".anytype.model.Image.sizes: array expected");
                    message.sizes = [];
                    for (var i = 0; i < object.sizes.length; ++i)
                        switch (object.sizes[i]) {
                        default:
                        case "Large":
                        case 0:
                            message.sizes[i] = 0;
                            break;
                        case "Small":
                        case 1:
                            message.sizes[i] = 1;
                            break;
                        case "Thumb":
                        case 2:
                            message.sizes[i] = 2;
                            break;
                        }
                }
                switch (object.style) {
                case "Picture":
                case 0:
                    message.style = 0;
                    break;
                case "File":
                case 1:
                    message.style = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an Image message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.model.Image
             * @static
             * @param {anytype.model.Image} message Image
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Image.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.sizes = [];
                if (options.defaults) {
                    object.id = "";
                    object.style = options.enums === String ? "Picture" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.sizes && message.sizes.length) {
                    object.sizes = [];
                    for (var j = 0; j < message.sizes.length; ++j)
                        object.sizes[j] = options.enums === String ? $root.anytype.model.Image.Size[message.sizes[j]] : message.sizes[j];
                }
                if (message.style != null && message.hasOwnProperty("style"))
                    object.style = options.enums === String ? $root.anytype.model.Image.Style[message.style] : message.style;
                return object;
            };

            /**
             * Converts this Image to JSON.
             * @function toJSON
             * @memberof anytype.model.Image
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Image.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Size enum.
             * @name anytype.model.Image.Size
             * @enum {string}
             * @property {number} Large=0 Large value
             * @property {number} Small=1 Small value
             * @property {number} Thumb=2 Thumb value
             */
            Image.Size = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Large"] = 0;
                values[valuesById[1] = "Small"] = 1;
                values[valuesById[2] = "Thumb"] = 2;
                return values;
            })();

            /**
             * Style enum.
             * @name anytype.model.Image.Style
             * @enum {string}
             * @property {number} Picture=0 Picture value
             * @property {number} File=1 File value
             */
            Image.Style = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "Picture"] = 0;
                values[valuesById[1] = "File"] = 1;
                return values;
            })();

            return Image;
        })();

        model.Video = (function() {

            /**
             * Properties of a Video.
             * @memberof anytype.model
             * @interface IVideo
             * @property {string|null} [id] Video id
             * @property {Array.<anytype.model.Video.Size>|null} [sizes] Video sizes
             */

            /**
             * Constructs a new Video.
             * @memberof anytype.model
             * @classdesc Represents a Video.
             * @implements IVideo
             * @constructor
             * @param {anytype.model.IVideo=} [properties] Properties to set
             */
            function Video(properties) {
                this.sizes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Video id.
             * @member {string} id
             * @memberof anytype.model.Video
             * @instance
             */
            Video.prototype.id = "";

            /**
             * Video sizes.
             * @member {Array.<anytype.model.Video.Size>} sizes
             * @memberof anytype.model.Video
             * @instance
             */
            Video.prototype.sizes = $util.emptyArray;

            /**
             * Creates a new Video instance using the specified properties.
             * @function create
             * @memberof anytype.model.Video
             * @static
             * @param {anytype.model.IVideo=} [properties] Properties to set
             * @returns {anytype.model.Video} Video instance
             */
            Video.create = function create(properties) {
                return new Video(properties);
            };

            /**
             * Encodes the specified Video message. Does not implicitly {@link anytype.model.Video.verify|verify} messages.
             * @function encode
             * @memberof anytype.model.Video
             * @static
             * @param {anytype.model.IVideo} message Video message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Video.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && message.hasOwnProperty("id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.sizes != null && message.sizes.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.sizes.length; ++i)
                        writer.int32(message.sizes[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified Video message, length delimited. Does not implicitly {@link anytype.model.Video.verify|verify} messages.
             * @function encodeDelimited
             * @memberof anytype.model.Video
             * @static
             * @param {anytype.model.IVideo} message Video message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Video.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Video message from the specified reader or buffer.
             * @function decode
             * @memberof anytype.model.Video
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {anytype.model.Video} Video
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Video.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.anytype.model.Video();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.string();
                        break;
                    case 2:
                        if (!(message.sizes && message.sizes.length))
                            message.sizes = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.sizes.push(reader.int32());
                        } else
                            message.sizes.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Video message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof anytype.model.Video
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {anytype.model.Video} Video
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Video.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Video message.
             * @function verify
             * @memberof anytype.model.Video
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Video.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.sizes != null && message.hasOwnProperty("sizes")) {
                    if (!Array.isArray(message.sizes))
                        return "sizes: array expected";
                    for (var i = 0; i < message.sizes.length; ++i)
                        switch (message.sizes[i]) {
                        default:
                            return "sizes: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                }
                return null;
            };

            /**
             * Creates a Video message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof anytype.model.Video
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {anytype.model.Video} Video
             */
            Video.fromObject = function fromObject(object) {
                if (object instanceof $root.anytype.model.Video)
                    return object;
                var message = new $root.anytype.model.Video();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.sizes) {
                    if (!Array.isArray(object.sizes))
                        throw TypeError(".anytype.model.Video.sizes: array expected");
                    message.sizes = [];
                    for (var i = 0; i < object.sizes.length; ++i)
                        switch (object.sizes[i]) {
                        default:
                        case "SD360p":
                        case 0:
                            message.sizes[i] = 0;
                            break;
                        case "SD480p":
                        case 1:
                            message.sizes[i] = 1;
                            break;
                        case "HD720p":
                        case 2:
                            message.sizes[i] = 2;
                            break;
                        case "HD1080p":
                        case 3:
                            message.sizes[i] = 3;
                            break;
                        case "UHD1440p":
                        case 4:
                            message.sizes[i] = 4;
                            break;
                        case "UHD2160p":
                        case 5:
                            message.sizes[i] = 5;
                            break;
                        }
                }
                return message;
            };

            /**
             * Creates a plain object from a Video message. Also converts values to other types if specified.
             * @function toObject
             * @memberof anytype.model.Video
             * @static
             * @param {anytype.model.Video} message Video
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Video.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.sizes = [];
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.sizes && message.sizes.length) {
                    object.sizes = [];
                    for (var j = 0; j < message.sizes.length; ++j)
                        object.sizes[j] = options.enums === String ? $root.anytype.model.Video.Size[message.sizes[j]] : message.sizes[j];
                }
                return object;
            };

            /**
             * Converts this Video to JSON.
             * @function toJSON
             * @memberof anytype.model.Video
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Video.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Size enum.
             * @name anytype.model.Video.Size
             * @enum {string}
             * @property {number} SD360p=0 SD360p value
             * @property {number} SD480p=1 SD480p value
             * @property {number} HD720p=2 HD720p value
             * @property {number} HD1080p=3 HD1080p value
             * @property {number} UHD1440p=4 UHD1440p value
             * @property {number} UHD2160p=5 UHD2160p value
             */
            Video.Size = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SD360p"] = 0;
                values[valuesById[1] = "SD480p"] = 1;
                values[valuesById[2] = "HD720p"] = 2;
                values[valuesById[3] = "HD1080p"] = 3;
                values[valuesById[4] = "UHD1440p"] = 4;
                values[valuesById[5] = "UHD2160p"] = 5;
                return values;
            })();

            return Video;
        })();

        return model;
    })();

    return anytype;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Struct = (function() {

            /**
             * Properties of a Struct.
             * @memberof google.protobuf
             * @interface IStruct
             * @property {Object.<string,google.protobuf.IValue>|null} [fields] Struct fields
             */

            /**
             * Constructs a new Struct.
             * @memberof google.protobuf
             * @classdesc Represents a Struct.
             * @implements IStruct
             * @constructor
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             */
            function Struct(properties) {
                this.fields = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Struct fields.
             * @member {Object.<string,google.protobuf.IValue>} fields
             * @memberof google.protobuf.Struct
             * @instance
             */
            Struct.prototype.fields = $util.emptyObject;

            /**
             * Creates a new Struct instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             * @returns {google.protobuf.Struct} Struct instance
             */
            Struct.create = function create(properties) {
                return new Struct(properties);
            };

            /**
             * Encodes the specified Struct message. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fields != null && message.hasOwnProperty("fields"))
                    for (var keys = Object.keys(message.fields), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.google.protobuf.Value.encode(message.fields[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified Struct message, length delimited. Does not implicitly {@link google.protobuf.Struct.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.IStruct} message Struct message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Struct.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Struct message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Struct(), key;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        reader.skip().pos++;
                        if (message.fields === $util.emptyObject)
                            message.fields = {};
                        key = reader.string();
                        reader.pos++;
                        message.fields[key] = $root.google.protobuf.Value.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Struct message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Struct
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Struct} Struct
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Struct.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Struct message.
             * @function verify
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Struct.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!$util.isObject(message.fields))
                        return "fields: object expected";
                    var key = Object.keys(message.fields);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.google.protobuf.Value.verify(message.fields[key[i]]);
                        if (error)
                            return "fields." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Struct message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Struct} Struct
             */
            Struct.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Struct)
                    return object;
                var message = new $root.google.protobuf.Struct();
                if (object.fields) {
                    if (typeof object.fields !== "object")
                        throw TypeError(".google.protobuf.Struct.fields: object expected");
                    message.fields = {};
                    for (var keys = Object.keys(object.fields), i = 0; i < keys.length; ++i) {
                        if (typeof object.fields[keys[i]] !== "object")
                            throw TypeError(".google.protobuf.Struct.fields: object expected");
                        message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Struct message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.Struct} message Struct
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Struct.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.fields = {};
                var keys2;
                if (message.fields && (keys2 = Object.keys(message.fields)).length) {
                    object.fields = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this Struct to JSON.
             * @function toJSON
             * @memberof google.protobuf.Struct
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Struct.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Struct;
        })();

        protobuf.Value = (function() {

            /**
             * Properties of a Value.
             * @memberof google.protobuf
             * @interface IValue
             * @property {google.protobuf.NullValue|null} [nullValue] Value nullValue
             * @property {number|null} [numberValue] Value numberValue
             * @property {string|null} [stringValue] Value stringValue
             * @property {boolean|null} [boolValue] Value boolValue
             * @property {google.protobuf.IStruct|null} [structValue] Value structValue
             * @property {google.protobuf.IListValue|null} [listValue] Value listValue
             */

            /**
             * Constructs a new Value.
             * @memberof google.protobuf
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {google.protobuf.IValue=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Value nullValue.
             * @member {google.protobuf.NullValue} nullValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.nullValue = 0;

            /**
             * Value numberValue.
             * @member {number} numberValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.numberValue = 0;

            /**
             * Value stringValue.
             * @member {string} stringValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.stringValue = "";

            /**
             * Value boolValue.
             * @member {boolean} boolValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.boolValue = false;

            /**
             * Value structValue.
             * @member {google.protobuf.IStruct|null|undefined} structValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.structValue = null;

            /**
             * Value listValue.
             * @member {google.protobuf.IListValue|null|undefined} listValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.listValue = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Value kind.
             * @member {"nullValue"|"numberValue"|"stringValue"|"boolValue"|"structValue"|"listValue"|undefined} kind
             * @memberof google.protobuf.Value
             * @instance
             */
            Object.defineProperty(Value.prototype, "kind", {
                get: $util.oneOfGetter($oneOfFields = ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Value instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue=} [properties] Properties to set
             * @returns {google.protobuf.Value} Value instance
             */
            Value.create = function create(properties) {
                return new Value(properties);
            };

            /**
             * Encodes the specified Value message. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nullValue != null && message.hasOwnProperty("nullValue"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.nullValue);
                if (message.numberValue != null && message.hasOwnProperty("numberValue"))
                    writer.uint32(/* id 2, wireType 1 =*/17).double(message.numberValue);
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.stringValue);
                if (message.boolValue != null && message.hasOwnProperty("boolValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.boolValue);
                if (message.structValue != null && message.hasOwnProperty("structValue"))
                    $root.google.protobuf.Struct.encode(message.structValue, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.listValue != null && message.hasOwnProperty("listValue"))
                    $root.google.protobuf.ListValue.encode(message.listValue, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Value message, length delimited. Does not implicitly {@link google.protobuf.Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Value message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nullValue = reader.int32();
                        break;
                    case 2:
                        message.numberValue = reader.double();
                        break;
                    case 3:
                        message.stringValue = reader.string();
                        break;
                    case 4:
                        message.boolValue = reader.bool();
                        break;
                    case 5:
                        message.structValue = $root.google.protobuf.Struct.decode(reader, reader.uint32());
                        break;
                    case 6:
                        message.listValue = $root.google.protobuf.ListValue.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Value message.
             * @function verify
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    properties.kind = 1;
                    switch (message.nullValue) {
                    default:
                        return "nullValue: enum value expected";
                    case 0:
                        break;
                    }
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.numberValue !== "number")
                        return "numberValue: number expected";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.boolValue !== "boolean")
                        return "boolValue: boolean expected";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        var error = $root.google.protobuf.Struct.verify(message.structValue);
                        if (error)
                            return "structValue." + error;
                    }
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        var error = $root.google.protobuf.ListValue.verify(message.listValue);
                        if (error)
                            return "listValue." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Value} Value
             */
            Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Value)
                    return object;
                var message = new $root.google.protobuf.Value();
                switch (object.nullValue) {
                case "NULL_VALUE":
                case 0:
                    message.nullValue = 0;
                    break;
                }
                if (object.numberValue != null)
                    message.numberValue = Number(object.numberValue);
                if (object.stringValue != null)
                    message.stringValue = String(object.stringValue);
                if (object.boolValue != null)
                    message.boolValue = Boolean(object.boolValue);
                if (object.structValue != null) {
                    if (typeof object.structValue !== "object")
                        throw TypeError(".google.protobuf.Value.structValue: object expected");
                    message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);
                }
                if (object.listValue != null) {
                    if (typeof object.listValue !== "object")
                        throw TypeError(".google.protobuf.Value.listValue: object expected");
                    message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);
                }
                return message;
            };

            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;
                    if (options.oneofs)
                        object.kind = "nullValue";
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;
                    if (options.oneofs)
                        object.kind = "numberValue";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    object.stringValue = message.stringValue;
                    if (options.oneofs)
                        object.kind = "stringValue";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    object.boolValue = message.boolValue;
                    if (options.oneofs)
                        object.kind = "boolValue";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);
                    if (options.oneofs)
                        object.kind = "structValue";
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);
                    if (options.oneofs)
                        object.kind = "listValue";
                }
                return object;
            };

            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Value;
        })();

        /**
         * NullValue enum.
         * @name google.protobuf.NullValue
         * @enum {string}
         * @property {number} NULL_VALUE=0 NULL_VALUE value
         */
        protobuf.NullValue = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NULL_VALUE"] = 0;
            return values;
        })();

        protobuf.ListValue = (function() {

            /**
             * Properties of a ListValue.
             * @memberof google.protobuf
             * @interface IListValue
             * @property {Array.<google.protobuf.IValue>|null} [values] ListValue values
             */

            /**
             * Constructs a new ListValue.
             * @memberof google.protobuf
             * @classdesc Represents a ListValue.
             * @implements IListValue
             * @constructor
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             */
            function ListValue(properties) {
                this.values = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListValue values.
             * @member {Array.<google.protobuf.IValue>} values
             * @memberof google.protobuf.ListValue
             * @instance
             */
            ListValue.prototype.values = $util.emptyArray;

            /**
             * Creates a new ListValue instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             * @returns {google.protobuf.ListValue} ListValue instance
             */
            ListValue.create = function create(properties) {
                return new ListValue(properties);
            };

            /**
             * Encodes the specified ListValue message. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.values != null && message.values.length)
                    for (var i = 0; i < message.values.length; ++i)
                        $root.google.protobuf.Value.encode(message.values[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListValue message, length delimited. Does not implicitly {@link google.protobuf.ListValue.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.IListValue} message ListValue message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListValue.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ListValue();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.values && message.values.length))
                            message.values = [];
                        message.values.push($root.google.protobuf.Value.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListValue message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ListValue
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ListValue} ListValue
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListValue.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListValue message.
             * @function verify
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (var i = 0; i < message.values.length; ++i) {
                        var error = $root.google.protobuf.Value.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ListValue} ListValue
             */
            ListValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ListValue)
                    return object;
                var message = new $root.google.protobuf.ListValue();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".google.protobuf.ListValue.values: array expected");
                    message.values = [];
                    for (var i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".google.protobuf.ListValue.values: object expected");
                        message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.ListValue} message ListValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (var j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);
                }
                return object;
            };

            /**
             * Converts this ListValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.ListValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListValue;
        })();

        return protobuf;
    })();

    return google;
})();

module.exports = $root;
